---
title: 프로그래머스 - 피로도(Lv2)
category: Algorithems
order: 9
---

### 알고리즘
##### DFS란?
![DFS](https://drive.google.com/uc?id=1ctZWV-TtoEhDOJfV8UYhDYwcbx3g2qg7)

DFS는 '깊이 우선 탐색'을 의미한다. <br>
이는 그래프나 트리와 같은 자료 구조에서 사용되는 탐색 알고리즘 중 하나이며 <br> 
DFS는 문자그대로 가능한 한 깊숙한 깊이까지 들어가면서<br> 더 이상 탐색할 곳이 없을 때까지 탐색을 진행한다.<br>
<br>
탐색을 시작한 노드에서 한 방향으로 최대한 깊게 들어가다가 더 이상 진행할 수 없게 되면,<br> 되돌아가서 다른 경로로 탐색을 진행하는데 <br>이러한 과정을 재귀적으로 구현하거나 스택을 사용하여 반복적으로 구현할 수 있다<br>

### 프로그래머스 문제
> 문제 설명

XX게임에는 피로도 시스템(0 이상의 정수로 표현합니다)이 있으며, 일정 피로도를 사용해서 던전을 탐험할 수 있습니다. 이때, 각 던전마다 탐험을 시작하기 위해 필요한 "최소 필요 피로도"와 던전 탐험을 마쳤을 때 소모되는 "소모 피로도"가 있습니다. "최소 필요 피로도"는 해당 던전을 탐험하기 위해 가지고 있어야 하는 최소한의 피로도를 나타내며, "소모 피로도"는 던전을 탐험한 후 소모되는 피로도를 나타냅니다. 예를 들어 "최소 필요 피로도"가 80, "소모 피로도"가 20인 던전을 탐험하기 위해서는 유저의 현재 남은 피로도는 80 이상 이어야 하며, 던전을 탐험한 후에는 피로도 20이 소모됩니다.

이 게임에는 하루에 한 번씩 탐험할 수 있는 던전이 여러개 있는데, 한 유저가 오늘 이 던전들을 최대한 많이 탐험하려 합니다. 유저의 현재 피로도 k와 각 던전별 "최소 필요 피로도", "소모 피로도"가 담긴 2차원 배열 dungeons 가 매개변수로 주어질 때, 유저가 탐험할수 있는 최대 던전 수를 return 하도록 solution 함수를 완성해주세요.

>제한사항

k는 1 이상 5,000 이하인 자연수입니다.
dungeons의 세로(행) 길이(즉, 던전의 개수)는 1 이상 8 이하입니다.
dungeons의 가로(열) 길이는 2 입니다.
dungeons의 각 행은 각 던전의 ["최소 필요 피로도", "소모 피로도"] 입니다.
"최소 필요 피로도"는 항상 "소모 피로도"보다 크거나 같습니다.
"최소 필요 피로도"와 "소모 피로도"는 1 이상 1,000 이하인 자연수입니다.
서로 다른 던전의 ["최소 필요 피로도", "소모 피로도"]가 서로 같을 수 있습니다.

##### 문제분석
이 문제는 유저가 현재 가진 피로도를 이용하여 던전을 탐험하여 최대한 많은 던전을 탐험하는 경우의 수를 찾는 문제다.<br>
먼저 DP로 도전을 해보았는데 절대 안풀렸다. <br>
DFS는 이럴때 DP와 유사한 기능을 하며 탐색을 효과적으로 할 수 있는 방법임<br> 
이 문제에서 유저는 현재 가진 피로도를 이용하여 각 던전을 탐험해야 하는데<br> 
주어진 던전의 개수가 작고,<br> 
각 던전을 방문할 때마다 유저의 현재 피로도가 변경되며 던전을 탐험하는 경우,<br> DFS를 사용하여 유저가 탐험할 수 있는 최대 던전 수를 찾을 수 있다.<br> 
각 던전을 방문할 때마다 유저의 현재 피로도를 고려하고,<br> 탐험 가능한 던전으로 이동하여 최대한 많은 던전을 탐험하는 방식으로 DFS를 활용할 수 있다<br>

DFS는 이러한 상황에서 현재 상태를 유지하면서 가능한 모든 경로를 탐색하므로,<br> 주어진 조건에서 최대한 많은 던전을 탐험하는 경우를 찾을 수 있다.<br>
 따라서, 주어진 문제를 DFS를 활용하여 푸는 것이 적합한 방법이라고 생각했다.<br>

 이후 DP로 풀수있을것 같아서 질문하기를 보니 나와같은생각을 한사람이 있었고, "최소 필요 피로도"와 "소모 피로도"의 차이를 기준으로 던전 배열을 정렬하면 DP로 풀이가 가능하다는 힌트를 얻었다. 이를통해 DP로도 다시 풀어보았고 성공했음. 

![DFS](https://drive.google.com/uc?id=12ets1F_NRgE7sfm52dbjGn5M7lDtt3Si)

##### 문제풀이

```java
class Solution {
    // 던전의 개수
    static int len;
    // 던전 정보를 담을 배열
    static int[][] arr;
    // 던전 방문 여부를 나타내는 배열
    static boolean[] visited;
    // 최종적으로 반환될 정답
    static int answer;

    // 주어진 던전 탐험 문제를 해결하는 메서드
    public int solution(int k, int[][] dungeons) {
        // 전역 배열에 입력된 던전 정보 할당
        arr = dungeons;
        // 던전 개수 설정
        len = dungeons.length;
        // 던전 방문 여부를 표시할 배열 초기화
        visited = new boolean[len];
        
        // DFS 호출하여 던전 탐험 시작
        recursive(0, k);
        
        // 최종 정답 반환
        return answer;
    }

    // DFS를 통해 던전을 탐험하는 메서드
    private void recursive(int idx, int k) {
        // 모든 던전을 순회
        for (int i = 0; i < len; i++) {
            // 이미 방문한 던전이거나, 현재 던전을 갈 수 없는 경우 건너뜀
            if (visited[i] || arr[i][0] > k) {
                continue;
            }
            
            // 현재 던전을 방문했다고 표시
            visited[i] = true;
            // 다음 던전으로 이동하며 체력 조정
            recursive(idx + 1, k - arr[i][1]);
            // 현재 던전 방문을 취소하여 다른 경로에서의 탐색을 위해 초기화
            visited[i] = false;
        }
        // 가장 많이 방문한 던전 수 업데이트
        answer = Math.max(idx, answer);
    }
}

```

```java
import java.util.*;

public class Solution {
    public int solution(int k, int[][] dungeons) {
        // 던전의 개수
        int len = dungeons.length;
        
        // 던전을 "최소 필요 피로도"와 "소모 피로도"의 차이를 기준으로 정렬한다.
        Arrays.sort(dungeons, new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                // "최소 필요 피로도"와 "소모 피로도"의 차이를 비교하여 정렬한다.
                return (a[0] - a[1]) - (b[0] - b[1]);
            }
        });

        // DP 테이블 초기화
        // dp[i][j]: i번째 던전까지 고려했을 때, j 피로도로 얻을 수 있는 최대 던전 개수
        int[][] dp = new int[len + 1][k + 1];

        // 각 던전을 순차적으로 탐색하며 DP 테이블을 채운다.
        for (int i = 1; i <= len; i++) {
            for (int r = 1; r <= k; r++) {
                // 현재 던전의 필요 피로도가 현재 피로도를 초과하는 경우,
                // 현재 던전을 탐험할 수 없으므로 직전까지의 값으로 업데이트한다.
                if (dungeons[i - 1][0] > r) {
                    dp[i][r] = dp[i - 1][r];
                } else {
                    // 현재 던전을 탐험할 수 있는 경우,
                    // 현재 던전을 탐험했을 때와 탐험하지 않았을 때 중 더 큰 값을 선택하여 DP 테이블을 갱신한다.
                    dp[i][r] = Math.max(
                        dp[i - 1][r], 1 + dp[i - 1][r - dungeons[i - 1][1]]
                    );
                }
            }
        }
        
        // 마지막 던전까지 고려한 후, 주어진 피로도로 얻을 수 있는 최대 던전 개수를 반환한다.
        return dp[len][k];
    }
}

```

![결과](https://drive.google.com/uc?id=12ieuhiN1x20wkjhBZxKum0LqbXkE4_PZ)
