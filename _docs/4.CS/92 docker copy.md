---
title: ...
category: Computer Science
order: 99
---
### Java

<details markdown = "1">
<summary>자바의 특징에 대해 설명해주세요.</summary>
자바는 객체 지향 프로그래밍 언어로 캡슐화,상속,다형성,추상화와 같은 객체 지향 원리를 제공하여 코드의 재사용성과 유지보수성을 높여줍니다.<br>
또한 자바는 JVM 위에서 실행되기 때문에 OS에 종속적이지 않고, 독립적으로 실행될 수 있습니다.<br>
클래스 로더에 의해 동적 로딩을 지원하여, 실행 시 모든 객체를 생성하는 것이 아니라, 필요한 시점에 클래스를 생성함으로서 메모리를 효율적으로 사용할 수 있습니다.
<br>
캡슐화 사용 시 외부에서 직접 접근을 제한하고, 오직 정해진 메서드를 통해서만 데이터 조작을 가능하게 끔 하여, 코드 수정 시 해당 객체 내부만 변경하면 됨<br>
상속은 기존 클래스의 속성이나 메서드를 새로운 클래스가 물려받아 사용. (중복 코드 작성 필요 x)<br>
다형성 : 여러 형태로 동작하는 객체를 하나의 인터페이스나 클래스로 표현할 수 있게 해줌. 시스템 확장이나 변경시 기존 코드를 수정하지 않고도, 새로운 형태의 객체 쉽게 추가<br>
추상화 : 사용자가 복잡한 내부 구현을 몰라도, 재공되는 인터페이스를 통해 필요한 기능 쉽게 사용 가능<br>
</details>

<details markdown = "1">
<summary>Java의 장단점에 대해 설명해주세요.</summary>
자바는 JVM 위에서 작동하기 때문에 OS에 종속적이지 않고, 독립적으로 실행될 수 있습니다.(다양한 환경에서 같은 코드 재사용 가능)<br>
객체지향 언어로 설계되어 코드의 재사용성 과 유지보수성이 좋습니다.(이유 : 캡상다추) <br>
추가로, 자바는 클래스 로더를 통해 동적 로딩을 지원하는데, 이는 (실행 시)필요한 시점에만 특정 클래스나 자원을 로딩하여 메모리 효율성을 높이게 됩니다.<br>
하지만 자바의 경우 소스코드가 바이트 코드로 변환 된 후, JVM에 의해 다시 기계어로 번역되는 과정을 거치기에, 일반적으로 한번만 컴파일링을 거치는 언어에 비해 실행속도가 상대적으로 느릴 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>Java 8의 특징은 무엇인가요?</summary>
첫번째로, 람다 표현식(화살표)이 도입되어 함수형 프로그래밍을 구현하는 것이 가능해졌습니다.
두번째로는 Stream API(대용량 처리시 유용)를 도입하여 데이터 컬렉션을 다루는데 있어 효율적인 처리할 수 있는 병렬 및 순차처리 방법을 제공합니다.<br>
그리고 인터페이스에 default 메서드를 통해 인터페이스 안에서 공통으로 사용되는 함수를 미리 정의할 수 있게 되었습니다.<br>
마지막으로 Optional 클래스가 추가되었는데, null 값을 안전하게 포장하는 래퍼 클래스로써, 이를 통해 참조 시 NPE를 방지할 수 있게 설계되어있습니다.<br><br>
<br>
참고 - 작은 데이터 세트에 대해서는 for 문이 더 빠를 수 있다(내부적으로 많은 오버헤드를 가지고 있기떄문)<br>
오버헤드 - 작업을 하기 위한 추가적인 리소스나 비용(ex: 추가적인 연산, 메모리 사용, 시간 등)<br>
기본적으로 for문은 단일 스레드에서 순차적으로 데이터를 처리하는 반면 Stream API 사용시에는 데이터 처리를 멀티 스레드(스레드 풀에서 남는 스레드)로 병렬화할수있다.<br>
for문은 기본적으로 단일스레드에서 순차적으로 작동하지만, 병렬처리 할수있음(별도의 멀티스레딩 코드 작성해야 ), 하지만 Stream API는 간단한 메서드 호출 한번(parallelStream())으로 병렬처리 쉽게 가능<br>
<br>
참고 - 자바 8,11,17이 LTS(Long Term Support)버전임. 이는 3년 단위로 유지보수를 지원해주는 버전<br>
참고 - 자바 11에 추가된것(String, File 클래스에 메서드 추가, 람다에서 var 키워드 사용 가능, HttpClient라는 것이 추가됨)
</details>

<details markdown = "1">
<summary>Java의 main 메소드가 static인 이유에 대해 알고 계시나요? (public static void main(){String args[]})</summary>
static 멤버는 프로그램 시작 시, 클래스 로더에 의해 메모리에 로드되어 인스턴스를 생성하지 않아도 호출이 가능하기 떄문입니다.<br>
런타임 데이터 영역(JVM 메모리 영역)에서 Method Area라고 불리는 영역에는 static 키워드를 가진 변수 및 메서드가 생성됩니다.<br>
따라서 JVM은 별도로 인스턴스를 생성하지 않아도, Method Area에 로드된 main()을 실행할 수 있습니다.
<br>
public인 이유<br>
JVM이 프로그램을 실행할때 외부에서 이 메서드에 접근하여 호출해야 하기 떄문에 public으로 선언되어야 함(어디에서나 접근 가능하게, 다른 접근제어자의 경우 에러)
<br>
static영역에 할당되기에 Garbage Collector에 의해 해제되지 않고 프로그램 종료 시까지 할당된 채로 남아있는다
<br>
</details>

<details markdown = "1">
<summary>절차지향, 객체지향, 함수형 프로그래밍이란 무엇이고 차이점은 무엇인가요?</summary>
절차지향 프로그래밍이란, 프로그램을 일련의 순차적인 절차 또는 단계를 따라 데이터에 작업을 수행하는 방식을 말합니다.(ex: C언어)<br>
이는 컴퓨터의 처리구조와 유사하기 때문에 실행 속도가 빠르지만 유지보수가 어렵다는 단점(엄격하게 순서가 정해져 있어서)이있습니다.<br>
객체지향 프로그래밍은 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고, 그 객체들간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다(ex: 자바,파이썬).<br>
이는 앞서 설명드린 절차지향형 프로그래밍 방식에 비해 코드 재사용이 용이하고, 유지 보수가 쉽지만 처리 속도가 상대적으로 느리고 설계시 많은 시간과 노력이 필요합니다.<br>
함수형 프로그래밍은 자료 처리를 수학적 함수의 계산으로 취급하고, 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나로 대표적인 언어로는 SQL,Scala등이 있습니다.<br>
</details>

<details markdown = "1">
<summary>객체 지향형 프로그래밍(OOP)가 무엇이죠??</summary>
객체 지향 프로그래밍은 컴퓨터 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태(필드,변수)와 행위(메서드)를 가지는 객체를 만들고, 그 객체들간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방식입니다.<br>
객체지향 탄생 이유 -> 코드의 유연성을 위해<br>
<br>
<br>
꼬리질문1 - 장단점에는 무엇이 있죠?<br>
우선 객체들이 재사용 가능한 컴포넌트(자체로 기능을 수행할 수 있는 모듈, 보통 인터페이스로 다른 컴포넌트와 상호작용)로 설계될 수 있어, 같은 기능을 다시 구현할 필요 없이 해당 객체를 재사용하거나 상속받아 확장하여 사용할 수 있습니다.<br>
그리고 객체 단위로 코드가 구분되어 있어, 특정 기능에 문제가 발생하거나 변경이 필요할때 해당 객체만을 수정하면 되므로 유지 보수 과정을 간소화할 수 있습니다.<br>
또한 데이터는 객체 내부에 캡슐화되어, 외부에서 직접 접근할 수 없습니다. 이때 데이터 접근은 객체가 제공하는 메소드를 통해서만 가능하므로, 데이터를 안전하게 보호할 수 있습니다.<br>
하지만 설계 단계에서 상당한 시간이 걸릴수 있고 객체 간의 메세지 전달이나 상속등의 오버헤드 때문에 절차 지향 프로그래밍에 비해 처리 속도가 느립니다.<br>
또한 객체가 상태를 가지고 있기에, 이러한 상태 변경의 예측(객체 메서드에 의해 변경)이 어렵고 디버깅하기 어렵게 만들 수 있습니다.<br>
만약 특정 상태에 종속적인 경우, 그 객체는 상태에 따라 다르게 작동하므로 재사용이 어려울 수도 있습니다.<br>
<br>
꼬리질문 2 - 객체 지향 프로그래밍의 특징에 대해 말해주세요.<br>
추상화는 객체의 공통적인 속성과 기능을 추출하여 정의하는 것을 의미합니다.<br>
다른 말로 표현하자면 인터페이스에 추상 메서드나 상수를 통해 어떤 객체가 수행해야 할 핵심적인 역할만 규정해두고, 실제적인 구현은 해당 인터페이스를 구현하는 각각의 객체에서 하도록 프로그램을 설계하는 것입니다. 이를 통해 인터페이스에 정의한 역할을 각각의 클래스의 맥락에 맞게 구현하게 되고, 이를 통해 변경에 유연한 프로그래밍을 할 수 있습니다<br>
<br>상속은 한 클래스의 속성과 메서드를 다른 클래스가 물려받아 사용하는 것입니다.<br>
상속을 통해 새로운 클래스는 부모 클래스의 특성과 메소드를 재사용할 수 있으며, 필요에 따라 확장(추가적 기능 넣거나) 및 수정(아예 기능 변경?)을 할 수 있습니다.<br>
<br>다형성은 하나의 클래스나 메서드가 맥락에 따라 다른 역할을 수행할수 있는 의미합니다<br>
예를 들어, 메소드가 같은 이름을 가지지만, 입력 매개변수에 따라 다르게 동작하는 오버로딩, 또는 같은 이름의 메소드(동물 울다 -> 강아지 멍멍, 고양이 야옹)가 슈퍼클래스와 서브클래스에서 다른 행동을 하는 오버라이딩 등이 이에 해당합니다.<br>
좀더 객체 지향적인 관점에서 다형성을 다루어보자면 상위 클래스의 타입의 참조변수로 하위 클래스의 객체를 참조할 수 있도록 하는 것입니다<br>
<br> 캡슐화는 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것을 말합니다.이를 통해 내부 데이터는 외부의 임의 접근으로 부터 보호될 수 있습니다.<br>
또한 캡슐화를 통해 클래스의 내부 구조나 동작 방식에 대해 깊게 알 필요 없이, 제공되는 메서드를 통해 클래스를 쉽게 활용할 수 있습니다.(결합도도 낮춤)
<br>
꼬리질문 3 - getter, setter를 사용하는 이유가 무엇인가요??
(어짜피 private으로 멤버 변수 지정하고 public으로 getter, setter 메서드를 만들어왔는데 왜그럴까??)
우선 private으로 멤버변수를 선언하면 외부에서 직접 접근할 수 없기에, 멤버 변수 값이 예상치 못한 방식으로 변경되는 것을 막을 수 있습니다.<br>
대신 public으로 선언된 getter와 setter 메서드를 통해 멤버 변수에 접근하게 되는데, 이 메서드들에 값의 변경을 제어하고 검증하는 로직을 추가할수 있습니다.<br>
예를들어 setter 메서드 내에서 입력된 값을 검증하여 객체의 상태가 유효한 상태로 유지되도록 할 수 있습니다.(ex: setAge가 0보다 작다면 에러나 로그를 남김)<br>
<br>
꼬리질문 4 - 캡슐화에 대해 좀더 자세히 물어보는 경우<br>
캡슐화 목적 - 앞서 말한 외부 에서직접 변경 X 말고 다른 것도 있음(밑에)<br>
캡슐화는 단지 getter setter를 사용해 private 멤버에 접근하도록 하는것 이상의 의미를 가지는데 이는 객체의 내부 구현을 감추고, 사용자에게는 필요한 인터페이스만을 제공한다는 것입니다.<br>
이를 통해 클래스의 내부 데이터를 보호할 수 있고, 사용자는 클래스가 제공하는 메서드를 통해서만 클래스와 상호작용할 수 있습니다.<br>
예를들어 사용자가 자동차라는 객체를 사용하고, 이러한 자동체 객체는 달린다,멈춘다,방향을 바꾼다 등의 메서드를 제공한다고 가정해보겠습니다.<br>
이러한 메서드는 사용자에게 필요한 인터페이스입니다.<br>
하지만 이때  자동차 객체의 내부 구현(엔진이 어떻게 돌아가는지, 브레이크가 어떻게 동작하는지)은 감추어져있습니다.<br>
이러한 내부 구현은 사용자가 알 필요가 없을 정보일 뿐 아니라 바꾸지 않아야할 정보입니다.<br>
이렇게 내부의 복잡한 부분을 감추고, 사용자에게는 단순한 인터페이스만을 제공하는 것이 캡슐화의 핵심입니다.<br>
<br>
참고 - 캡슐화를 하는 목적은 객체의 내부 구현을 감추어 내부 구현의 변화가 일어나더라도 협력하는 외부 객체에 변화의 영향이 퍼져나가지 않도록 막기 위함이다.<br>
</details>

<details markdown = "1">
<summary>SOLID 원칙에 대해 설명해주세요</summary>
SOLID는 좋은 객체 지향 설계를 위한 5가지 원칙을 다룬 개념입니다.(단개리인의)<br>
<br>
우선 단일 책임 원칙(Single Responsibility Principle)은 한 클래스가 하나의 책임만을 가지도록 하는 원칙입니다.<br> 
이때 저는 중요한 기준을 변경이라고 보는데, 해당 클래스에 대한 변경이 있을때 다른 클래스에 파급 효과가 적다면 단일 책임을 잘 따른것이라 볼 수 있습니다.<br>
<br>
개방 폐쇄 원칙은 소프트웨어 구성 요소(클래스,모듈, 함수 등)가 확장에는 열려 있어야 하며, 변경에는 닫혀있어야 함을 의미합니다.<br>
즉 새로운 변경 사항이 발생했을때(ex: 기능 추가) 직접적인 (객체) 수정 없이도 이를 반영할 수 있도록 설계해야 함을 의미합니다.<br>
<br>
리스코프 치환 원칙은 부모 클래스(또는 베이스 타입)의 인스턴스를 자식 클래스(또는 서브타입)의 인스턴스로 교체하는 과정에서 프로그램의 정확성이 유지되어야 한다는 원칙입니다.<br>
인터페이스 분리 원칙(ISP)은 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 나음을 의미합니다.<br>
마지막으로 의존관계 역전 원칙(DIP)은 프로그래머가 구체적인 것보다 추상화된 것에 의존해야 함을 의미합니다.<br>
<br><br>
SRP 원칙을 준수하면 각 클래스가 맡은 책임이 명확해져, 한 책임의 변경이 다른 책임에 미치는 영향을 최소화 할 수 있습니다.<br>
OCP 준수 하기 위해 스프링에서는 DI(의존성 주입)과 제어의 역전(IOC)를 제공합니다.<br><br>
<br>
리스코프 치환 원칙(LSP) 예시<br>
클라이언트는 인터페이스를 구현한 객체의 내부 구현을 알지 못하므로, 객체는 인터페이스의 명세를 준수하여 구현되어야 합니다.<br>
예를들어 자동차 인터페이스에 앞으로 가는 기능을 선언했는데, 서브 클래스에서 뒤로 가게 구현한 것은 LSP를 위반한 예입니다. 느리더라도 앞으로 가는 기능을 제공해야 LSP를 준수한 것입니다.<br>
<br>
예를 들어, '전자기기'라는 인터페이스에 '켜기', '끄기', '충전하기', '인쇄하기'라는 메소드가 있다면, '스마트폰' 클래스는 '인쇄하기' 메소드를 사용하지 않을 것입니다. 
이럴 때 '스마트폰'을 위한 '켜기', '끄기', '충전하기' 메소드만을 가진 인터페이스와 '인쇄하기' 메소드를 가진 인터페이스로 분리하는 것이 더 효과적일 수 있습니다. 이렇게 하면 각 클래스는 필요한 메소드만을 포함한 인터페이스에 의존하게 되므로 더 명확하고 깔끔한 설계를 할 수 있습니다.<br>
<br>
DIP 예시<br>
즉, 클라이언트가 구현 객체에 직접 의존하는 것이 아니라, 클라이언트와 구현 객체 모두 인터페이스에 의존해야 합니다. 이렇게 되면 구현 객체가 변경되더라도 클라이언트에는 아무런 변화가 없게 됩니다.<br>
<br>
DIP 예시<br>
예를 들어, 회사에서 서비스를 운영하면서 MySQL에서 PostgreSQL로 데이터베이스를 바꾸려고 합니다. 이 때, 웹 애플리케이션의 각 부분이 구체적으로 MySQL에 의존하고 있다면, 이 변경은 코드의 모든 부분을 수정해야 하는 매우 큰 작업이 될 것입니다. 또한, 이러한 변경은 버그를 만들 가능성이 크기 때문에 위험성도 큽니다.<br>
하지만 만약 웹 애플리케이션의 각 부분이 데이터베이스에 직접 의존하는 대신, 데이터베이스 인터페이스(DB Interface)에 의존하도록 설계되어 있다면 이 문제는 간단히 해결될 수 있습니다.<br>
이 인터페이스는 MySQL과 PostgreSQL 모두에서 사용할 수 있는 일반적인 메소드(예: get, set, update, delete 등)를 정의합니다. 웹 애플리케이션의 나머지 부분은 이 인터페이스를 통해 데이터베이스와 상호작용하므로, 어떤 데이터베이스가 뒤에 연결되어 있더라도 그것에 영향을 받지 않습니다.<br>
따라서 MySQL에서 PostgreSQL로 데이터베이스를 바꿀 때는 단지 인터페이스를 구현하는 클래스만 바꾸면 됩니다. 웹 애플리케이션의 나머지 부분은 이 변경을 알아차리지 못하고 그대로 작동합니다. 이러한 접근 방식은 의존관계 역전 원칙을 따르는 것이며, 시스템의 유연성과 확장성을 크게 향상시킵니다.<br>
<br>
OCP 예시<br>
스프링을 기반으로 한 예시를 정리해보겠습니다:<br>
<br>
1. **`MemberService`** 클래스는 **`MemberRepository`** 인터페이스에 의존하고 있습니다.<br>
2. **`MemberRepository`** 인터페이스에는 여러 구현체가 있습니다.<br>
3. 만약 **`MemberService`** 클래스 안에서 **`MemberRepository`**의 구현체를 직접 생성한다면(**`MemberRepository m = new MemoryMemberRepository()`**), 구현체 변경 시에 **`MemberService`** 코드도 수정해야 합니다. 이렇게 되면 OCP와 DIP(의존성 역전 원칙)를 위반하게 됩니다.<br>
4. 따라서, 의존성 주입(Dependency Injection, DI)을 통해 이 문제를 해결할 수 있습니다. 구현체를 외부에서 주입받도록 수정함으로써, **`MemberService`** 클래스는 구현체에 대한 의존성을 줄이고, 변경에 닫혀 있게 됩니다.<br>
<br>
요약하면, OCP는 기능의 확장과 변경에 대응하기 위한 원칙입니다. 스프링 예시에서는 의존성 주입을 통해 OCP를 준수하고, 기존 코드의 변경을 최소화하며 유지 보수성을 높이는 것을 보여줍니다.<br>
</details>

<details markdown = "1">
<summary>클래스와 객체가 무엇이죠?.</summary>
클래스는 객체를 생성하기 위한 설계도라고 생각할 수 있습니다.<br> 
클래스는 객체가 가져야할 상태를 나타내는 필드(field)와 객체가 수행할 수 있는 동작을 나타내는 메서드로 구성됩니다.<br>
객체는 클래스에서 정의된 내용에 따라 메모리에 할당된 실체를 의미합니다. 각각의 객체는 자신만의 상태를 가지며, 클래스에 정의된 동작을 수행할 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>상속이랑 컴포지션의 차이에 대해 설명해주세요.</summary>
상속(IS-A)은 한 클래스의 속성과 메서드를 다른 클래스가 물려받아 사용하는 것입니다.<br> 
(보통 모듈을 만들때는 응집도는 높게, 결합도는 낮게하며, 변경사항이 있을때는 클라이언트의 코드만 변경하는 것이 이상적입니다).<br>
이때 부모 클래스를 상속받는 하위 클래스는 상위 클래스의 구현 내용 변경에 따라 하위 클래스의 구현 내용도 바뀔 수 있습니다.<br>
즉 자식 클래스는 부모 클래스에 대한 결합도가 높습니다.<br>
따라서 이러한 문제를 해결해보기 위해 등장한 개념이 컴포지션입니다.<br>
컴포지션이란 상속 처럼 기존의 클래스를 확장하는 것이 아닌, private 필드로 기존 클래스의 인스턴스를 참조하는 방식(forwarding)입니다.<br>
즉 기존 클래스가 새로운 클래스의 구성요소가 되는것입니다. (HAS-A 관계)<br>
<br>
꼬리질문 - 어떠한 경우 상속을 쓰고 어떠한 경우에 컴포지션을 쓰면 좋을까요???<br>
상속은 부모 클래스의 코드를 재사용하고자 할때, 또는 확장을 통해 새로운 기능을 추가하고 싶을 때 사용합니다.<br>
하지만 이는 부모 클래스 변경이 자식 클래스의 영향을 미치므로, 부모 클래스가 변경될 가능성이 적거나, 부모 클래스를 잘 아는 상황에서 사용해야합니다.<br>
컴포지션은 유연성이 필요한 상황에서 사용되며, 컴포넌트를 독립적으로 변경하거나 확장하는 경우에 효과적입니다. 또한 상속에 대한 위험성을 피하고 싶을 때 사용하면 좋습니다.<br>
<br>
참고 - 부모 클래스의 private 멤버는 상속에서 제외
</details>

<details markdown = "1">
<summary>super() 메서드란 무엇인가요??</summary>
super() 메서드는 자식 클래스에서 부모 클래스의 생성자를 호출할때 사용됩니다.(자식 클래스 생성자에서만 호출할 수 있음)<br>
기본적으로, 모든 클래스의 생성자 첫 번째 줄에는 super()가 숨겨져 있어 명시적으로 호출하지 않아도 부모 클래스의 기본 생성자를 호출하게 됩니다. <br>
하지만, 부모의 생성자 중 매개변수 가 있는 생성자가 실행되도록 할려면 super()에 반드시 매개변수를 사용 후 호출해야 합니다.<br>
<br>
</details>

<details markdown = "1">
<summary>transient에 대해 아시나요???</summary>
transient는 직렬화 과정에서 특정 필드를 제외하고 직렬화(특정 변수에 붙이는 단위, Serializable 대상에서 제외) 하도록 지정하는데 사용합니다.<br>
transient으로 선언된 필드는 직렬화 과정에서 제외되며, 기본값으로 초기화됩니다.따라서 transient 필드는 직렬화 되지 않고, 역직렬화 과정에서 해당 필드는 기본값으로 설정됩니다.<br>
이는 패스워드와 같이 보안상 중요한 변수나 꼭 저장해야 할 필요가 없는 변수에 대해서는 transient를 사용할 수 있습니다.<br>
<br>
직렬화란 객체를 바이트 스트림으로 변환하여 저장하거나 네트워크 상에서 전송하기 위한 과정<br>
</details>

<details markdown = "1">
<summary>직렬화와 역직렬화에 대해 설명해주세요.</summary>
직렬화란 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터를 변환하는 기술입니다.<br>
역직렬화는 직렬화의 반대 과정으로 바이트 스트림을 원래의 객체 상태로 복원하는 과정을 말합니다.<br>
<br>
참고 - 자바에서는 Serializable이라는 인터페이스를 구현하여 생성(클래스가 implements Serializable 상속 함으로서 직렬화 될수 있는 형태로 만들어짐)
참고 - 자바에서 입출력을 수행할려면, 즉 어느 한쪽에서 다른 쪽으로 데이터를 전달할려면 두 대상을 연결하고 데이터를 전송할 수 있는 무언가가 필요한데 이를 Stream이라고 부름.<br>
즉 데이터를 운반하는데 사용하는 통로<br>
참고 - 직렬화의 경우 -> (여기 여러 이름들 있음)OutputStream 객체 이용, 역직렬화의 경우 InputStream 객체 사용
<br><br>
꼬리질문 - SerialVersion UID 에 대해 아시나요?<br>
SerialVersionUID는 자바에서 객체 직렬화를 수행할때 클래스의 버전을 식별하는데 사용하는 유니크한 ID입니다.<br>
이를 통해 직렬화된 객체의 클래스가 현재 JVM에서 사용하는 클래스와 동일한지 확인할 수 있습니다.<br>
만약 클래스가 변경되었지만, SerialVersionUID가 동일하다면, JVM은 변경된 클래스도 이전 클래스와 같다고 간주하고 역직렬화를 수행합니다.<br>
그러나 이 아이디가 다르면, JVM은 역직렬화 과정에서 예외를 발생시킵니다.<br>
</details>

<details markdown = "1">
<summary>try-catch-finally의 단점과, 이로 인해 나온 구문에 대해 알고 계신다면 설명해주세요.</summary>
try-catch-finally 구문에서 리소스를 생성하게 되면, 생성은 try에서 하고 반납은 finally에서 하다보니 실수의 발생 여지가 있었습니다.<br> 
그래서 나온 구문으로 try-with-resources가 있습니다. try 옆에 괄호로 리소스를 생성해주면, 따로 반납 코드를 작성하지 않아도 자동으로 리소스를 반납합니다.<br>
</details>

<details markdown = "1">
<summary>volatile에 대해 아시나요???</summary>
volatile은 변수의 값을 메인메모리에서 항상 값을 읽거나 씀으로서 스레드 간의 가시성을 보장하는데 사용됩니다.
이를 붙인 변수는 여러 스레드에서 동시에 접근할 수 있고, 해당 변수의 값을 읽거나 쓸 때 항상 메인 메모리에서 직접 읽고 쓰도록 보장됩니다.<br>
이는 스레드 간의 변경 사항이 즉시 반영되고 다른 스레드에서 최신 값을 읽을 수 있도록합니다.<br>
<br>
꼬리 질문 1 - volatile을 사용하는 주요한 경우는 어떤 경우가 있을까요??<br>
여러 스레드에서 공유하는 변수의 가시성을 보장하고 최신값을 읽기 위해 사용합니다.<br>
<br>
꼬리질문 2 - (멀티스레드 용 용어임)가시성이 무엇이고, volatile을 사용하지 않으면 어떤 경우 문제가 발생할 수 있죠??<br><br>
가시성이란 한 스레드가 변수를 변경했을 때 이 변경사항이 다른 스레드에게 얼마나 빨리 보이는지를 의미하는 용어입니다<br>
메모리 가시성 문제는 주로 각 스레드가 자신의 로컬 메모리(예: CPU 캐시)에 변수 값을 저장하고 사용하기 때문에 발생합니다<br>
<br>
예를들어 한 스레드에서는 플래그를 true로, 다른 스레드는 그 플래그가 true가 될때까지 대기하는 상황이라고 해보겠습니다.<br>
만약 이 플래그가 volatile로 선언되지 않으면, 플래그를 설정하는 스레드가 그 값을 true로 변경했음에도 불구하고 대기 중인 스레드는 여전히 false를 볼 수 있습니다. 
왜냐하면 각 스레드는 자신의 CPU 캐시에서 값을 읽고 쓰기 때문입니다. 이렇게 되면 대기 중인 스레드는 영원히 대기 상태에 머물수 있습니다.<br>
<br>
</details>

<details markdown = "1">
<summary>기본형과 참조형이 무엇인지와 그에 대한 차이를 설명해주세요.</summary>
자바에서는 총 8가지의 기본형 타입(byte, short, int, long(이까지 정수형), float, double, char, boolean)을 미리 정의하고 제공해줍니다.<br>
기본형 변수는 메모리의 스택 영역에 할당되며, 값이 저장될때 해당 메모리 위치에 직접 저장됩니다.<br>
참조형 타입에는 기본형을 제외한 모든 타입으로 클래스, 인터페이스, 배열 등이 있습니다. 참조형 변수는 메모리의 스택 영역에 할당되며, 실제 데이터(객체)는 힙 영역에 할당됩니다.<br>
이때 스택 영역에 저장된 참조형 변수는 힙 영역에 저장된 객체의 주소를 가리키고 있는 것이 특징입니다.<br>
<br>
참고 - 8가지 이외엔 전부 참조형<br>
기본 타입의 경우 크기가 작고 고정적이기에 Stack 영역에 저장하고, 참조 타입은 데이터의 크기가 가변적이고 동적이므로 Heap 영역에 저장<br>
참조형의 경우 String과 배열은 new 없이 생성가능하지만 참조타입이고, 더이상 참조 하는 변수가 없을때 GC에 의해서 삭제됨<br>
</details>

<details markdown = "1">
<summary> 자바에서 '=='연산자와 'equals()' 메서드의 차이에 대해 설명해주세요 </summary>
== 은 참조 비교로 두 객체가 같은 메모리 공간을 가리키는지 확인하고, equals는 두 객체의 내부 값이 같은지 내용을 비교합니다.
<br>
참고: equals는 override 할 수 있기 때문에 사용자가 원하는 논리적인 통일성을 비교할 수 있다.<br>
참고 : equals는 주소 값을 자체를 비교하는 것은 아니지만 주소값을 통해서 비교를 함, equals는 기본 타입에 대해서는 적용 불가<br>
</details>

<details markdown = "1">
<summary> call by reference 와 call by value의 차이에 대해 설명해주세요.</summary>
call by value와 call by reference는 함수 호출 시 인자 전달 방식의 차이를 나타냅니다.<br>
call by value는 함수 호출 시 인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달 합니다.
따라서 함수 내에서 인자 값이 변경되더라도 원래 변수에는 영향을 미치지 않습니다.<br>
<br>
반면 call by reference는 함수 호출 시 인자로 전달되는 변수의 레퍼런스(주소)를 전달한다.<br> 
이 경우 함수 내에서 인자 값이 변경되면 원래 변수의 값도 함께 변경됩니다.<br>
<br>
자바에서는 기본형 변수를 함수의 인자로 전달할 때 call by value 방식을 사용합니다. 
참조형 변수를 전달할 때도 사실 call by value 방식을 사용하지만, 이때 전달되는 값은 객체의 참조 주소입니다. 
따라서 함수 내에서 해당 주소의 객체를 변경하면 호출자에게도 그 영향이 반영됩니다. 
하지만, 새로운 객체를 할당하는 등 참조 자체를 변경하는 경우 호출자의 원본 참조에는 영향을 주지 않습니다.
</details>

<details markdown = "1">
<summary> 클래스 변수, 지역 변수, 인스턴스 변수의 차이에 대해 설명해주세요 </summary>
클래스 변수는 static 키워드를 사용해 선언되며, 클래스 레벨에서 정의가 됩니다. 이는 해당 클래스의 모든 객체가 공유하며, JVM 의해 클래스가 로드될때 메모리(Method Area)에 할당됩니다.(객체를 생성하지 않고도 클래스 이름을 통해 접근 가능)<br>
인스턴스 변수는 객체가 생성될 때마다 힙(heap) 영역에 매번 새로 생성되어 각 객체마다 독립적인 값을 가지게 됩니다.<br>
지역변수는 메서드나 블록 내에서 선언되며, 해당 영역 내에서만 사용할 수 있습니다. 이는 스택 영역에 할당되며, 메서드나 블록 실행이 종료되면 메모리에서 해제됩니다.(초기화 하지 않으면 사용 불가)
<br><br>
참고 : 클래스 변수, 인스턴스 변수 둘다 멤버 변수<br>
참고 : 인스턴스 변수는 객체가 생성될 때마다 힙(heap) 영역에 매번 새로 생성되며, 각 객체마다 독립적인 변수를 가지게 됩니다.<br> 
지역 변수는 메서드가 호출될 때마다 스택(stack) 영역에 새로 생성되고 메서드 호출이 종료되면 소멸합니다. <br>
반면에 클래스 변수는 static Area에 한 번만 생성되어 해당 클래스의 모든 객체가 공유합니다.<br>
멤버변수는 지역 변수와 다르게 각 타입의 기본 값으로 자동 초기화<br> 
참고 : 자바를 실행했다고 바로 메모리에 올라가는 것이 아님, 클래스 로드 시점은 다음과같다<br>
1. 클래스 인스턴스를 생성하려할때<br>
2. 클래스의 정적 멤버에 접근하려할떄!<br>(중요!!)
3. 클래스를 직접 로드하는 경우 Class.forName()<br>
<br>
<br>
public class test {<br>
<br>
	int iv; // 인스턴스 변수<br>
	static int cv; // 클래스 변수<br>
	<br>
	void method() {<br>
		int lv; // 지역 변수<br>
	}<br>
}<br>
</details>

<details markdown = "1">
<summary>상속이란 무엇인가요?</summary>
상속이란 부모 클래스가 가지고 있는 상수, 메소드를 자식 클래스에서 물려 받아 같이 공유하면서 확장하는 것입니다<br>
상위 클래스를 상속 받게 되면 하위 클래스, 즉 상속받은 클래스는 상위 클래스의 변수나 메서드를 사용할 수 있게 됩니다.<br>
이게 가능한 이유는 하위 클래스 생성 시 상위 클래스의 생성자가 먼저 호출되고 하위 클래스의 생성자가 호출되도록 프로그램 내부에 이미 설정되어 있기 때문입니다. <br>
즉 하위 클래스 생성자에서 super()를 자동으로 호출하게 됩니다.<br>
이러한 상속에는 예약어 extends가 사용됩니다.
</details>

<details markdown = "1">
<summary>정적 타입의 언어와 동적 타입 언어의 차이는 무엇인가요??</summary>
타입(자료형)의 결정을 컴파일 할때 결정한다면 정적타입 언어(Java,C), 런타임 과정에서 결정한다면 동적 타입의 언어입니다.<br>
정적 타입의 언어의 경우 컴파일 때 미리 타입을 결정하기 떄문에, 실행 속도가 빠르고 타입 에러로 인한 문제점을 초기에 발견 할 수 있어 타입의 안전성을 높일 수 있습니다.<br>
하지만, 매번 코드 작성시 변수형을 결정해줘야 하는 번거로움이 있습니다.<br>
동적 타입의 언어의 경우 런타임까지 타입의 결정을 끌고 갈 수 있기에 유연성이 높고, 컴파일 시 타입을 명시해주지 않아도 되기에 빠르게 코드를 작성할 수 있습니다.<br>
하지만 런타임에서 타입 관련 에러를 만날 수 있으므로, 해당 에러들에 대한 주의가 필요합니다<br>
</details>

<details markdown = "1">
<summary>컬렉션(collection) 클래스에서 제네릭을 사용하는 이유가 무엇인가요?</summary>
컬렉션 클래스에서 제네릭을 사용하면 컴파일러는 특정 타입만 포함 될 수 있도록 컬렉션을 제한하게됩니다.
컬렉션 클래스에 저장하는 인스턴스 타입을 제한하여 런타임에 발생할수있는 잠재적인 모든 예외를 컴파일 타임에 잡아낼 수 있도록 도와줍니다.<br>
</details>

<details markdown = "1">
<summary>스크립트 언어와 컴파일 언어의 차이에 대해 설명해주시고 자바는 컴파일언어인가요? 스크립트 언어인가요?</summary>
컴파일 언어는 코드를 작성한 후 전체 코드를 기계어로 번역하는 컴파일 과정을 거칩니다. 이 컴파일된 코드는 실행 파일로 저장되어, 이후에는 컴파일 과정없이 빠르게 실행할 수 있습니다(대표적으로 C,C++)<br>
컴파일 언어의 장점으로는 실행 속도가 빠르다는 것(사전에 컴파일 되어 기계어 상태로 실행되므로)과, 컴파일러가 코드의 문법적 오류를 미리 확인해준다는 점입니다.<br>
이에 반해 스크립트 언어는 컴파일 단계 없이, 실행 단계에서 한줄씩 기계어로 번역 후, 실행되므로 통상 컴파일 언어보다 실행이 느립니다.<br>
이를 위해 인터프리터라는 프로그램이 필요하며, 코드는 실행될떄마다 인터프리터에 의해 해석됩니다(python, javascript)<br>
스크립트 언어의 장점으로는 개발 속도가 빠르고, 코드 수정 후 바로 결과를 확인할 수 있다는 점이있습니다.<br>
<br>
자바의 경우에는 두가지의 특성을 모두 가지고 있습니다. 자바 코드는 먼저 자바 컴파일러에 의해 바이트 코드로 컴파일됩니다.<br>
그러나 이 바이트 코드는 기게어가 아니라 자바 가상 머신이 이해할 수 있는 중간언어입니다. 이 바이트 코드를 실행할 떄는 JVM의 인터프리터가 한 줄 씩 읽어 나가며 실행합니다.<br>
자바 코드가 처음 실행될때는 인터프리터가 바이트 코드를 한줄씩 해석하며 실행하지만, 자주 실행되는 코드 부분은 JIT 컴파일러가 기계어로 컴파일하여 효율적으로 실행합니다.<br>
</details>

<details markdown = "1">
<summary>묵시적 형변환과 명시적 형변환의 차이가 뭔가요?</summary>
묵시적 형변환은 프로그래머가 직접 형변환을 지정하지 않아도 컴파일러가 자동으로 형변환을 수행하는 것을 말합니다.<br>
이는 보통 작은 데이터 타입에서 큰 데이터 타입으로 변환될 때 발생되며, 정보의 손실이 없습니다.<br>
예를들어 int 형값을 double 형 변수에 저장할려고 할때 묵시적 형변환이 일어납니다.<br>
반면 명시적 형변환은 프로그래머가 직접 형변환을 지시하는 것을 말합니다.<br>
보통 큰 데이터 타입에서 작은 데이터 타입으로 변환될때 사용하며, 이 경우 데이터 손실이 발생할 수 있습니다.<br>
이때 형변환하려는 타입을 괄호 안에 명시하여 사용하게 됩니다.<br><br>
예시
int myInt = 10;
double myDouble = myInt;  // 자동으로 int형이 double형으로 형변환 됩니다.
double myDouble = 10.5;
int myInt = (int) myDouble;  // 명시적으로 double형을 int형으로 형변환 합니다. 여기서 소수점 아래는 손실됩니다.
</details>

<details markdown = "1">
<summary>오버로딩과 오버라이딩에 대해 설명해주세요</summary>
오버로딩은 같은 이름의 메서드를 여러 개 정의하되, 매개변수의 개수나 타입이 다르게 하는 것입니다.
이를 통해 다양한 매개변수를 받을 수 있는 메서드를 구현할 수 있습니다.
반면에 오버라이딩은 상속 관계에서 자식 클래스가 부모 클래스가 정의한 메서드를 재정의하는 것입니다. 
메서드의 시그니처는 동일하게 유지되지만, 구현 내용을 변경하여 자식 클래스의 요구에 맞게 동작할 수 있습니다. 
이를 통해 다형성을 구현할 수 있습니다.<br>
참고 : 다형성이란 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 하는 것!
</details>

<details markdown = "1">
<summary>접근 제어자에 대해 설명해주세요</summary>
<img width = "80%" src = "https://github.com/wookjongkim/cs-study/assets/121083077/632e42b5-f054-421e-bf82-dcd0afa16f7c">
<br>
접근 제어자란 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 합니다.<br>
이러한 접근제어자에는 private, default, protected, public이 있습니다.<br>
private의 경우에는 같은 클래스내에서만 접근이 가능하고, default의 경우에는 같은 클래스와 패키지 내에서만 접근이 가능합니다.<br>
protected의 경우에는 같은 패키지 뿐 아니라, 그리고 다른 패키지의 자손클래스에서 접근이 가능하고 public의 경우에는 접근 제한이 없습니다.<br>
</details>

<details markdown = "1">
<summary>static 예약어에 대해 설명해주세요</summary>
자바에서 static은 클래스 레벨에서 공유되는 멤버(변수, 메서드)를 선언하는데 사용되는 예약어로, 이 키워드를 사용해 변수, 메서드, 내부 클래스를 정의할 수 있습니다.<br>
static 변수는 클래스의 모든 인스턴스가 공유하는 변수로 클래스 로드 시 메모리에 한번 할당되고, 인스턴스 생성과 무관하게 사용 가능합니다.<br>
static 메서드는 클레스 레벨에서 동작하는 메서드로, 인스턴스 생성없이 호출 할 수 있습니다.<br>
static 내부 클래스는 클래스 내부에 정의된 정적 클래스로, 외부 클래스와 독립적으로 동작합니다.따라서 외부 클래스의 인스턴스 생성과 상관없이 사용할 수 있습니다.<br>
<br>
참고 : 보통 유틸리티 메서드를 포함하는 클래스에 사용, static 으로 선언된 변수나 메서드는 JVM의 메서드 영역에 위치<br>
<br>
참고 : static 키워드를 통해 생성된 정적 멤버는 Metaspace에 저장되고, 저장된 메모리는 모든 객체가 공유해서 하나의 멤버를 어디에서든 참조할 수 있음<br>
하지만 GC의 관리 영역 밖이기에 프로그램 종료시까지 메모리에 할당된 채로 존재해서, 너무 남발하면 시스템에 악영향<br>
</details>

<details markdown = "1">
<summary>final 예약어에 대해 설명해주세요(finally, finalize 물어볼수도)</summary>
final 예약어는 값이 변하지 않는 상수를 선언할때나, 메서드의 오버라이드 및 클래스 확장을 방지하기 위해 주로 사용됩니다.<br>
변수에 final을 붙이면 해당 변수는 변경 될수 없는 상수가 되고, 메서드에 final이 붙으면 이는 오버라이드가 불가능해집니다.<br>
또한 클래스에 final을 붙으면 다른 클래스에서 이를 상속할 수 없습니다.<br>
<br>
finally 키워드는 try catch 블록 뒤에서 항상 실행될 코드 블록을 정의하기 위해 사용<br>
finalize 메서드는 가비지 컬렉터가 더 이상의 참조가 존재하지 않는 객체를 메모리에서 삭제하겠다고 결정하는 순간 호출된다.<br>
</details>

<details markdown = "1">
<summary>추상 클래스에 대해 설명해주세요</summary>
추상클래스는, abstract 키워드를 사용해 선언한 클래스로, 추상 메소드를 최소 한 개 이상 포함한 클래스입니다.여기서 추상메소드는, abstract 키워드를 사용해 원형만 선언되고 내부 코드는 작성하지 않은 메서드를 뜻합니다.<br>
추상클래스 내부에 추상메소드 외의 다른 것들도 추가가 가능하다는 것이 특징이고, 추상클래스의 사용 주 목적은 관련성이 높은 클래스 간의 코드를 공유하고 확장하고 싶은 목적입니다<br>
이러한 추상 클래스를 상속받은 클래스는 추상 메서드를 모두 구현하던가, 본인도 추상 클래스로 만들어야 오류가 발생하지 않으며 예약어 abstract를 사용합니다.<br>
<br>
참고 : extends 사용<br>
참고 : abstract 안 붙여도 구현부가 없는 메서드는 추상 메서드로 분류함<br>
참고 : 추상 클래스는 `일반 메서드도 가질 수 있음`, 그 자체로 인스턴스화 될수 없음<br>
참고 : 새로운 클래스를 작성할때 일종의 설계도 역할을 해줌, 공통 기능을 상속해 주기 위한 용도<br>
<br>
// 추상 클래스 선언
abstract class 동물 {<br>
    <br>
    // 일반 메서드<br>
    void 숨쉬기() {<br>
        System.out.println("숨을 쉽니다.");<br>
    }<br>
    <br>
    // 추상 메서드<br>
    abstract void 소리내기(); // 구현부가 없습니다.<br>
}
</details>

<details markdown = "1">
<summary>인터페이스에 대해 설명해주세요</summary>
인터페이스는, interface 키워드를 사용해 선언하며 default와 static을 제외하고는 추상 메소드와 상수만을 포함합니다<br>
interface 내부의 모든 메소드는 추상 메소드로, abstract public이 생략되어 있는 상태입니다.상수 필드는 public static final이 생략되어 있습니다.<br>
인터페이스는 다중 상속이 가능하며 관련성이 없는 클래스들의 논리적으로 같은 기능을 자신에 맞게 구현을 강제하는데에 목적을 갖습니다.<br>
<br><br>
<br>
사용 목적에 대해 간단히 말씀드리자면 우선 클래스들이 가져야 할 메서드의 시그니처(public abstract 자동 붙음)를 정의함으로서, 클래스가 구현해야 하는 행동을 지정할 수 있습니다.<br>
또한 인터페이스를 구현하는 여러 클래스는 동일한 인터페이스 메서드를 사용하여 다양한 구현(새의 move, 고양이의 move)을 제공할 수 있습니다.<br>
이를 통해 구현체에 의존하지 않고 인터페이스에 의존하게 되어 유연성과 확장성이 향상됩니다.(Bird 클래스나 Cat 클래스에 의존하는게 아니라 Animal 이라는 인터페이스에 의존)<br>
<br><br>
참고 : 추상 클래스는 추상 메서드를 가진 클래스이고, 인터페이스(implements)는 추상 메서드로만 이루어진 클래스<br>
참고 : 인터페이스, 추상클래스 둘의 메서드는 상속되어야 하기 때문에 final 키워드 붙지 않음
</details>

<details markdown = "1">
<summary>추상 클래스와 인터페이스의 차이에 대해 설명해주세요</summary>
<br>
짧게 외우려면 그냥 이걸로 답변하자.<br>
정리하자면, 구조상 차이로 추상 클래스는 abstract 키워드가 붙고 추상 메서드뿐만 아니라 다른 변수, 메서드도 선언이 가능하고, 인터페이스는 추상 메서드와 상수만 선언 가능하다.(자바 8부터는 default 메서드 선언 가능)<br>
목적의 차이로 추상 클래스는 관련성이 높은 클래스 간의 코드 공유(재사용)와 확장을 목적으로 하고, 인터페이스는 관련성이 없는 클래스들의 같은 기능을 자신에 맞게 구현하는데 목적이 있다.<br>
<br>
<br>
추상 클래스는 상속받은 클래스가 기능을 이용 및 확장하는 것이고, 인터페이스는 하위클래스에게 일종의 설계도를 제공하는 것입니다.<br>
추상 클래스 상속과 같이 extends 관계를 가진 경우에는 자식이 부모의 필드나 메서드를 참조할 수 있기 때문에, 자식이 부모의 기능을 확장한 구조로 이루어집니다.<br>
따라서 부모-자식 관계 뿐 아니라, 같은 부모에서 확장된 자식 클래스들끼리도 어느정도 역할에 공통점이 존재해야 합니다.<br>
반면 인터페이스의 구현체의 경우, 자식들간에 전혀 아무런 관계가 없더라도 인터페이스로 관계를 맺을 수 있습니다.<br>
요약하자면 관련성이 높은 클래스 간의 코드 공유 및 확장을 목적으로 하면 추상클래스, 관련성이 없는 클래스들의 같은 기능을 자신에 맞게 구현하고자 한다면 인터페이스를 사용하는 것이 바람직합니다.
<br>
참고 - 둘 다 서로 하위 클래스에게 공통적으로 사용하는 방식을 뽑아 전달하는 객체들인 공통점<br>
그러나 목적이 다르다. 추상 클래스는 추상 메서드를 자식 클레스가 구체화해서 기능 확장에 목적이 있지만,
인터페이스는 서로 관련이 없는 클래스에게 공통적으로 사용하는 방식이 필요하지만 기능을 각각 모두 반드시 구현케 하는 경우에 사용한다.<br>
</details>

<details markdown = "1">
<summary>Error와 Exception의 차이에 대해 설명해주세요</summary>
Error(모든 에러는 Unchecked)는 시스템 레벨에서 발생하는 문제로 개발자가 처리할 수 없는 심각한 오류를 말합니다.(OutOfMemory, StackOverflow)<br>
이런 경우 일반적으로 애플리케이션 코드에서 복구할 수 없는 문제들이기에 대부분의 경우 애플리케이션이 멈추게 됩니다.<br>
Exception은 프로그램의 정상적인 흐름을 방해하는 조건을 나타냅니다.<br>
이러한 예외는 체크예외와 unchecked 예외로 나뉩니다.<br>
일반적으로 컴파일 단계에서 명확하게 Exception 체크가 가능한 것을 Checked Exception이라 하며, 실행 과정 중 발견되는 Exception을 Unchecked Exception이라고 합니다<br>
</details>

<details markdown = "1">
<summary>Checked예외와 UnChecked 예외의 차이에 대해 설명해주세요</summary>
둘의 가장 명확한 구분 기준은 꼭 처리를 해야 하느냐 입니다.<br>
Checked Exception이 발생할 가능성이 있는 메서드라면 반드시 오류 처리(try/catch or throw : 이건 의존성 문제 야기할수도)를 해주어야 합니다.<br>
반면 Unchecked Exception은 명시적인 예외처리를 하지 않아도 됩니다.<br>
또한 예외를 확인하는 시점에서도 구분할 수 있습니다.<br>
일반적으로 컴파일 단계에서 명확하게 Exception 체크가 가능한 것을 Checked Exception이라 하며, 실행 과정 중 발견되는 Exception을 Unchecked Exception이라고 합니다.<br>
그리고 트랜잭션 roll-back 여부에도 차이가 있습니다.<br>
기본적으로 Checked Exception은 예외가 발생하면 기본적으로 트랜잭션을 roll-back하지 않고 예외를 던져주는 반면, Unchecked Exception은 예외 발생 시 트랜잭션을 roll-back한다는 점에서 차이가 있습니다.</br>
<br>- 참고 : 롤백이란 트랜잭션 내에서 발생한 모든 변경 작업을 취소하고 이전 상태로 돌리는 과정(데이터 일관성 유지)<br>
- 대표적인 Checked : Exception , UnChecked : RuntimeException<br>
</details>

<details markdown = "1">
<summary>문자열을 리터럴(string = "abcd")로 할당하는 것과 객체(string = new String("abcd"))로 할당하는 방식의 차이가 무엇인가요?</summary>
문자열을 리터럴과 객체로 할당하는 방식의 주요 차이점은 메모리 위치와 효율성에 있습니다.<br>
리터럴로 선언된 문자열은 Heap의 String pool 영역에 저장되는 반면, new 키워드를 사용해 생성된 문자열 객체는 힙 영역에 저장됩니다.<br>
String Pool에서는 동일한 문자열 리터럴에 대해 하나의 참조만 유지하여 중복된 저장을 피하게 되는 반면 new를 사용하면 같은 내용의 문자열이라도 매번 새로운 객체가 생성되어 메모리 사용이 비 효율적이게 됩니다.
<br>
참고 - 굳이 객체로 만들어 GC 대상이 되는것 보다, String pool로 만들어 활용하는 것이 메모리 효율 측면에서 더욱 유리할 것으로 보임
</details>

<details markdown = "1">
<summary>자바에서는 왜 String을 불변 객체로 만들었을까요?</summary>
String이 불변하다는 것은 여러 참조 변수가 하나의 String 객체를 가리키고 있을때도 그 객체를 조작할 수 없다는 것을 의미합니다.<br>
이를 통해 실수나, 버그로 인한 데이터 변조의 위험에서 자유로울 수 있습니다.<br>
자바에서는 String pool이라는 메모리 영역을 활용해 문자열을 관리합니다. 이곳에는 한번 생성된 문자열들이 저장되며, 동일한 문자열에 대해서는 하나의 참조만을 유지하게 하여 메모리의 효율성을 높입니다.<br>
만약 String이 불변성을 가지지 않았다면, 같은 문자열을 참조하는 여러 변수 중 하나에서 문자열을 변경하게 되면, 그 변경이 String pool의 해당 문자열에도 반영되어,다른 모든 변수의 참조한 값도 변경되게 됩니다.<br>
<br>
참고 <br>
이거 뿐 아니라 불변 객체기 떄문에 두 문자열을 더할때 값을 저장할 새로운 문자열 객체를 만들어야 한다는 단점, 또한 동시성 제어 없이도 안전함<br>
String이 불변인 이유 -> 내부에 char[] value 배열이 final임! <br>
<br>
String str1 = "hello" , String str2 = "hello";<br>
System.out.println(str1);<br>
System.out.println(str2);<br>
<br>
str1.toUpperCase(); // -> 만약 String이 불변성을 가지지 않았다면 str1을 변경할 수 있을것<br>
<br>
System.out.println(str1); System.out.println(str2); // 만약 바뀌었다면 둘다 출력이 hello가 될것!
</details>

<details markdown = "1">
<summary>StringBuffer, StringBuilder 차이는 무엇이죠?</summary>
StringBuilder와 StringBuffer는 모두 문자열을 변경하거나 추가하는 연산을 제공하는 가변성 클래스입니다<br>
이 둘을 가르는 차이점은 동기화에 있습니다<br>
StringBuffer는 각 메서드에 대한 동기화를 지원하므로 멀티쓰레드 환경에서 안전합니다.<br>
즉 여러 스레드가 동시에 객체를 변경할 수 없으므로, 멀티스레드 환경에서 사용하면 좋습니다<br>
반면 StringBuilder는 동기화를 지원하지 않습니다. 하지만 단일 스레드 환경일 시 더 빠른 성능을 보입니다.<br><br>

참고 - 문자열 끼리 더하기 할시, 실제로는 새로운 객체를 생성한다기 보단(반은 맞고 반은 틀림), 컴파일 전 내부적으로 STringBuilder 클래스를 만들어서 사용<br>
즉, "hello" + "world" 문자열 연산이 있다면 이는 new StringBuilder("hello").append("world").toString() 과 같다는 말이다.<br>
참고 - 소켓과 같은 비동기 상황에서는 Buffer 사용하기<br>
참고 - StringBuilder와 StringBuffer는 문자열을 추가하거나 변경할 때, 새로운 객체를 생성하는 것이 아니라 기존 객체를 직접 변경합니다.<br>
참고 - String은 불변이기에 멀티쓰레드 상황 생각할 필요 X<br>

꼬리질문 - 왜 동기화가 걸려있으면 느린걸까요?
동기화란 여러 스레드가 동시에 특정 코드블록이나 메서드에 접근하는 것을 방지하여, 데이터 불일치 문제를 해결하는 기법입니다.<br>
예를들어 두개의 스레드가 동시에 StringBuffer 객체를 수정하려고 시도하면, 동기화된 메서드는 한번의 하나의 스레드의 작업만을 허용합니다.<br>
이로 인해 다른 스레드는 첫번째 스레드가 작업을 완료할때까지 기다려야하며, 이 동안 성능이 저하될수 있습니다.<br>
이렇게 스레드가 다른 스레드의 작업을 완료하기를 기다리는 것을 블로킹이라고 합니다. 이러한 블로킹은 많은 시스템 리소스를 소비하고,<br>
이 동안 CPU는 유휴상태가 될 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>왜 StringBuilder가 단일 스레드 환경에서 더 빠른 성능을 보이죠? </summary>
StringBuilder가 단일 스레드 환경에서 더 빠른 성능을 보이는 이유는 '동기화 오버헤드' 때문입니다.<br>
동기화는 멀티스레드 환경에서 데이터의 일관성을 유지하기 위해 필요한 작업이지만, 그 과정에서 추가적인 시스템 리소스를 소모합니다. 이를 '동기화 오버헤드'라고 합니다.<br>
StringBuffer의 모든 주요 메소드는 동기화 되어 있습니다. 따라서 멀티스레드 환경에서는 안전하지만, 단일 스레드 환경에서는 필요 없는 동기화 비용이 발생하게 됩니다.<br>
반면에 StringBuilder는 동기화를 지원하지 않습니다. <br>
그래서 동기화에 따른 오버헤드 없이 작동하기 때문에, 단일 스레드 환경에서는 StringBuilder가 StringBuffer보다 빠른 성능을 보이게 됩니다."
</details>

<details markdown="1">
<summary>String, StringBuffer, StringBuilder 차이:star:  </summary>
A)<br>

<img src="https://user-images.githubusercontent.com/78812317/171040842-1b72da3f-0b74-4c14-b7f3-3ea84399c5c8.png">
<br>
String 객체는 한번 생성되면 할당 메모리 공간이 변하지 않습니다. 따라서 값이 변경되지 않습니다.<br>
장점-불변이기때문에 단순 조회연산에서 타 클래스보다 빠르고, 불변이기때문에 동기화를 신경쓸 필요가 없습니다.<br>
단점-문자열연산이 자주 일어나면 더이상 참조되지 않는 객체는 GC대상이 되며 이들이 쌓입니다.<br>
<br>
StringBuffer, StringBuilder는 mutable(가변)입니다. 문자열 연산 시 메모리 크기를 변경시켜 문자열이 변경됩니다.<br>
문자열 연산이 자주 있을 시 사용하는 것이 좋습니다.<br>
둘 사이의 차이는 동기화 여부에 있습니다. <br>
StringBuffer는 메서드마다 synchronized 예약어가 걸려있어 멀티스레드 환경에서 동기화를 지원합니다.<br>
StringBuilder는 동기화를 보장하지 않습니다. 그 대신 연산처리가 StringBuffer보다 빠릅니다.<br>
결론적으로 멀티스레드 환경에선 StringBuffer, 싱글스레드 환경에선 StringBuilder를 사용하는 것이 좋습니다.<br>
</details>

<details markdown = "1">
<summary>래퍼 클래스란 무엇이죠? </summary>
래퍼 클래스란 자바의 기본형 데이터 타입을 객체로 다루기 위한 클래스를 의미합니다.<br>
이러한 각각 기본 데이터 타입에 대응하는 래퍼 클래스가 있으며, 이를 통해 기본 데이터 타입도 객체처럼 다룰수 있습니다.<br>

참고 - int : Integer, char : Character, 나머지는 기본 타입의 앞글자만 대문자
</details>

<details markdown = "1">
<summary>래퍼 클래스를 사용하는 이유엔 어떤것들이 있을까요?</summary>
java의 컬렉션 프레임워크는 객체만 저장할 수 있습니다. 따라서 기본 데이터 타입을 컬렉션에 저장하려면 해당 데이터 타입의 래퍼 클래스로 변환해야 합니다.<br>
그리고 기본 데이터 타입은 null 값을 가질 수 없습니다. 그러나 특정 상황에서 변수가 아무런 값도 가지고 있지 않음을 나타내고 싶은 경우 래퍼클래스를 사용하여 null값을 할당할 수 있습니다.<br>
<br>
참고: 기본 데이터 타입은 객체가 아니라서 직접 동기화를 수행할 수 없다.(객체만 java의 동기화 메커니즘을 사용할수 있기에..)<br>
참고 : 일반적으로 객체의 경우 외부에서 함부로 값을 변경할 수 없음...(바꿀려면 아마 set? : 캡술화 반영)<br>
</details>

<details markdown = "1">
<summary>Boxing과 UnBoxing이 무엇이죠?</summary>
박싱은 기본 타입의 데이터를 래퍼 클래스의 인스턴스로 변환하는 것이고<br>
언박싱은 래퍼클래스의 인스턴스에 저장된 값을 기본 타입의 데이터로 변환하는 것입니다.<br>
</details>

<details markdown = "1">
<summary>AutoBoxing과 UnBoxing이 무엇인지와 사용시 주의해야할점에 대해 설명해주세요.</summary>
오토 박싱이란 기본 데이터 타입의 값을 래퍼 클래스의 객체로 변환하는 과정입니다.<br>
오토 언박싱은 래퍼 클래스의 객체가 그에 해당하는 기본데이터 타입의 값으로 변환되는 과정을 말합니다.<br>
주의해야할 점으로 우선 성능상의 이슈가 있습니다.<br>
AutoBoxing과 UnBoxing은 내부적으로 객체를 생성하거나, 참조를 변환해야 하는 과정을 거치므로 반복적인 연산이 필요한 경우 성능 저하를 일으킬 수 있습니다.<br>
또한 AutoBoxing을 통해 래퍼 클래스의 객체를 생성할때 null을 할당할 경우, 이후 UnBoxing 시 NPE가 발생할 수 있습니다.<br>
또한 == 로 값을 비교할때 값이 아닌 참조를 비교하게 되므로 이에 대해 주의해야 합니다.<br>
</details>

<details markdown = "1">
<summary>Enum이란 무엇이죠?</summary>
Enum이란 특정 변수가 가질 수 있는 값의 집합을 미리 지정한 자료형입니다.(즉 변수가 특정한 값들 중 하나만 가질 수 있게 하려고 할떄)<br>
Enum은 명시적으로 특정 값들만을 가질 수 있기에, 그 외의 값들을 가지려 하면 컴파일 오류가 발생합니다. 이로 인해 코드의 안정성을 높일 수 있습니다.<br>
또한 enum의 각 상수는 해당 타입의 유일한 인스턴스를 나타내므로, 이를 통해 Singleton 패턴을 구현하는데 사용할수있습니다.<br>
따라서 멀티쓰레드 상황에서 안전<br>
<br>
참고 - ex)enum Day{Mon,Tue,Wed,Thurs,FRI,SAT,SUN) ~~~ , Day day = "not a day" // 컴파일 에러
</details>

<details markdown = "1">
<summary>프레임워크와 라이브러리의 차이에 대해 설명해주세요.</summary>
프레임워크란 소프트웨어 개발을 위해 만들어진 구조나 도구의 집합을 의미합니다.<br>
개발자는 프레임워크의 규칙과 패턴에 따라 개발을 진행하며, 프레임워크가 제공하는 틀안에서 구현한 코드를 실행하고 확장할수 있습니다.<br>
라이브러리는 소프트웨어 개발에 자주 쓰일만한 코드를 미리 구현해놓고, 필요한 곳에서 호출하여 사용 가능하도록 만들어진 집합을 뜻합니다<br>
둘다 개발 생산성을 올리기 위한 도구라는 점에서 같지만, 이 둘은 흐름에 대한 제어의 권한이 어디있냐에 따라 차이가 있습니다.<br>
즉 프레임워크는 전체적인 흐름을 자체적으로 가지고 있으며 프로그래머가 그 안에 필요한 코드를 작성하는 반면(IOC)<br>
라이브러리는 사용자가 흐름에 대해 제어를 하며 필요한 상황에 가져다 쓰는 것입니다.<br>
<br>
참고 - 프레임워크에는 라이브러리들이 포함되어있음(라이브러리가 프레임워크 구성), 라이브러리 하나가 모듈과 유사한 개념<br>
참고 - 스프링에서 JPA는 라이브러리, 개발자는 필요한 경우 JPA를 선택하고, 기능을 사용하기 위해 해당 API 호출<br>
참고 - 스프링 프레임워크 자체는 JPA 라이브러리 사용하는 것 이상을 제공, 전체적인 구조와 흐름을 제어하기 위해 IOC 컨테이너와 DI 기능 제공<br>
</details>

<details markdown = "1">
<summary>equals()와 hashCode() 메서드가 무엇인지 설명해주세요</summary>
equals()는 객체의 내용이 같은지 비교할때 사용하는 메서드이고 hashCode()는 객체의 메모리 주소를 기반으로 고유한 정수값을 반환하는 메서드입니다(Heap에 저장된 객체의 메모리 주소, 두 객체가 동등한지 비교할때 주로 사용).
<br>
동일한 객체는 항상 동일한 메모리 주소를 가집니다. 결과로, 기본 hashCode()는 객체의 메모리 주소를 기반으로 하는 해시 코드를 반환합니다. 따라서 동일한 객체는 동일한 해시 코드를 가져야 합니다. 그러나 객체의 내용을 기반으로 equals() 메서드를 재정의(오버라이드)했을 때, 그 내용이 동일한 두 객체가 서로 다른 해시 코드를 반환하는 상황을 피하기 위해 hashCode() 메서드도 함께 재정의하는 것이 중요합니다. 이렇게 함으로써 동일한 내용을 가진 객체가 동일한 해시 코드를 반환하도록 보장할 수 있습니다."
<br>
<br>
꼬리질문 - 이 둘을 왜 같이 사용하는지에 대해 예시와 함께 설명해주시겠어요?
저는 HashTable을 통해 예를 들어보겠습니다. 해시 테이블은 내부적으로 hashCode() 메서드를 이용하여 객체를 저장하고 검색하는 위치를 결정합니다.<br>
이때 hashCode() 메서드가 반환하는 값이 같다면, 이 두 객체는 같은 버킷에 위치하게 됩니다.<br>
그러나 hashCode가 같다고 이 두 객체가 항상 같은것은 아닙니다. 이는 해시 충돌 떄문인데, 서로 다른 두 객체가 동일한 해시코드를 가질 수 있기 때문입니다.<br>
이런 경우를 구분하기 위해 equals() 메서드를 사용하여 두 객체의 실제 내용을 비교합니다.<br>
<br>
따라서 equals() hashCode() 메서드는 항상 함께 오버라이드 해야합니다. 예를들어 equals() 메서드만 오버라이드 하고, hashCode() 메서드를<br>
오버라이드 하지 않는다면, 내용이 같은 두 객체의 해시코드가 다를 수 있어 해시 기반 컬렉션에서 예상치 못한 결과를 가져올 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>제네릭이 무엇이고 어떨때 사용하나요??</summary>
제네릭이란 클래스나 메서드에서 사용할 내부 데이터 타입을 미리 지정하는 방식입니다.<br>
이러한 제네릭은 타입 안정성을 보장합니다.즉 제네릭을 사용하면 컴파일 시에 데이터 타입 체크가 가능하므로, 실행 시 불필요한 타입 변환을 방지하고, 잘못된 타입의 객체가 저장되는 것을 막을 수 있습니다.<br>
또한 제네릭을 사용하면 하나의 코드를 다양한 타입에 대해 사용할 수 있기에 코드 재사용성이 좋아집니다.<br>
예를들어 List인터페이스를 구현하는 ArrayList 클래스는 다양한 타입의 객체를 저장할 수 있게끔 제네릭을 사용합니다.(특정 타입에 종속되지 않는 유연한 코드 작성)<br>
<br><br>
참고 - 예를들어 ArrayList에 제네릭을 지정하지 않으면 "hello"도 저장가능하고 1도 저장가능함<br>
이는 Object 형식으로 반환을 하는데 String text = (String)list.get(1)이라고 하면 ClassCastException이 발생할 수 있음<br>
하지만 제네릭을 사용하면 컴파일 시점에 오류가 나기에 list.add(1)은 가능하지 않음<br>
<br>
꼬리질문 - 와일드카드가 무엇인지 아시나요??<br>
와일드 카드란 제네릭 타입에 다형성을 적용하고자 할때 사용하는 개념입니다.<br>
이것은 ?를 사용하는데, 이때 extends를 통해 와일드 카드의 상한 제한(T와 그 자손만), super를 통해 와일드 카드의 하한 제한(T와 그 조상들만 가능)을 할 수 있습니다.<br>
이러한 와일드 카드를 이용하면 하나의 참조변수로 다른 타입의 지네릭 타입이 지정된 객체를 다룰 수 있습니다.<br>
<br>참고<br>
ArrayList<? extends Product> list = new ArrayList<TV>() or new ArrayList<Audio>();
</details>

<details markdown = "1">
<summary>애너테이션이 무엇인지 설명해주세요.</summary>
애너테이션이란 프로그램에게 정보를 제공하는 주석을 뜻합니다.<br>
이러한 애너테이션에는 자바에서 기본적으로 제공하는 표준어노테이션(@Override, @Deprecated)와 다른 어노테이션에 대한 정보를 제공하는 메타 에너테이션이 있으며,<br>
사용자가 직접 정의를 하여 사용할 수 있습니다.<br>
이러한 애너테이션을 사용하여 롬북과 같이 프로그램 작성시 코드를 자동 생성하도록 정보를 제공할수도 있고, 런타임에 특정 기능을 실행하도록 정보를 제공할 수 있습니다.(@Transactional)<br> 
</details>

<details markdown = "1">
<summary>JDK, JRE, JVM란 무엇인지 설명해주세요.</summary>
JDK(Java Development Kit)이란 Java 언어로 소프트웨어를 개발하기 위한 소프트웨어 개발 도구 모음을 뜻합니다.<br>
이러한 JDK에는 자바 개발시 필요한 라이브러리들과, java compiler(자바 코드 -> 바이트 코드)과 jar(java 클래스 파일을 하나의 아카이브 파일로 패키징)와 같은 개발 도구들이 포함되어있습니다.<br>
그리고 자바 프로그램을 실행시키기 위한 JRE(Java Runtime Environment)또한 포함되어있습니다.(라이센스에 따라 여러 JDK 종류가 있음)<br>
JRE는 Java 응용 프로그램을 실행하는 데 필요한 최소 환경을 뜻하며 여기에는 클래스 라이브러리, JVM(Java Virtual Machine) 및 배포 도구가 포함됩니다.(이러한 소프트웨어 구성 요소를 사용하여 모든 디바이스에서 바이트 코드를 실행합니다.)<br>
JVM은 Java Virtual Machine의 약자로, 자바 바이트 코드를 실행하는 소프트웨어를 의미합니다.<br>
이러한 JVM은 바이트 코드를 해당 OS나 하드웨어 아키텍처에 알맞은 기계어로 해석 또는 실행해주기에, 플랫폼(운영체제)에 관계 없이 독립적으로 프로그램을 실행할 수 있습니다.<br>
<br><br>
참고 - 바이트코드란 특정 하드웨어가 아닌 가상 머신에서 실행되도록 고안된 특별한 형태의 중간 코드<br>
기계어란 컴퓨터의 CPU가 직접 이해할 수 있는 저 수준의 언어(CPU에 따라 각각 인스트럭션 셋이라고 하는 기계어 명령어 세트를 가짐)<br>
java C에 비해 JVM을 거쳐야 하길래 상대적으로 느림<br>
<br>
간단히 자바 컴파일 과정 - 자바 소스코드(.java)는 자바 컴파일러에 의해 바이트코드(.class 파일)로 변환됨.<br> 
이렇게 생성된 바이트 코드는 JVM 위에서 실행되는 동안, JVM 내부의 인터프리터에 의해 해당 시스템의 기계어로 해석된 후 실행됨<br>
하지만 인터프리터는 모든 코드라인을 읽으면서, 중복된 코드에 대해서도 매번 다시 읽음<br>
이러한 인터프리터 단점을 극복하기 위해 JIT(Just-in-Time) 컴파일러도 함께 사용함(자주 사용되는 코드 캐싱하여 빠름)<br>
자바 개발 도구인 JDK를 이용해 개발된 프로그램은 JRE에 의해 가상의 컴퓨터인 JVM 상에서 구동됩니다.
</details>

<details markdown = "1">
<summary>JVM이 무엇인지 설명해주세요.</summary>
JVM은 Java Virtual Machine의 줄임말로, OS와 Java Application 사이를 중재해주는 가상 머신입니다.<br>
JVM은 JVM 내부에서 클래스 파일을 로드(Runtime Data Area) 및 링크하는 ClassLoader, 실제 실행과 번역을 담당하는 Execution Engine, 힙 메모리에서 참조되지 않는 객체를 삭제하는 Garbage Collector, JVM의 메모리 영역인 Runtime Data Area로 구성이 되어있습니다.<br>
<br>
바이트 코드는 인터프리터로 직접 실행되거나, JIT 컴파일러를 통해 기계어로 변환된 후 실행 될 수 있다.
</details>

<details markdown = "1">
<summary>Java Application이 JVM에서 실행되는 과정을 설명해주세요.(or JVM 동작 방식)</summary>
<img src="https://user-images.githubusercontent.com/78812317/171031807-05d65d39-d665-4d96-9291-1f1b881efbdf.png"><br>
자바 소스 코드는 먼저 자바 컴파일러(javac)에 의해 바이트 코드(.class 파일)로 변환됩니다.<br>
이러한 바이트 코드가 준비된 이후, 프로그램을 실행하면 JVM이 OS로 부터 필요한 메모리를 할당받고, 이 메모리는 특정 영역으로 나뉘게 됩니다.<br>
클래스 로더는 동적 로딩을 통해 프로그램 실행에 필요한 파일을 런타임 중에 로드하며, 로딩된 클래스 파일은 Runtime Data Area(JVM 메모리)배치됩니다.<br>
Execution Engine은 이러한 바이트 코드를 해석하고 기계어로 변환하여 실행합니다.
JVM의 바이트 코드는 기본적으로 인터프리터 방식으로 실행되지만, 효율성을 위해 JIT(Just in Time)컴파일러를 사용하기도 합니다.<br>
<br>
JIT 컴파일러는 자주 사용되는 코드를 기계어로 미리 변환하고, 이후에는 변환된 코드를 직접 실행하여 성능을 향상시킵니다.<br>
그리고 프로그램 실행 도중 JVM의 가비지 컬렉터는 더이상 참조되지 않는 객체를 메모리에서 제거하여 메모리 관리를 합니다.<br>
<br><br>
JIT 컴파일러에 대해 자세히 물어볼시<br>
JIT 컴파일러는 프로그램이 실행되는 동안 어떤 코드가 자주 실행되는지, 즉 어떤 부분이 핫스팟인지 분석합니다.<br>
이렇게 분석을 통해 핫스팟을 식별하면, JIT 컴파일러는 해당 코드를 기계어로 컴파일합니다.<br>
이렇게 컴파일된 코드는 메모리 내에 저장되고,이후 같은 코드가 실행될 경우 빠르게 재사용될 수 있습니다.<br>
인터프리터나 JIT 컴파일러에 의해 변환된 코드는 CPU에서 실행됨<br>
</details>

<details markdown = "1">
<summary>클래스 로더에 대해 아시는대로 설명해주세요.</summary>
자바 컴파일러를 통해 생성된 클래스 파일들은 각 디렉터리에 흩어져 있습니다.<br>
이렇게 흩어져 있는 각각의 클래스 파일을 찾아서 동적로딩 방식으로 JVM 메모리 영역에 탑재해주는 것이 클래스 로더입니다.<br>
클래스 파일의 로딩 순서는 Loading- Linking - initialization 과정을 거칩니다.<br>
로딩은 클래스 파일(바이트 코드)을 읽어 JVM 메모리에 로드하는 과정이고,Linking은 바이트 코드가 올바른지 검증하고, 정적 변수를 메모리에 할당하는 과정입니다.
마지막으로 Initialization 단계에서는 정적 변수를 초기값으로 설정하게 됩니다. 
이 과정까지 끝나면 JVM에서는 클래스 파일을 구동시킬 준비를 마친것입니다.<br> 
<br>
참고 - 필요하다 할때 로드된다 == 클래스내 특정 메소드가 호출되거나 특정 객체가 생성될때를 의미함<br>
</details>


<details markdown = "1">
<summary>JVM 메모리 구조에 대해 설명해주세요 == 자바 Runtime Area에 대해 설명해주세요.</summary>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/352afd61-3ce2-4136-bd4e-fb09e240aeb8">
JVM 메모리 구조는 총 5가지의 영역(메서드 영역, 힙 영역, Stack 영역, Pc Regsiter, Native Method Stack)으로 구성되어있습니다.<br><br>

method, runtime constant pool, heap are는 모든 스레드에서 공유<br>
stack, pc register, native method stack area는 각 스레드 별로 생성됨<br>

메서드 영역(static 영역이라고도함)은 JVM이 시작될때 생성되며, 모든 스레드가 공유하는 영역입니다.(바이트 코드가 로드되는 곳)<br> 
이 영역에서는 (클래스 로더에 의해 로드된) 클래스의 변수의 이름, 타입, 접근 제어자 등과 같은 클래스 관련 메타데이터 저장됩니다.<br> 
그외에도 static 변수, 인터페이스 등이 저장됩니다.(jvm이 동작하고 클래스가 로드되어 프로그램이 종료될떄 까지 저장됨)<br>
<br>

힙 영역은 런타임에 객체를 동적으로 할당하기 위한 공간으로 new 연산자로 생성된 객체나 배열이 인스턴스가 저장됩니다.<br>
이러한 힙 영역에서 참조되지 않는 객체는, 가비지 컬렉터에 의해 제거됩니다.<br>
<br>
(유의할 점은 힙 영역에 생성된 객체와 배열은 Reference Type으로서, `JVM 스택영역의 변수나 다른 객체 필드에서 참조된다는 것!!!!`)<br>
즉, 힙의 참조 주소는 스택이 가지고 있고, 해당 객체를 통해서만 힙 영역에 있는 인스턴스 핸들링할 수 있다.<br>
<br>

Stack 영역은 각 스레드가 작업을 수행하는 과정에서 지역 변수(+매개변수)와 같이 임시적으로 사용되는 변수나 정보들이 저장되는 영역입니다.<br>
특정 메서드가 호출될 때, 해당 메서드와 관련된 정보(지역변수, 반환값, 메서드에 대한 참조 등)는 스택 프레임(현재 실행중인 메서드 상태 정보 저장)이라는 구조로 스택에 push됩니다.<br>
메서드의 수행이 끝나면 해당 스택 프레임은 pop되어 제거됩니다.<br>
<br>

PC Register(CPU 레지스터와 다름)는 현재 (스레드가) 수행중인 JVM 명령어 주소를 저장하는 공간입니다.<br>
이때 JVM 명령(Instruction)의 주소는 쓰레드가 어떤 부분을 무슨 명령으로 실행해야 할지에 대한 기록을 가지고 있습니다.<br>
메서드 호출이 발생할 경우 PC Register의 값은 현재 실행 중인 명령어 주소에서 변경되어, 호출된 메서드의 첫번째 명령어 주소로 설정되고, 메서드 실행이 완료되면 원래의 주소로 복귀하게 됩니다.<br>
<br>

마지막으로 Native Method Stack은 기계어로(바이트 코드 X) 작성된 프로그램이나, 자바 이외의 언어로(C, C++ 등) 작성된 네이티브 코드를 실행하기 위한 영역입니다.<br><br>
여기에는 네이티브 메서드의 실행정보(호출 정보 및 지역 변수 등)가 저장됩니다.<br><br>
<br>

참고 - static 변수와 메서드는 무조건 메서드 영역에 포함됨<br>
메서드 영역에는 런타임 상수풀이 위치하고 있는데, 이는 클래스나 인터페이스에 대한 상수, 메서드와 필드에 대한 참조 등을 저장합니다.이 뿐만 아니라 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변환하기 위한 추가 정보를 포함합니다.<br>
힙 영역에 생성된 객체는 JVM 스택 영역의 변수나 다른 객체 필드에 의해 참조되는데, 이렇게 참조되는 동안은 생존하지만, 더이상 참조되지 않으면 GC의 대상이 됩니다.<br>
기본형 타입 변수는 스택영역에 직접 값을 가지는데 비해, 참조 타입의 변수는 힙 영역이나 메서드 영역의 객체 주소를 가짐<br>
<br>
독립적 예시<br>
예를 들어, 한 쓰레드가 현재 실행 중인 명령어를 중단하고 다른 쓰레드가 수행되어야 할 경우(Context Switching), 첫번째 쓰레드의 PC 레지스터는 그 쓰레드가 다시 실행될 때 어디서부터 시작해야 하는지를 가리키는 주소를 유지합니다.
이렇게 함으로써 각 쓰레드는 자신의 작업을 독립적으로 수행하고, 다른 쓰레드의 작업에 영향을 주지 않는 것입니다<br>
</details>

<details markdown = "1">
<summary>자바 메모리 상수풀 영역(RunTime Constant Pool)에 대해 아시는대로 설명해주세요 </summary>
상수풀 영역은 Method 영역안에 위치하며, 클래스나 인터페이스에 대한 상수(static), 메서드와 필드에 대한 참조 정보
및 리터럴(숫자,문자열 등) 저장하는 영역입니다.<br>
<br>
(ex: 참조정보? object.myMethod()는 해당 메서드의 실제 메모리 주소를 가리키지 않음. 대신 상수풀에 저장된 myMethod에 대한 참조정보를 통해 해당 메서드를 찾아감) 
<br>
문자열 리터럴 또한 Heap 영역이 아닌 이 상수풀에 저장되며, 같은 내용의 문자열 리터럴은 한개만 생성됩니다.<br>
예를 들어 여러 곳에서 "Hello"라는 문자열 리터럴을 사용하더라도, "Hello"라는 문자열 리터럴은 상수풀에 한 번만 저장됩니다. 그 이후로는 해당 문자열 리터럴에 대한 참조가 재사용됩니다.<br>
<br>
<br>
참고 내용<br>
public class Test{<br>
    int a = 10; <br> // a라는 멤버변수는 힙영역에 저장되어있는 Test의 인스턴스 내에 있음(즉 힙영역에 저장되어있음).10이라는 값은 a가 저장되는 메모리 공간에 저장되므로 힙에 저장됨<br>
    static int b = 20;  // b라는 멤버변수는 Method Area에 저장되며, 20이라는 값은 b라는 값이 저장되어있는 Method Area라는 곳에 저장됨<br>
    Person person = new Person(); // person 참조 변수는 Test의 인스턴스 내에 저장되어 있고, Person 객체 자체는 힙 영역에 새롭게 저장됩니다<br>
    Static Person staticPerson = new Person();// staticPerson 참조 변수는 메서드 영역에 저장되며, 새 Person 객체는 힙 영역에 저장됩니다.
    <br>
    <br>
    public void myMethod(){<br>
        Person localPerson = new Person(); // localPerson 참조 변수는 스택 영역에 저장되고, 새로운 Person 객체는 힙 영역에 저장됩니다.<br>
        String str = "hello" // str 참조 변수는 스택 영역에 저장되며, "hello" 문자열 자체는 상수 풀에 저장됩니다.<br>
        System.out.println(localPerson);<br>
    }<br>
}<br>
정리하자면 클래스의 멤버변수(인스턴스 변수,non-static 필드)와 그 객체는 힙 영역에 저장됨<br>
클래스 변수(static 필드)는 메서드 영역에 저장됨<br>
메서드 내부에 선언된 지역변수는 스택 영역에 저장됨<br>
객체는 힙 영역에 생성되며, 그 참조 변수는 선언 위치에 따라 힙(멤버변수), 스택(지역변수), 메서드 영역(static 멤버 변수)에 저장됨.<br>
스트링 리터럴은 상수풀에 저장됨<br>
</details>

<details markdown = "1">
<summary>JNI(Java Native Interface)가 무엇인지에 대해 설명해주세요</summary>
JNI는 자바 가상머신(JVM)위에서 실행되고 있는 자바코드가 네이티브 응용 프로그램(하드웨어와 운영 체제 플랫폼에 종속된 프로그램들) 그리고 C언어나 어셈블리 같은
다른 언어들로 작성된 라이브러리들을 호출하거나 반대로 호출되는 것을 가능하게 하는 프로그래밍 프레임워크입니다.<br>
이러한 JNI를 사용하여 C나 C++로 작성된 함수를 호출한다면, 이러한 함수의 실행정보는 네이티브 메서드 스택에 저장됩니다.<br>
</details>

<details markdown = "1">
<summary>자바 변수의 종류와 각각이 메모리 상 어디에 할당되는지 설명해주세요.</summary>
자바의 변수는 크게 지역 변수, 매개변수, 인스턴스 변수, 클래스 변수로 나뉩니다.<br>
지역변수는 메서드 내부에 선언되어 있는 변수로, 이는 메서드의 호출과 함께 스택 영역에 할당되며, 메서드가 작업을 완료하면 소멸됩니다.<br>
매개변수는 메서드 호출 시 전달되는 인수를 메서드 내부로 전달하는 변수입니다. 이는 지역변수와 마찬가지로 메서드가 호출될때 매개변수가 스택 영역에 할당되며, 이 변수들은 메서드의 호출이 끝나면 스택에서 사라집니다.<br>
인스턴스 변수는 클래스 내에서 static이 아닌 변수를 뜻합니다. 인스턴스 변수는 클래스의 객체를 생성할때 생성되는 변수로 힙 영역에 할당 되며, 각 객체마다 별도의 저장공간을 가지게됩니다.<br>
마지막으로 클래스 변수는 static 키워드를 사용하여 선언되며, 해당 클래스의 모든 인스턴스에서 공유합니다.<br>
이러한 클래스 변수는 메서드 영역에 할당되며, 클래스가 클래스 로더에 의해 로드될때 한번 생성되어 프로그램이 종료될때 까지 유지됩니다.<br>
<br>
<br>
참고 - 지역변수와 매개변수는 방식 동일<br>
참고 - 각 스레드는 자신만의 스택을 가지며, 이는 스레드가 생성될때마다 생성<br>
멤버변수 - GC에 의해 관리됨<br>
Counter sub = new Counter()라는 코드가 있다면 new Counter()에 의해 객체 자체는 힙영역에 생성되며 이는 생성된 객체의 메모리 주소를 반환<br>
이 반환된 주소는 sub라는 변수에 할당되는데, sub는 이 메모리 주소를 가지고 있으면서 스택 메모리에 할당됩니다.<br>
따라서 sub는 스택영역에 위치하면서, 그 값으로 힙 영역에 위치한 Counter 객체를 참조하게 됨<br>
<br>
int a = 10; 이렇게 했을때 a 뿐만아니라 10또한 스택 영역에 저장됨(정확히는 a라는 공간에 10이 저장됨), 즉 값 자체가 변수에 저장되는 특징<br>
int[] a = new int[5]; 이렇게 하든 Custom[] arr = new Custom[6]; 이렇게 하든 배열은 무조건 힙 영역에 저장됨<br>
위와 같이 참조형 배열의 경우에는 처음에 각 요소는 아무런 객체도 참조하고 있지 않기에 null 값을 가지고 있음<br>
참조형 배열안에는 그 객체들의 주소를 가지고 잇다. 참조만을 저장함으로서 메모리를 효율적으로 사용<br>
</details>

<details markdown = "1">
<summary>가비지 컬렉터란 무엇인가요???</summary>
가비지 컬렉터는 자바의 JVM 내에 위치한 메모리 관리 도구입니다. 이는 힙 영역에 할당된 객체 중에서 더 이상 참조되지 않는 객체들을 자동으로 탐지하고 회수하여 메모리를 관리하게 됩니다.
C언어의 경우에는 개발자가 직접 메모리를 할당(malloc)하고 해제(free)하는 과정을 거칩니다. 이렇게 메모리 관리를 개발자에게 맡기면, 메모리 누수나 해제하지 않은 메모리로 인한 버그의 문제가 발생할 수 있습니다.<br>
반면 자바의 경우에는 가비지 컬렉터가 이러한 메모리 관리를 대신해주어 메모리누수와 같은 문제를 상당 부분 완화시켜주고 프로그래머가 오로지 로직에 집중할 수 있게 해줍니다.
다만 가비지 컬렉션 동작 시 GC작업을 위한 스레드 외 모든 스레드가 종료 되는 Stop-the-world가 발생할 수도 있습니다.(일부 알고리즘, GC특성상 어쩔수 없음)<br>
<br>
꼬리질문 - 메모리 누수란 무엇인가요? 가비지 컬렉터가 메모리 관리를 대행해주기에 개발자는 메모리 누수와 같은 문제를 아예 신경쓰지 않아도 되나요?<br>
메모리 누수(Memory Leak)은 프로그램이 필요하지 않은 메모리를 계속해서 점유하고 있는 상태를 말합니다.<br>
이러한 메모리 누수가 발생한다면, 시간이 지남에 따라 사용가능한 메모리가 점점 줄어들어 성능 저하와 함께 프로그램이 중단되는 현상까지 발생할수 있습니다.<br>
<br>
예를들어 개체를 계속 생성만 하고 참조를 해제하지 않으면 해당 객체는 메모리 상에 계속 남게되어 메모리 누수가 발생합니다.<br>
이러한 상황이 반복되면, 사용 가능한 메모리 공간이 점차 줄어들게 되는데 이를 메모리 누수라고 합니다.<br>
<br>
자바에서는 가비지 컬렉터가 메모리 관리를 대행하므로 메모리 누수 문제를 상당 부분 완화할 수 있습니다. 하지만, 프로그램 내에서 계속 참조되는 객체, 즉 더 이상 필요하지 않지만 여전히 참조되고 있는 객체는 가비지 컬렉터에 의해 회수되지 않습니다. 따라서, 해당 객체는 메모리 누수의 원인이 될 수 있습니다.<br>
결론적으로, 가비지 컬렉터가 있더라도 개발자는 참조 관리와 객체의 생명주기를 적절히 관리해야 하며, 불필요한 참조를 제거하여 메모리 누수를 방지해야 합니다.<br>
<br>
꼬리질문 - Stop the world가 발생하는 이유가 뭐죠?<br>
가비지 컬렉션 도중 다른 스레드가 동작하면 메모리 구조가 변경될 수 있어, 이로 인해 안정적인 메모리 회수가 어려울 수도 있습니다.<br>
이러한 상황을 막고 GC가 안전하게 메모리를 회수하기 위해 애플리케이션의 모든 스레드를 일시 중지(Stop the world)시키게 됩니다.<br>
<br>
참고 - 예를들어 db연결 커넥션 반납하는 것들이 있을 것<br>
참고 0 메모리 누수 예제 : 스트림 객체를 사용하고 닫지 않은 경우, 디비 커넥션 얻은 후 닫지 않은 경우
참고 - 개발자는 메모리가 언제 해제되는지 알지 못함.
</details>

<details markdown = "1">
<summary>JAVA의 Garbage Collection이 필요한 이유에 대해 설명해주세요</summary>
JAVA에서는 개발자가 직접 메모리를 해제하는 방법을 제공하지 않습니다.<br>
이로 인해 시간이 지남에 따라 사용하지 않는 객체들이 메모리에 계속 존재하게 될 수 있습니다.<br> 
이런 미사용 객체들이 메모리를 계속 점유하게 되면 결국 메모리 부족 현상(Heap 메모리 부족)이 발생할 위험이 있습니다<br>
Garbage Collection은 이런 문제를 방지하기 위해 더 이상 참조되지 않는 객체를 자동으로 탐지하고 메모리에서 해제하는 역할을 수행합니다.<br>
<br>
가비지 컬렉션 대상 -> 참조되지 않는 객체(ex: 메서드가 끝나는 등의 이벤트로 인해 Heap Area 객체의 메모리 주소를 가지고 있던 참조 변수가 삭제된다면? 어디서든 참조 되지 않는 상태가 됨)
</details>

<details markdown = "1">
<summary>mark and sweep과 mark and compact 알고리즘에 대해 설명해주세요(메모리 해제의 기준을 나타내는 알고리즘)</summary>
가비지 컬렉션의 기본 알고리즘 중 하나인 mark and sweep 알고리즘은 두 단계로 구성되어있습니다.<br>
mark 단계에서는 root set에서 시작하여 접근가능한 모든 객체를 마킹합니다.(root set은 GC가 참조를 검색하는 출발점으로, Heap 영역을 참조하는 포인터나 변수 등) method area, stack 등등이 있음)<br>
sweep 단계에서는 마킹되지 않은 객체를 메모리에서 해제합니다. 이렇게 해제된 메모리는 새로운 객체의 할당을 위해 사용할 수 있게 됩니다.<br>
<br>
해제 과정을 거친 후,  사용하지 않는 메모리 공간(가비지)이 분산되어있으면, 이들 공간이 합쳐지지 않아 큰 객체를 위한 연속적인 메모리 공간을 확보하는 것 어려워집니다. -> 단편화 된것을 의미<br>
이러한 문제를 해결하기 위해 mark and compact 알고리즘이 제안되었습니다. 이때는 mark and sweep과 다르게 compact라는 과정을 거칩니다.<br>
이 compact 단계에서는 사용중인 객체들을 메모리의 한쪽 끝으로 이동시키고, 그로 인해 메모리 공간을 압축합니다. 이를 통해 연속적인 메모리 공간을 효율적으로 확보하게 됩니다.<br>
<br>
참고 - compact과정을 거치면 메모리 할당을 보다 효율적으로 할수 있지만 Stop-the-world 시간이 늘어날수있다는점 유의<br>
mark-compact는 참조되지 않는 객체를 명시적으로 제거하는 sweep 과정을 거치지 않지만, compact 과정을 통해 살아있는 객체만 남기게 됨<br>
즉 메모리에서 직접적으로 제거하는 작업이 없어도, 더이상 참조되지 않는 객체는 더이상 접근할 수 없는 메모리 영역에 남게됨.이후 메모리 할당시 이 영역을 덮어쓸것<br>
</details>

<details markdown = "1">
<summary>가비지 컬렉션의 과정(동작 원리)에 대해 설명해주세요 or Minor GC와 Major GC에 대해 물어보는 경우</summary>
가비지 컬렉션은 사용되지 않는 메모리를 회수하는 과정으로, 이를 안전하게 진행하기 위해 대상 메모리 영역의 동작을 잠시 중단시키는 것이 필요합니다.<br>
JVM은 가비지 컬렉션을 수행할 때 "stop-the-world" 이벤트를 발생시킵니다. 이 이벤트 동안에는 가비지 컬렉터 쓰레드를 제외한 모든 애플리케이션 쓰레드가 작업을 중지합니다<br>
GC 작업이 완료되면, 애플리케이션의 모든 쓰레드가 다시 동작을 시작합니다. 가비지 컬렉션은 크게 Minor GC와 Major GC로 구분됩니다.<br>
<br><br>
Minor GC는 Young Generation 영역 내에서 발생하는 GC를 의미합니다.<br>
처음에 생성되는 객체는 Young Generation 영역의 일부인 Eden에 할당됩니다.<br>
객체가 계속 생성되면서 Eden 영역이 가득차면 Minor GC가 실행되는데, 이때 Reachable(참조 가능한) 객체를 식별하고(Mark), 이 객체들은 Survivor 영역으로 이동합니다.<br>
Eden 영역에서 unReachable(참조되고 있지 않은) 객체는 메모리에서 제거되고(sweep 과정을 거치고), Survivor 영역으로 이동한 객체들의 age bit 값은 1씩 증가합니다<br>
이 후 다시 Eden 영역이 신규 객체로 가득 찬다면 다시 한 번 Minor GC가 발생하게 되고, 이때 앞선 작업에서 Survivor 영역에 옮겨진 객체도 포함하여 reachable 객체를 식별합니다. 이러한 과정이 계속 반복되게 됩니다.<br>
<br>
Major GC는 Old Generation 영역이 가득 차서 발생하는 GC를 말합니다. Minor GC 과정을 거치면서 age bit 값이 임계값을 넘는 객체는 Old Generation 영역으로 이동하게 되는데, 이 과정을 Promotion이라고 합니다.<br>
Promotion이 반복되면서 Old Generation 영역의 공간이 부족해지면 Major GC(Full GC)가 발생하게 됩니다. <br>
이 과정에서는 JVM의 모든 힙 영역(Young generation, Old Generation, 메타데이터(주소 정보) 포함한 JVM 힙영역(자바 8 이후 :Metaspace, 이전 Permanent)을 대상으로 가비지 컬렉션을 진행합니다.<br>
Major GC는 상당한 시간이 소요될 수 있으며, 이는 Stop-the-world 이벤트를 길게 만들어 애플리케이션의 성능에 영향을 줄 수 있습니다.<br>
따라서, 자바 개발자와 연구자들은 Stop-the-world 시간을 최소화하면서 가비지 컬렉션의 효율을 높이는 다양한 알고리즘을 연구하고 개발해왔습니다.<br>
<br><br>
꼬리질문 - 왜 Young 영역보다 Old영역을 크게 잡을까요??<br>
Young 영역보다 Old 영역을 더 크게 잡는 이유는, 대부분의 객체가 Young 영역에서 빠르게 소멸되기 때문입니다<br>
즉, Young 영역에서는 메모리가 빠르게 회전하며, 더 많은 공간이 필요하지 않습니다. 반면에 Old 영역은 오랫동안 살아남은 객체를 저장하므로, 더 많은 공간이 필요합니다<br>
또한, Old 영역이 더 크게 설정되면 Major GC가 발생하는 빈도를 줄일 수 있습니다. Major GC는 힙의 모든 영역을 대상으로 하기 때문에, 처리 시간이 길고 CPU에 부하를 줍니다. 따라서 Old 영역을 충분히 크게 설정하면 이런 부담을 줄일 수 있습니다.<br>
<br>
참고 - Survivor 영역이 2개인 이유<br>
객체를 복사하면서 이동시키는 것이 하나의 영역에서 이루어진다면, 그 영역이 꽉찼을 때 추가적인 공간을 찾아야 하기 때문입니다.<br>
age bit란 객체가 얼마나 오래 살아남았는지 표현하는 데이터입니다.<br>
Young 영역은 새롭게 생성한 객체들이 위치하는 영역이고, Old 영역은 young 영역에서 계속 사용되어 살아남은 객체가 복사되는 영역입니다.<br>
<br><br>
Survivor 영역은 두 부분, Survivor 0와 Survivor 1로 나뉘며 이 중 한 영역은 항상 비어 있어야 합니다.<br>
Young 영역은 새롭게 생성된 객체가 할당되는 공간, Old 영역은 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역<br>
Eden 영역은 새로 생성된 객체가 위치, Survivor 0/ Survivor 1 은 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역<br>
</details>

<details markdown = "1">
<summary>가비지 컬렉터의 종류에 대해 설명해주세요(or 가비지 컬렉션 알고리즘 종류)</summary>
우선 Serial GC는 서버의 CPU 코어가 1개일때 사용하기 위해 개발된 가장 단순한 GC입니다. 이는 mark-sweep-compact 알고리즘을 사용합니다.<br>
이는 GC를 싱글스레드로 처리하여 Stop-the-world 시간이 길다는 단점이 있습니다.<br>
Parallel GC는 자바 8의 디폴트 GC로 Serial GC와 기본적인 알고리즘은 같지만 Minor GC나 Major GC 둘다 멀티스레드로 동작합니다.<br>
따라서 Serial GC보다 Stop-the-world 시간이 감소된다는 특징이 있습니다.(이걸 사용해도 Stop-the-world 발생, 그래서 GC와 애플리케이션 동작이 동시에 실행되는 것은 아님. 다만 CMS나 G1은 일시중지 없이(또는 최소화하여) GC작업을 수행하는 기능 제공하므로, 애플리케이션 동작과 GC과정이 동시에 일부 실행될 수 있다.<br>
CMS(Concurrent Mark-Sweep) GC는 Stop-the-world 시간을 최소화하기 위해 설계된 GC로 애플리케이션 쓰레드와 GC 쓰레드가 동시에 실행되는 구간이 있습니다 <br>
그러나, 힙 메모리에서의 공간 확보 및 단편화 문제가 발생할 수 있어(Old 영역에서의 연속적 공간 확보가 어려울수), 주기적인 Full GC가 필요할 수 있습니다(이걸로 단편화 해결하는게 아니라, 단편화 때문에 Old 영역에서 메모리 확보가 어려우면 발생한다는거).<br>
G1 GC는 CMS GC를 대체하기 위한 GC로 자바 9 이후부터 디폴트 GC로 지정된 GC로 애플리케이션 쓰레드와 GC 쓰레드가 동시에 실행되는 구간이 있습니다.<br>
기존 GC는 Heap 영역을 Young/Old로 나누어 사용했지만, G1 GC는 Heap영역을 Region이라는 단위로 나누어 관리합니다(체스 같이 분할).<br>
이때 Region에 Eden,survivor,old 등의 역할을 동적으로 부여하게 되며, 가비지가 많은 영역부터 우선적으로 처리한다는 특징이 있습니다.<br>
이 외에도 ZGC및 Shenandoah(쉐난도) GC가 있으며, 이 둘은 최신 가비지 컬렉터로 애플리케이션의 중단 시간을 극소화할려는 것이 특징입니다.<br>
<br>
꼬리질문 - 왜 G1 GC는 Stop-the-world 시간이 짧냐??<br>
G1 GC는 메모리를 여러 영역으로 분할하고 각 영역을 독립적으로 관리함으로써 전체 힙을 한 번에 처리하는 대신 일부 영역만을 대상으로 가비지 컬렉션을 수행합니다. 그리고 가비지가 가장 많이 축적된 영역부터 우선적으로 처리함으로써 효율적인 가비지 컬렉션을 수행하며, 이로 인해 Stop-the-world 시간이 짧아집니다.<br>
<br>
꼬리질문 - 왜 CMS는 메모리 단편화 문제가 발생하는지 상세히 설명해주세요<br>
CMS 가비지 컬렉터는 Mark and sweep이라는 알고리즘을 사용하며, 이 알고리즘은 메모리에서 사용되지 않는 객체를 찾아내고 해당 메모리 공간을 해제하는 방식입니다.<br>
하지만 이 과정에서 각기 다른 크기와 위치에 있는 객체들이 해제되면서 메모리 공간이 불 연속적으로 바뀌게 됩니다.<br>
이렇게 나눠진 메모리 공간들은 특정 크기의 객체를 저장하기에 충분하지 않을 수 있습니다.<br>
예를들어 여러 개의 작은 메모리 공간이 있지만 그 공간들이 각각 딸떨어져있다면, 이 공간들을 합치지 않고는 저장할 수 없게 됩니다.<br>
이렇게 메모리가 단편화되면 메모리의 활용도가 떨어지고, 결국 충분한 메모리가 있음에도 Out Of Memory를 발생시킬 수 있습니다.<br>
이러한 문제를 해결하기 위해 일부 가비지 컬렉션 알고리즘은 Compaction과정을 포함합니다.<br>
이 과정에서 가비지 컬렉터는 메모리에 남아있는 객체들을 한쪽으로 몰아서 메모리를 연속적으로 만듭니다.<br>
하지만 이 과정은 추가적인 시간이 소요되며, Stop-the-world 시간을 늘릴수있습니다.<br>
요약하자면 CMS는 Compaction 과정을 포함하지 않기에 메모리 단편화 문제에 노출되어 있습니다.<br>
</details>

<details markdown = "1">
<summary>가비지 컬렉터의 작동의 문제를 진단하는 방법과 해결하는 방법은 무엇이 있을까요??</summary>
만약 두 Survivor 영역 모두에 데이터가 존재하거나, 두 영역 모두 사용량이 0 이라면 시스템이 정상적인 상황이 아니라고 판단할 수 있습니다.<br>
또한 GC에 대한 로그를 확인하여 문제를 진단 할 수 있습니다.<br>
문제를 해결하는 방법에는 힙 사이즈를 조정하는 방법이 있습니다.<br>
JVM의 힙 사이즈가 너무 작으면, GC가 자주 발생하여 성능이 저하될수있고, 반대로 힙 사이즈가 너무 크면 GC의 시간이 길어져 애플리케이션의 응답 시간이 길어질수 있습니다.<br>
따라서 애플리케이션의 요구사항이나 성능 목표에 따라 힙 사이즈를 적절히 조정하는 것이 중요합니다.<br>
또한 JVM은 여러 가지 종류의 가비지 컬렉터를 제공합니다. 이러한 가비지 컬렉터는 각 상황에 최적화 되어있기에 요구사항에 따라 적절한 가비지 컬렉터를 선택하여 문제를 해결할 수 있을 것 같습니다.<br> 
</details>

<details markdown = "1">
<summary>가비지 컬렉터에 의한 시스템 중단 시간을 어떻게 줄일까요??</summary>
우선 애플리케이션의 요구사항과 가장 잘 맞는 가비지 컬렉터를 선택함으로서 시스템 중단 시간을 줄일 수 있습니다.<br>
또한 적절한 힙 크기를 선택하는 것 또한 시스템 중단 시간을 줄일 수 있습니다. 예를들어 힙의 크기를 높이면 GC의 빈도는 줄어들겠지만 실행 시간이 길어질수 있습니다.<br>
따라서 애플리케이션의 메모리 사용 패턴을 이해하여 적절한 힙 크기를 선택한다면 시스템 중단 시간을 줄일 수있습니다.<br>
그리고 가비지 컬렉션 작업과 애플리케이션 작업을 병렬로 실행하도록 설정하면 시스템 중단시간을 줄일 수 있습니다.<br>
또한 개발자입장에서는 불필요한 객체 생성을 막고, 불변 객체(final 키워드로 생성, 내부 상태가 변하지 않음, Thread Safe)를 사용하여 시스템 중단 시간을 줄일수 있습니다.<br>
불변 객체를 활용하면 가비지 컬렉터가 스캔해야 되는 객체 수가 줄어서 스캔해야 하는 메모리 영역이 줄어들기 떄문입니다.<br>
<br>
참고 - 불변객체 생성 방법 : 클래스를 final로, 모든 클래스 변수을 private final 으로 선언하기<br>
</details>

<details markdown = "1">
<summary>Stream API에 대해 간략히 설명해주세요.</summary>
Stream은 자파8에서 추가된 API로, 자바에서의 일련의 데이터 요소인 배열이나 컬렉션 등의 데이터를 처리하기 위한 기술입니다.<br>
작업을 내부 반복(반복문을 메서드 안으로 숨김)으로 처리하기에 불필요한 코딩을 줄일 수 있고, 원본 데이터로부터 데이터를 읽기만 할뿐, 원본 데이터 자체를 변경하지 않습니다.<br>
연산의 구조는 Stream 생성, 중간연산(sort,distinct 등), 최종연산(forEach, Collect 등)순으로 이어집니다.<br>
중간연산은 데이터를 가공하는 과정이고, 최종 연산은 Stream안의 데이터를 모아서 반환하는 역할을 합니다.<br>
<br>
참고 - 중간 연산 작업은 바로 실행되는 것이 아니라, 종결 처리 실행이 필요할때 중간 처리가 실행됨<br>
참고 - 스트림은 1회용, 멀티 스레드를 활용해서 병렬로 연산을 수행할 수 있고<br>
Collection은 외부 반복, Stream은 내부 반복.<br>
성능면에서는 내부 반복이 비교족 좋다. 내부반복은 작업을 병렬 처리하면서 최적화된 순서로 처리해주는 반면, 외부 반복은 명시적으로 컬렉션 항목을 하나씩 가져와야 해서 최적화에 불리<br>
즉 Collection에서 병렬성을 이용하려면 직접 synchronized를 통해 관리해야 함<br>
</details>

<details markdown = "1">
<summary>리플렉션이 무엇인가요??</summary>
리플렉션은 런타임 시에 클래스, 메서드, 필드 등의 정보를 조회하거나 조작할 수 있는 기술입니다.<br>
이를 통해 런타임에 동적으로 클래스의 객체를 생성하거나, 메서드를 호출하고, 필드 값을 얻거나 설정하는 것이 가능합니다.<br>
특히, 컴파일 시점에 타입 정보가 결정되지 않고 런타임 시에 동적으로 결정해야 하는 경우에 유용하게 사용됩니다. 그러나 런타임에만 오류를 발견할 수 있기 때문에 주의가 필요합니다.<<br>
<br>
<br>
예시 -Class<?> stringClass = Class.forName("java.lang.String");<br>
    Method[] methods = stringClass.getMethods();<br>
<br>
런타임 시점에 다른 클래스를 동적으로 로딩하여 접근할 때 사용<br>
클래스와 멤버 필드, 메서드 등에 관한 정보를 얻어야 할 때 사용<br>
</details>

<details markdown = "1">
<summary>업캐스팅과 다운 캐스팅에 대해 설명해주세요.</summary>
업캐스팅은 하위 클래스의 객체가 부모 클래스로 형변환 되는 것을 말합니다. 근데 업캐스팅하게 되면 하위 클래스의 메서드를 사용할 수 없기 때문
</details>

<details markdown = "1">
<summary>blocking과 non-blocking의 차이</summary>
두 가지의 차이점은 다른 주체가 작업을 할때 자신이 코드를 실행할 제어권이 있는지 없는지로 판단할 수 있습니다.<br>
Blocking은 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 제어권을 다른 주체로 넘깁니다. 따라서 자신은 제어권이 없기에 실행할 수 없고, 다른 주체가 실행을 완료하고 제어권을 돌려줄때까지 아무 작업도 할 수 없습니다.<br>
Non-Blocking은 다른 주체의 작업에 관련없이 자신이 제어권을 가지고 있습니다.<br>
</details>

<details markdown = "1">
<summary>자바의 Fork-Join Pool이 무엇인지 설명해주세요.</summary>
Fork Join Pool은 자바 7에서 도입된 병렬 처리를 위한 프레임워크로, Task를 분할하여 작은 서브 태스크로 나눈 후, 서브 태스크를 병렬로 처리하고, 그 결과를 다시 취합하는 형태의 스레드 풀입니다.<br>
Fork Join pool 내부에는 큐가 하나 존재하는데, 여기에 각 Task가 저장되고, 각 쓰레드가 Task를 가져가서 처리합니다.<br>
만약 어떤 쓰레드의 큐가 비어있다면 다른 쓰레드의 큐에서 작업을 가져와 처리하게 되며 이를 stealing이라고 합니다.<br>
(최대한 놀고 있는 Thread를 줄이는 방법으로 설계된것)<br>
</details>

<details markdown="1">
<summary>동기(Sync)와 비동기(Async)의 차이에 대해 설명해주세요.</summary>
동기 방식은 한 작업이 완료될 때까지 다음 작업이 기다려야 합니다. 즉, 하나의 작업이 끝나야 다음 작업을 시작할 수 있습니다.<br>
비동기 방식은 하나의 작업이 완료되지 않아도 다음 작업을 시작할 수 있습니다.<br>
<br><br><br>
서버에 데이터를 요청한 후 응답을 받아야만 그 다음 작업을 수행하는 경우, 이는 동기적으로 작동한다고 볼 수 있습니다.<br>
서버에 데이터를 요청한 후 응답을 기다리는 동안 다른 작업을 계속 수행하는 경우, 이는 비동기적으로 작동한다고 볼 수 있습니다.<br>
<br>
동기 방식은 순서대로 실행되므로 코드의 흐름을 이해하기 쉽지만, 특정 작업에서 지연이 발생하면 전체 시스템의 효율이 떨어질 수 있습니다.<br>
반면, 비동기 방식은 여러 작업이 병렬적으로 실행될 수 있어 효율적이지만, 코드의 흐름이나 상태 관리가 복잡해질 수 있습니다.<br>
</details>

<details markdown="1">
<summary>자바에서 쓰레드를 생성 및 실행하는 방법에 대해 설명해주세요.</summary>
자바에서는 쓰레드를 생성하고 실행하기 위해 주로 두 가지 방법을 사용합니다<br>
Thread 클래스를 상속받아 run 메서드를 오버라이드합니다. 이후 해당 클래스의 객체를 생성하고 start() 메서드를 호출하여 쓰레드를 실행합니다<br>
Runnable 인터페이스를 구현하고 run 메서드를 오버라이드합니다. 그리고 해당 구현체를 Thread의 생성자에 전달하고, Thread 객체의 start() 메서드를 호출하여 쓰레드를 실행합니다.<br>
</details>

<details markdown="1">
<summary>자바에서 멀티스레드 프로그래밍을 하는 방법에 대해 설명해주세요.</summary>
자바의 ExecutorService는 쓰레드 관리 및 병렬 처리를 지원해주는 인터페이스입니다.(쓰레드 라이프 사이클 관리)<br>
ExecutorService는 다양한 종류의 쓰레드 풀을 생성할 수 있는 Executors라는 유틸리티 클래스를 제공합니다.<br>
쓰레드풀 생성 이후에는 ExecutorService의 Submit() 메서드를 통해 작업을 제출하면 Future 객체를 통해 비동기 결과를 얻을 수 있습니다.<br>
<br><br>
멀티 쓰레드 프로그래밍 관련 용어<br><br>
Future : 비동기 연산 결과를 나타내는 객체<br>
Callable : 결과를 반환하는 작업을 정의하는데 사용되는 함수형 인터페이스<br>
CountDownLatch : 여러 쓰레드가 특정 지점까지 도달할때 까지 대기하게 하는 동기화 도구<br>
Semaphore : 동시에 리소스에 접근할 수 있는 쓰레드의 수를 제한하는 동기화 도구<br>
ExecutorService: 쓰레드의 생성, 관리 및 실행을 관리하는 고수준 인터페이스.<br>
Executors: 다양한 유형의 쓰레드 풀을 생성하는 유틸리티 클래스.<br>
</details>

<details markdown="1">
<summary>자바에서 동시성 문제를 해결하는 방법들에 대해 설명해주세요.</summary>
synchronized 키워드는 메서드나 블록에 사용되고, 해당 부분의 동시 접근을 막아 동기화를 수행합니다.<br>
한 시점에 오직 하나의 쓰레드만이 synchronized로 보호된 영역에 접근할 수 있습니다. 이로 인해 비용이 크고 성능에 영향을 줄 수 있습니다.<br>
<br>
volatile 키워드가 붙은 변수는 해당 변수의 모든 연산이 메인 메모리에서 직접 이루어집니다. 이는 CPU 캐시 메모리의 일관성 문제를 해결하며, 변수의 가시성을 보장합니다<br>
일반적으로 하나의 쓰레드만이 write 작업을 수행하며, 나머지 스레드는 read 작업만 수행합니다.<br>
그러나, 여러 스레드가 동시에 Main Memory에 접근하게 되면, 쓰레드 간의 동시 접근 문제가 발생할 수 있습니다. 따라서 volatile은 변수의 가시성 문제는 해결할 수 있으나, 동시 접근 문제를 완전히 해결하지는 못합니다.<br>
<br>
Atomic 클래스는 CAS(compare and swap)을 이용하여 동시성을 제어하므로, 여러 쓰레드에서 데이터를 write해도 문제가 없습니다.<br>
synchornized 보다 적은 비용으로 동시성을 보장할 수 있는 것이 특징입니다.<br>
<br><br>
꼬리질문 1 - CAS가 뭐죠?<br>
CAS 알고리즘이란 현재 스레드가 존재하는 CPU의 CacheMemory와 MainMemory에 저장된 값을 비교하여, 일치하는 경우 새로운 값으로 교체하고, 일치하지 않을 경우 기존 교체가 실패되고, 이에 대해 계속 재시도하는 방식입니다<br>
CPU가 MainMemory의 자원을 CPU Cache Memory로 가져와 연산을 수행하는 동안 다른 스레드에서 연산이 수행되어 MainMemory의 자원 값이 바뀌었을 경우 기존 연산을 실패처리하고, 새로 바뀐 MainMemory 값으로 재수행하는 방식입니다.<br>
<br><br>
꼬리질문 2 - 가시성 문제와 동시 접근 문제에 대해 설명해주세요.<br>
가시성 문제는 하나의 스레드에서 변수를 변경했을때, 다른 스레드에서 그 변경을 즉시 확인하지 못하는 상황을 의미합니다.<br>
이는 주로 CPU의 캐시 메모리 떄문에 발생합니다. 한쓰레드가 변수를 변경하면 그 변경이 즉시 메인 메모리에 반영되지 않고, 해당 스레드의 로컬 캐시에만 저장될 수 있습니다.<br>
따라서 다른 스레드는 자신의 로컬 캐시에 있는 이전 값으로 작업을 계속사용하게됩니다.<br>
이러한 문제를 해결하기 위해 volatile을 사용합니다. 이를 통해 변수의 변경이 즉시 메인 메모리에 반영되고, 다른 스레드는 그 변수를 읽을때 항상 메인 메모리의 최신값을 읽게 됩니다.<br><br>
동시 접근 문제는 두개의 이상의 스레드가 동시에 공유 자원 변경하려할때 발생합니다.<br>
예를 들면, 두 스레드가 동시에 은행 계좌의 잔액을 변경하려고 하면, 최종 결과는 예측하기 어려울 수 있습니다. 이 문제를 'race condition'이라고도 합니다<br>
synchronized 키워드나 Lock 인터페이스는 이러한 동시 접근 문제를 해결하기 위해 사용됩니다. 이들은 한 번에 하나의 스레드만 공유 자원에 접근하도록 제한하여 동시성 문제를 방지합니다<br>
<br>
참고<br><br>
자바의 메모리 구조는 이럼 -> CPU가 작업을 처리 하기 위해, 필요한 데이터를 RAM에서 읽어 캐시 메모리에 복제함<br>
작업을 처리한 뒤, 변경된 CPU 캐시 메모리 데이터를 RAM에 덮어씌움(RAM 쓰기 작업)<br>
CPU가 여러개일 경우, 각 CPU별 캐시 메모리에 저장된 데이터가 달라 문제가 발생할 수 있다.<br>
<br>
메인 메모리(RAM)는 프로그램이 실행될때 필요한 데이터와 명령어 일시 저장. CPU는 램에서 명령어와 데이터 읽어와서 처리. 상대적으로 느리지만 큰 용량<br>
CPU 캐시 메모리는 CPU 내부의 작은 용량의 빠른 메모리, CPU가 자주 접근하는 데이터나 명령어 저장.<br>
CPU는 먼저 캐시 메모리에서 필요한 데이터나 명령어 찾음. 만약 캐시에 필요한 데이터/명령어가 없는 경우(캐시 미스), 메인 메모리에서 해당 정보를 찾아와 캐시에 저장하고 사용.<br>
<br>
예시<br>
여러 스레드가 동시에 실행되면서 메인 메모리와 CPU 캐시 사이에서 일관성 문제가 발생할 수 있습니다. 예를 들어, 한 스레드가 CPU 캐시의 데이터를 수정했지만, 이 변경 사항이 즉시 메인 메모리에 반영되지 않는 경우, 다른 스레드가 오래된 메인 메모리의 데이터를 읽게 될 수 있습니다. 이로 인해 데이터의 불일치 문제가 발생합니다.<br>
<br>
[synchronized 동기화](https://backtony.github.io/java/2022-05-04-java-50/)
</details>

### DataStructure

<details markdown = "1">
<summary>자료구조와 알고리즘에 대해 설명해주세요</summary>
자료구조는 데이터를 원하는 규칙 또는 목적에 맞게 저장하기 위한 구조이고<br>
알고리즘이란 자료구조에 쌓인 데이터를 활용해 어떠한 문제를 해결하기 위한 여러 동작들의 모임을 의미합니다.<br>
</details>

<details markdown = "1">
<summary>Java Collection Framework란 무엇인가요?</summary>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/46cd973e-01d2-47ca-9e69-266018f5df97">
컬렉션 프레임워크란 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스들의 집합을 의미합니다.<br>
이러한 컬렉션 프레임워크는 Collection 인터페이스와 Map인터페이스로 나뉘며, Collection 인터페이스 하위에는 List,Queue,Set 인터페이스가 있습니다.<br>
<br>
참고 - 객체만 담을 수 있고, 이는 객체의 주소를 담는 것이기에 null도 저장 가능<br>
</details>

<details markdown = "1">
<summary>배열과 ArrayList가 무엇인지</summary>
배열이란 동일한 데이터 타입의 값들을 연속된 메모리 공간에 저장하는 자료구조이며, 크기를 동적으로 변경할 수 없습니다.<br>
이러한 배열의 요소는 메모리에 연속적으로 저장되며, 각 요소는 고유한 인덱스를 가지므로 Random Access가 가능합니다.(물리적 저장순서와 논리적 저장순서가 일치하기에 인덱스 통해 빠르게 접근)<br>
배열은 데이터 개수가 정해져있고, 접근이 빈번할 경우 사용하기 좋은 자료구조이나, 중간에 요소가 삽입되거나 삭제되는 경우엔 적합하지 않는 자료구조입니다.<br>
또한 배열은 공간 지역성이 보장되어 요소 접근 시 Cache hit 가능성이 커 캐시의 효율성을 높일 수 있습니다.<br>
<br><br>
ArrayList는 동일한 데이터 타입의 값들을 연속된 메모리 공간에 저장하며, 크기를 동적으로 변경할 수 있는 자료구조입니다.(요소 추가 시 동적으로 크기 증가)<br>
ArrayList는 내부적으로 데이터를 (Object[])배열에 저장하고 있어, 각 요소가 인덱스를 가지고 있고, 이를 바탕으로 Random Access가 가능합니다.<br>
ArrayList는 데이터 개수가 정해져 있지 않고, 접근이 빈번할 경우 사용하기 좋은 자료구조입니다.<br>
이 또한 공간지역성이 보장되어 요소 접근 시 Cache hit 가능성이 커 캐시의 효율성을 높일 수 있습니다.<br>
<br><br>
참고<br>
Random Access란 데이터의 특정 위치에 직접 접근할 수 있는 것을 의미, 메모리 상 시작 주소 + (인덱스 x 데이터 타입 크기(참조형 변수 크기 4byte))를 통해 해당 인덱스 빠르게 접근 가능<br>
공간지역성이란, 관련된 데이터들이 연속적인 메모리 주소에 위치하면 그 데이터를 빠르게 읽거나 쓸수 있다.<br>
캐시 히트는 필요한 데이터가 캐시에 있다면 캐시에서 빠르게 데이터를 가져오는 것을 의미, 캐시 히트 가능성이 높다는 것은 캐시에서 이 데이터를 찾을 확률이 높다는 것<br>
<br>
배열의 시간복잡도<br>
접근(O(1)) : 배열의 특정 인덱스에 위치한 요소에 바로 접근 가능<br>
삽입(O(n)) : 중간에 요소를 삽입하려면 이후의 모든 요소를 하나씩 밀어야 함<br>
삭제(O(n)) : 중간의 요소를 삭제하려면 이후의 모든 요소를 하나씩 당겨야 합니다.<br>
검색(O(n)) : 특정 요소를 찾기 위해서는 순차적으로 검색을 해야 함<br>
<br>
ArrayList도 접근은 O(1), 삽입의 경우 빈자리가 있을때 맨 끝에 추가한다면 O(1)<br>
내부가 꽉찼을때 끝에 추가할때는 O(N), 중간의 경우 당연히 O(N)<br>
삭제의 경우 삭제 뒤에 애들을 앞으로 떙겨야 하기에 O(n), 근데 마지막 값을 지운다면 O(1)일듯<br>
<br>
차이를 물어보면 배열의 경우 한번 생성되면 크기를 변경할 수 없는 반면, ArrayList는 동적으로 크기가 조절됨. 요소를 추가하거나 제거할때 자동으로 크기가 변경됨<br>
</details>

<details markdown = "1">
<summary>캐시의 효율성에 대해 설명해주세요.</summary>
CPU는 필요한 데이터를 RAM에서 가져올 수 있지만, 이렇게 직접 데이터를 읽는 것은 상대적으로 느립니다.<br>
이를 위해 훨씬 빠른 속도를 가진 메모리인 캐시를 사용하며, 필요한 데이터가 캐시에 있다면 캐시에서 빠르게 데이터를 가져올 수 있는데 이를 캐시히트가 발생되었다고 합니다.<br>
하지만 캐시의 크기는 매우 작기에, 모든 데이터를 저장할 수 없고, CPU는 어떤 데이터를 캐시에 저장할지 결정하는데 이때 중요한 원칙이 공간지역성입니다.<br>
이는 메모리에 인접한 위치에 있는 데이터는 함께 사용될 가능성이 높다는 원리인데, 배열의 경우 모든 요소가 메모리 상 연속적으로 위치해있습니다.<br>
따라서 한번에 여러 요소를 캐시에 저장할 수 있고, 이후 배열에 접근할때 빠른 속도를 얻을 수 있습니다.<br>
요약하자면 배열의 요소들은 메모리상에 인접해 있기때문에, 한번에 여러 요소를 캐시에 저장할 수 있고, 그래서 CPU가 배열의 데이터에 빠르게 접근할 수 있습니다.<br>
<br><br><br>
참고 - 컴퓨터에서 데이터를 읽을때, 주소가 연속적인 메모리 위치에 있는 데이터를 읽는 것이 흩어진것 보다 효과적<br>
왜냐하면 컴퓨터는 메모리에서 블록 단위로 데이터를 읽음. 따라서 배열과 같이 데이터가 연속적인 메모리 위치에 있으면, 컴퓨터는 한번에 여러데이터 읽을 수 있따.<br>
이것이 한번에 여러 요소를 캐시에 저장할 수 있다는 의미.<br>
데이터가 메모리의 여러 위치에 있으면, 컴퓨터는 여러 블록을 읽어야 함(접근하는데 더 많은 시간이 듬)<br>
연관 데이터를 가능한 가까이 두는것이 캐시를 효율적으로 사용하고 성능을 높이는데 사용<br>
캐시 라인을 기반으로 읽어옴 예를들어 arr[0]이 캐시에 로드되면,arr[1],arr[2]등 같은 캐시라인에 있는 배열 요소도 같이 캐시에 로드됨<br>
즉 cpu가 램에서 데이터를 가져올때 캐시 라인 단위로 가져옴(일반적으로 64바이트)<br>
따라서 cpu가 arr[0]의 값을 가져올때 캐시는 arr[0]을 포함하는 메모리 블록을 가져오며 여기엔 arr[0]제외 인접 데이터들도 포함됨<br>
따라서 arr[1],arr[2]는 캐시에 저장되고 나중에 접근할때는 RAM에 접근할 필요 X<br>
</details>

<details markdown = "1">
<summary>LinkedList에 대해 아시는 대로 설명해주세요.</summary>
LinkedList란 각 노드가 데이터와 포인터를 가지고 연결되어 있는 방식으로 데이터를 저장하는 자료구조입니다.<br>
이러한 링크드 리스트의 종류로는 단방향, 양방향, 원형 링크드리스트들이 존재합니다.<br>
LinkedList의 각 요소는 메모리상에 불연속적으로 배치되어 있습니다.<br>
따라서 특정 인덱스 요소에 접근하려면 ArrayList와 다르게 순차적으로 하므로 접근에 최적화된 자료구조는 아닙니다<br>
하지만 삽입 삭제가 빈번하게 일어나는 경우에는 유용한 자료구조이며, CPU 스케쥴링이나 메모리 관리 등에서 사용되는<br>
큐나 스택등의 자료구조를 구현하는데 사용될 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>ArrayList와 LinkedList의 차이에 대해 설명해주세요.</summary>
ArrayList는 동적 배열의 형태를 가지고 있어, 데이터가 메모리 상에서 연속적으로 배치됩니다.<br>
이로 인해 인덱스를 통해 빠르게 요소에 접근하는 것이 가능합니다. 이를 'random access'라고 합니다.<br>
그러나 이런 특성 때문에 중간에 새로운 요소를 삽입하거나 기존 요소를 삭제할 때는 배열의 요소들을 이동시키는 추가적인 작업이 필요합니다<br>
.이는 비효율적일 수 있습니다. 또한, 배열이 꽉 차면 크기를 늘려야 하며 이 과정에서도 시간이 소요됩니다. 하지만 ArrayList의 공간 지역성이 보장되므로, 캐시 히트 가능성이 높아져서 캐시의 효율성이 좋습니다.<br>
<br>
반면, LinkedList는 연결 리스트의 형태를 가지며, 각 요소가 메모리 상에서 불연속적으로 배치됩니다.<br>
이로 인해 인덱스를 통한 빠른 접근이 어렵습니다. 대신, LinkedList는 노드의 연결 정보만 변경함으로써 요소의 삽입과 삭제를 매우 효율적으로 수행할 수 있습니다.<br>
특히, 리스트의 시작 부분(head)나 끝 부분(tail)에서의 삽입 및 삭제는 매우 빠릅니다.<br>
그러나 LinkedList는 공간 지역성이 보장되지 않아 캐시 히트 가능성이 낮으며, 이로 인해 캐시의 효율성이 상대적으로 떨어집니다.<br>
<br>
요약하자면, 요소의 접근이 주로 이루어지는 경우에는 ArrayList를, 요소의 삽입과 삭제가 빈번하게 이루어지는 경우에는 LinkedList를 사용하는 것이 더 효율적일 수 있습니다."<br>
<br>
참고 - ArrayList 값 연속정 저장 : Random Access, LinkedList는 값이 산재되어 저장되어 있음<br>
첫번째 위치에 insert/remove DoublyLinkedList의 경우 O(1), ArrayList의 경우 O(N)<br>
마지막 위치에 insert/remove DoubleLinkedList의 경우 O(1), ArrayList의 경우 O(1) or O(N)<br>
중간에 insert/remove Doubly : O(N) or searchtime + O(1), ArrayList : O(N)<br>
값으로 search는 둘다 O(N)이지만 ArrayList가 나음<br>
인덱스로 값을 get, LinkedList의 경우 O(N), ArrayList의 경우 O(1)<br>
값으로 remove 시 둘다 O(N)<br>
</details>

<details markdown = "1">
<summary>왜 ArrayList의 캐시 효율성이 더 좋은지 가능한 상세히 설명해주세요</summary>
공간 지역성(spatial Locality)는 컴퓨터 프로그램에서 사용하는 데이터가 메모리의 특정 구간에 집중되어 있는 경향을 말합니다.<br>
즉, 한번 참조된 데이터 근처의 데이터가 곧 이어서 참조될 가능성이 높다는 의미이며, 이는 CPU 캐시의 설계와 밀접한 관계가 있습니다.<br>
CPU 캐시는 주기억장치(RAM)에 비해 매우 빠른 속도를 가지지만 그만큼 용량이 작아서 전체 메모리를 저장할 순 없습니다.<br>
따라서 CPU는 프로그램이 주로 참조하는 데이터를 캐시에 저장합니다. 이때 공간지역성이 있다면 한번 참조된 데이터 주변의 데이터가<br>
곧 이어서 참조될 가능성이 높으므로 이러한 데이터를 캐시에 미리 가져와 놓으면 메모리 접근 시간을 줄일 수 있습니다.<br>
ArrayList는 메모리 상에서 연속적인 데이터를 저장하는 구조를 가지고 있습니다. 따라서 한 데이터가 CPU 캐시에 로드되면 그 근처의 데이터도 함께 로드되게 됩니다.<br>
이후 이 근처의 데이터에 접근하게 되면, 이미 캐시에 데이터가 존재하므로 캐시 히트가 발생하고, 메모리 접근 시간이 크게 줄어듭니다.<br>
반면 LinkedList는 노드들이 메모리의 여기저기에 분산되어 저장됩니다.<br>
각 노드는 자신의 다음 노드에 대한 참조만을 가지고 있으며, 이 참조는 메모리상의 아무 곳에나 위치할 수 있습니다.<br>
따라서 한 노드를 참조했다고 해서 그 근처의 노드가 곧바로 참조될 확률이 낮습니다. 이것이 LinkedList에서 공간지역성이 보장되지 않는 이유입니다.<br>
이로 인해 LinkedList를 사용할때는 캐시 히트 가능성이 상대적으로 낮아지고, 이에 따라 캐시의 효율성이 떨어집니다.<br>
</details>

<details markdown = "1">
<summary>Array와 LinkedList의 차이점에 대해 설명해주세요</summary>
이둘의 주요 차이점은 데이터가 메모리에 저장되는 방식과 각 요소에 대한 접근 방식에 있습니다<br>
배열은 'Random Access'를 지원합니다. 이는 배열의 요소들이 메모리 상에서 연속적으로 위치하기 때문에 가능한 것입니다<br>
따라서, 인덱스를 통해 배열의 특정 요소에 직접 접근할 수 있으며, 이러한 접근은 일정한 시간복잡도인 O(1)를 가집니다<br>
반면에 LinkedList는 'Sequential Access'를 지원합니다. LinkedList의 요소들은 메모리 상의 임의의 위치에 있으며, 각 요소(노드)는 다음 요소를 가리키는 링크를 가지고 있습니다<br>
이 링크를 따라가면서 요소에 접근해야 하기 때문에, 특정 요소에 접근하는 데는 시간복잡도 O(N)이 소요됩니다<br>
배열에서 요소의 삽입 또는 삭제는 복잡한 작업입니다. 배열은 고정된 크기를 가지므로, 삽입 또는 삭제를 위해서는 배열의 크기를 조정하거나, 요소들을 재배치해야 합니다. <br>
이러한 작업은 시간복잡도 O(N)이 소요됩니다.<br>
반면에 LinkedList에서는 삽입 및 삭제 작업이 상대적으로 간단합니다. 특정 위치에 삽입 또는 삭제를 위해서는 단지 몇 개의 링크를 조정하면 되므로, 이 작업은 일반적으로 시간복잡도 O(1)을 가집니다.<br>
배열은 '정적 메모리 할당'을 사용합니다. 즉, 배열이 생성될 때 그 크기가 고정되며, 메모리 상에 연속적으로 할당됩니다. 따라서, 배열의 크기는 변경할 수 없습니다.<br>
반면에 LinkedList는 '동적 메모리 할당'을 사용합니다. LinkedList의 요소(노드)는 필요에 따라 생성되고, 각 노드는 메모리 상의 임의의 위치에 할당됩니다. 이러한 특성 덕분에 LinkedList는 필요에 따라 크기를 동적으로 변경할 수 있습니다."<br>
<br>
참고 -  배열은 스택 영역에 할당되고, LinkedList는 힙 영역에 할당되는 것이 일반적입니다.
</details>

<details markdown = "1">
<summary>스택과 큐의 차이점에 대해 설명해주세요</summary>
스택은 세로로된 바구니와 같은 구조로, 자료가 쌓이는 구조를 가지고 있습니다.<br>
이것은 Last in First out 특성을 가지고 있어, 가장 나중에 넣은 데이터를 가장 먼저 꺼내게 됩니다.<br>
큐는 가로로된 통과 같은 구조로, 데이터가 한쪽 방향으로만 흐르는 구조를 가지고 있습니다.<br>
이는 First in First Out 특성을 가지고 있어, 가장 먼저 넣은 데이터를 가장 먼저 꺼냅니다.<br>
<br><br>
참고 - LinkedList는 노드를 앞이나 뒤에 추가시 제거하는 시간이 상수 시간에 가능<br>
이러한 스택은 배열로 구현하는 경우, 데이터를 제거할때 실제 데이터를 지울 필요가 없고, top 인덱스를 지우는 것만으로도<br>
데이터의 삽입과 삭제를 효과적으로 관리할 수 있습니다.<br>
이러한 큐는 배열로 구현하게 되면 데이터를 제거할때마다 남은 데이터를 앞으로 당겨야 하는 비효율성이 있습니다.<br>
따라서 LinkedList와 같이 삽입 삭제가 용이한 자료구조로 구현하는것이 일반적입니다.<br>
</details>

<details markdown = "1">
<summary>힙에 대해 아시는 대로 설명해주세요.</summary>
힙은 최솟값 또는 최대값을 빠르게 찾아내기 위해 완전 이진트리 형태로 만들어진 자료구조입니다.<br>
힙에는 최대힙과 최소힙 두가지 유형이있습니다.<br> 
최대힙에서는 부모의 노드값이 그 자식 노드값보다 항상 크거나 같습니다.<br>
그리고 최소힙에서는 부모의 노드 값이 그 자식 노드값 보다 항상 작거나 같습니다.
이러한 힙을 사용하면 데이터 최댓값 또는 최솟값을 상수시간에 찾아낼 수 있으며, 삽입과 삭제는 로그 시간에 할 수 있기에 효율적입니다.<br>
<br>
참고<br>
이진트리 - 모든 노드의 최대 차수를 2로 제한한것<br>
완전(complete) 이진트리 - 모든 노드의 최대 차수 2 제한 + 마지막 레벨을 제외한 모든 노드 채워져 + 모든 노드는 왼쪽부터 채워져야함<br>
포화이진트리(perfect binary tree) 이진트리 - 완전 이진 트리 조건 + 마지막 레벨을 제외한 모든 노드는 두개의 자식 노드를 가짐<br>
상수시간 - 데이터 크기와 무관하게 일정한 시간을 필요로 한다는 것<br>
예를들어 배열에서 특정 인덱스의 값을 읽는 작업은 배열의 크기와 상관없이 항상 동일한 시간이 소요됨<br>
보통 배열로 구현하는 것이 효율적<br>
</details>

<details markdown = "1">
<summary>왜 힙의 삽입,삭제 연산의 시간복잡도는 O(logN)인지 설명해주세요.</summary>
힙은 완전 이진 트리의 형태를 띄고있기에 노드의 수가 늘어남에 따라 트리의 높이는 logN에 비례합니다(각 레벨에서 노드의 수가 두배로 늘어나므로 log에 비례)<br>
힙에서 삽입 및 삭제 연산은 루트 노드에서 시작하여 leaf 노드까지의 경로를 따라 이루어집니다.<br>
이 때문에 이러한 연산들은 트리에 높이에 비례하는 시간이 걸리며 이로인해 삽입 삭제 연산은 O(logN)이됩니다.<br>
<br><br>
예를 들어 삽입 연산의 경우 새로운 요소는 처음에 트리의 가장 하위 레벨(leaf노드)에 추가되고,그 후 힙 속성을 유지하며 적절한 위치로 이동합니다.<br>
이러한 연산은 새 요소를 부모 노드와 비교하며 진행되므로, 트리의 높이만큼의 비교가 이루어집니다.<br>
힙에서 가장 크거나 작은 요소를 삭제하면 일반적으로 루트 노드가 삭제됩니다.<br>
이후 트리의 가장 하위 레벨에서 하나의 노드를 루트로 이동시키고, 이 노드를 자식과 비교하며 적절한 위치로 이동시킵니다.<br>
이러한 연산 또한 트리의 높이에 비례하는 시간이 걸립니다.<br>
</details>

<details markdown = "1">
<summary>우선순위큐가 무엇인지와 동작원리에 대해 설명해주세요.</summary>
우선 순위 큐란 각각의 요소들이 우선순위를 가지고 있고, 요소들의 대기열에서 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료구조입니다.<br>
우선순위 큐는 자료를 추가하는 작업과, 삭제하는 작업 모두 지원하며 데이터를 추가할때는 우선순위에 따라 적절한 위치에 삽입되며, 데이터를 제거할때는 항상 가장 높은 우선순위의 항목이 제거됩니다.<br>
이러한 우선순위큐를 구현하기 위해서 일반적으로 힙이라는 자료구조를 구현합니다.<br>
<br>
따라서 모든 정점은 자신의 자식 요소보다 우선순위가 높다는 성질과, 완전 이진 트리의 성질로 인해 삽입,삭제 시 O(logN)의 시간복잡도를 보입니다.<br>
또한 우선순위가 가장 높은 요소는 루트에 위치하므로, 이를 조회하는데에는 상수의 시간이 걸립니다.<br>
<br>
참고 - 힙은 형제노드와 대소 비교를 안함<br>
</details>

<details markdown = "1">
<summary>우선순위큐를 힙이 아닌 다른 자료구조로 구현한다면 어떻게 될까요?</summary>
힙이 아닌 배열 이나 연결리스트를 통해서도 구현할 수 있습니다.<br>
배열로 구현시, 배열의 새로운 요소를 추가하는 것은 O(1)의 시간복잡도를 가지며, 새 요소는 배열의 마지막에 추가됩니다.<br>
삭제시에는 가장 우선순위가 높은 요소를 찾아 삭제하는데 O(N)의 시간복잡도를 가집니다.(모든 요소 탐색)
조회 또한 가장 우선 순위가 높은 요소를 찾는데 O(N)의 시간복잡도를 가집니다.<br>
연결리스트로 구현시 삽입에 O(1)시간복잡도를 가집니다.(새 요소는 리스트의 시작 또는 끝에 삽입됨)<br>
삭제 시에는 O(N)이 걸립니다(전체 탐색)<br>
조회의 경우에도 O(N)의 시간복잡도를 가집니다.(전체 탐색)<br>
</details>

<details markdown = "1">
<summary>덱(deque)에 대해 설명해주세요</summary>
덱(Deque)은 "Double-Ended Queue"의 줄임말로, 앞과 뒤에서 데이터의 삽입과 삭제가 모두 가능한 자료구조입니다. 이 특성 때문에 덱은 큐(Queue)와 스택(Stack)의 연산을 모두 지원합니다. 덱은 유연성이 높아서 필요에 따라 스택처럼 Last-In-First-Out(LIFO) 방식으로 동작하게 할 수도 있고, 큐처럼 First-In-First-Out(FIFO) 방식으로 동작하게 할 수도 있습니다.
</details>

<details markdown = "1">
<summary>hash와 hash Function이 무엇인지 설명해주세요</summary>
Hash란 일반적으로 key가 Hash Function을 통과하여 암호화되어 나온 결과물을 의미하고, Hash Function은 임의의 길이의 입력값을 고정된 길이의 암호화된 출력으로 변환해 주는 함수를 뜻합니다.<br>
이러한 해시 함수는 어떤 입력 값에도 항상 고정된 길이의 해시값을 출력하고, 입력 값이 아주 일부만 변경되어도 전혀 다른 결과값을 출력하는 특징을 가집니다.(즉 출력물로 유추 불가)<br>
<br><br>
참고 - 왜 사용할까??<br>
해시 함수를 사용하면 원하는 데이터를 찾는데 필요한 시간을 줄일 수 있습니다.<br>
예를들어 배열에서 특정 값을 찾으려면 보통 원하는 값을 찾을때 까지 배열의 모든 요소를 탐색해야 하므로 시간이 오래걸릴 수 있습니다.<br>
하지만 해시 테이블을 사용한다고 하면, 특정 키의 해시 값을 계산하여 바로 해당 위치에 접근할 수 있으므로, 상대적으로 빠른 시간안에 원하는 값을 찾을 수 있습니다.<br>
<br>
또한 해시 함수는 단방향성을 가지므로, 해시 값을 통해 유추가 어려워 데이터의 보안성 또한 높일 수 있다.<br>
<br><br>
Constant Time Complexity: 해시 테이블에서 데이터의 조회, 삽입, 삭제 연산은 일반적으로 평균 시간 복잡도가 O(1)입니다. 즉, 데이터의 양에 관계없이 거의 일정한 시간이 걸립니다.
Direct Access: 해시 함수의 결과값은 배열의 인덱스처럼 사용됩니다. 이 인덱스를 사용해서 직접 해당 위치에 접근할 수 있기 때문에 데이터를 빠르게 찾을 수 있습니다.
</details>

<details markdown = "1">
<summary>해시 충돌이 무엇인지 혹시 아시나요?</summary>
해시 충돌이란 입력한 키 값이 다름에도 불구하고, 같은 해시값이 나오는 경우를 의미합니다.
</details>

<details markdown = "1">
<summary>이러한 해시 충돌은 불가피한것인가요??</summary>
일반적으로 해시 충돌은 불가피한 현상입니다. 저는 이 이유를 비둘기집 원리와 함께 설명드리고자 합니다.<br>
비들기집 원리는 간단히 말해서, 만약 n개의 비둘기집에 n+1마리의 비둘기가 있다면, 적어도 하나의 비둘기 집에는 두마리 이상의 비둘기가 있다는 원리입니다.<br>
해시함수의 경우, 일정한 크기의 해시 테이블에 많은 입력을 매핑해야 하는 상황에서 이 원리가 적용됩니다.<br>
즉, 한정된 수의 버킷에 무한히 많은 키를 매핑해야하는데, 이 경우엔 어떤 해시 함수를 사용하더라도 충돌은 불가피 합니다.<br>
물론, 실제로는 무한히 많은 키를 다루는 것은 아니지만, 주어진 입력 데이터의 가능한 모든 조합이 해시 테이블의 슬롯 수보다 많을 가능성이 높습니다.<br>
예를들어 문자열을 키로 사용한다고 가정해 보겠습니다. 문자열은 알파벳,숫자,특수 문자등 다양한 문자의 조합으로 이루어질 수 있고, 그 길이에도 제한이 없습니다.<br>
이렇게 가능한 조합이 거의 무한대에 가까운 데이터를 키로 사용할때, 이를 저장하기 위한 해시 테이블의 크기를 그만큼 무한대에 가까운크기로 만들 수 없습니다.<br>
따라서 해시 함수와 해시 테이블의 설계 과정에서 충돌을 최소화하는 것이 중요하며, 이를 효과적으로 처리하는 방법을 갖추는 것이 중요합니다.<br>
</details>

<details markdown = "1">
<summary>해시 충돌을 해결하는 방법에 대해 가능한 상세히 설명해주세요.</summary>
해시 충돌(안 일어난다면 탐색,삽입,삭제 연산이 모두 O(1))을 해결하는 대표적인 방법에는 개방 주소법(Open Addressing)과 분리 연결법이 있습니다.<br>
개방 주소법은 한 버킷에 오직 하나의 엔트리만 저장되는 방식으로, 충돌 발생 시 다른 버킷에 데이터를 저장합니다..<br>
충돌이 발생한 경우 probing을 바탕으로 다음 슬롯을 찾아가는데, 이러한 probing 방법에는 선형 탐사법, 제곱 탐사법, 이중 해싱 등이 있습니다.<br>
<br>
분리 연결법(Seperate Chaining)은 개방 주소법과 달리 한 버킷 당 들어갈 수 있는 엔트리 수에 제한을 두지 않는 방식입니다.<br>
이는 해시 충돌이 일어난 경우 해당 버킷에 연결된 리스트에 데이터를 추가합니다.<br>
하지만 개방 주소법에 비해 추가적인 메모리 공간(다음 노드를 가리키는 포인터 공간)이 필요합니다.<br>
<br>
지금까지 설명드린 두가지 방법외에도, (해시 테이블의 Load Factor가 높은 경우엔) 크기가 더 큰 새로운 테이블을 만들어 기존 데이터를 옮겨 사용하거나<br>
체이닝 방법을 통해 연결리스트가 너무 길어졌다면, 재해싱을 통해서 너무 길어진 리스트의 길이를 나누어 다시 저장하는 방법도 있습니다.<br>
<br><br>
데이터가 적은 경우엔 일반적으로 개방 주소법이 더 빠릅니다.(충돌이 발생해도 추가적인 메모리 공간 없이 원래 해시테이블 내에서 충돌을 해결하기에)<br>
<br>
부가 내용들<br>
선형 탐사법 : 해시 충돌이 일어난 경우, 해시값에서 고정된 폭만큼 옮겨 다음 빈칸을 찾는 방법<br>
-> 간단하지만 테이블의 연속된 공간에 데이터가 몰리고, 같은 해시값이 나올수록 탐색 효율이 계속 나빠짐.(해시 충돌이 해시 값 전체에 균등한 경우 유용)<br>
<br>
제곱 탐사법 : 탐사폭이 제곱으로 늘어남.(ex: 2의 1제곱, 2제곱 ~~~~)<br>
데이터가 메모리 공간에 균등하게 분포되지 않고, 특정 제곱값에만 집중될 수 있음.(탐색의 연쇄적 충돌은 선형보단 덜함)<br>
<br>
이중 해싱(로드 팩터 높은 경우) : 충돌 시 항목을 저장할 다음 위치를 결정할때, 원래 해시 함수와 다른 별개의 해시 함수를 사용하는 방법<br>
이 방법은 이전 방법에 비해 균일하게 데이터를 분포시킬 수 있습니다.하지만 두번째 해시 함수를 통해 새로운 해시값을 생성해서 추가 연산을 요구하게 되며, 이를 바탕으로 탐색 경로를 설정하기에, 빈 슬롯을 찾기 위해 메모리 내 여러 위치를 불규칙하게 접근하게 됩니다.<br>
<br>
<br>
Load Factor(적재율)는 해시 테이블에서 현재 저장된 엔트리의 수와, 해시 테이블의 전체 버킷수의 비율을 나타냄(엔트리수 / 전체 버킷 수)<br>
load factor가 1에 가까워질수록 충돌 확률 증가, 로드 팩터가 높다면 보통 재해싱을 통해 더 큰 크기로 확장.(즉 새로운 버킷에 재배치)<br>
반면 너무 낮다면 메모리 사용이 비효율적일 수 있다.<br>
<br>
 해시 테이블의 기본 개념을 간단히 되짚어보면, 해시 테이블은 키를 입력으로 받아 해시 함수를 통해 해당 키에 대한 인덱스 값을 생성하고, 그 인덱스에 해당하는 위치에 값을 저장하는 자료구조<br>
<br>
체이닝으로 충돌을 해결하면, (리스트로 데이터가 저장되어있기에) 원하는 값을 찾기 위해 해당 인덱스(해시값)에 연결된 모든 키를 확인해야 될 수 있다.(탐색 및 삭제에 O(k : 키의 갯수))<br>
참고 - 충돌이 일어나지 않는다면, 즉 각각의 키가 유일한 해시값을 가진다면, 탐색+삽입+삭제는 O(1)<br>
참고 - 개방 주소법으로 해결하면 탐색 및 삭제의 시간 복잡도는 로드 팩터에 비례합니다.<br>
</details>

<details markdown = "1">
<summary>HashSet에 아시는 대로 설명해주세요.</summary>
HashSet은 Set인터페이스 구현체 중 하나입니다. HashSet은 중복된 요소를 허용하지 않는데, 이때 같음은 equals() 메서드와 HashCode() 메서드로 판단합니다.<br>
그리고 순서를 보장하지 않습니다.
이러한 HashSet은 내부적으로 HashMap을 사용하고, 각각의 요소들이 해시 함수를 통해 결정되는 버킷에 저장됩니다.<br>
따라서 특정 요소를 찾거나 추가하거나 삭제하는데, 상수시간이 걸립니다.<br>
하지만 해시 충돌이 발생한다면 O(n)의 시간복잡도를 가질수있습니다.(체이닝으로 해결 후 모든 요소가 동일한 버킷에 해시되는 경우)<br>
<br>
꼬리질문 - 왜 입력 순서가 보장되지 않을까요???
데이터 해싱된 값에 따라 저장되는 위치가 달라지기 때문에 순서가 보장되지 않습니다.<br>
만약 순서가 보장되어야 하는 상황이라면 LinkedHashSet을 사용하면 됩니다.<br>
<br>
참고 - hashCode()는 객체를 HashSet에 추가할때 해당 객체의 저장 위치 결정<br>
equals() 메서드는 해시 충돌이 일어날 때, 실제로 동일한 객체인지를 판별<br>
</details>

<details markdown = "1">
<summary>TreeSet에 아시는 대로 설명해주세요.</summary>
TreeSet은 Set인터페이스 구현체 중 하나로 HashSet과 같이 중복을 허용하지 않습니다.<br>
이러한 TreeSet의 가장 중요한 특징 중 하나는 자동 정렬기능입니다. TreeSet에 요소를 추가하면, 요소는 자연 순서 또는 TreeSet을 생성할때 제공한 Comparator에 따라 자동정렬됩니다.<br>
방금 말한 자연 순서란 요소가 Comparable 인터페이스를 구현하고 있는 경우 해당 객체 compareTo 메서드를 통해 결정됩니다.<br>
TreeSet은 내부적으로 레드 블랙 트리라는 자료 구조를 사용합니다.<br>
따라서 추가,삭제,검색 작업은 모두 log(n)의 시간복잡도를 가집니다. 이는 정렬된 상태를 유지하면서 이러한 연산을 수행하는 경우에 유용합니다.<br>
참고 - 삽입 및 삭제 시 트리의 균형을 유지하기 위한 재배치가 필요
</details>

<details markdown = "1">
<summary>BST(Binary Search Tree, 이진탐색트리)와 Binary Tree(이진트리)에 대해 설명해 주세요.</summary>
이진 탐색 트리란 이진 트리의 일종으로, 특정한 규칙에 따라 데이터를 저장하는 구조입니다.<br>
각 노드의 왼쪽 서브트리에는 현재 노드의 값보다 작은 값들을, 오른쪽 서브트리에는 현재 노드의 값보다 큰 값들을 저장하는 방식으로 작동합니다.<br>
이러한 방식 덕분에 이진탐색 트리에서는 일반적으로 데이터 검색,삽입,삭제 등의 작업을 로그 시간 내에 처리할 수 있습니다.(편향된 경우엔 O(N))<br>
<br>
하지만 이진 탐색 트리는 데이터가 이미 정렬되어있거나(12345 순으로 삽입한다고 생각해보자), 특정 패턴을 따라 삽입되는 경우 트리가 한쪽으로 치우쳐진 편향트리가 될 수 있습니다.<br>
이런 경우 트리의 높이가 높아져서 탐색,삽입,삭제 등의 연산이 O(N)에 비례합니다.<br>
따라서 이진 탐색 트리를 사용할때는 이런 문제를 고려해야 하면 이를 보완하기 위한 트리로 AVL 트리나 레드블랙 트리같은 균형 이진 탐색 트리가있습니다.<br>
<br>
반면 이진 트리는 모든 노드가 최대 두개의 자식 노드를 가지는 트리 구조를 말합니다.<br>
이러한 이진 트리는 빠른 데이터 삽입,삭제,검색이 가능하며, 이러한 연산은 보통 O(N)의 시간복잡도를 가집니다.<br>
이러한 이진트리는 대개 정렬되지 않은 데이터를 저장하거나, 이진 탐색이 아닌 다른 트리 기반 알고리즘을 구현할때 사용합니다.<br>
또한, 트리의 높이(height)를 최소화하여 효율적인 탐색을 할 수 있도록 균형 잡힌 트리(balanced tree)를 사용하는 경우도 있습니다. 대표적인 균형 잡힌 트리로는 AVL 트리, Red-Black 트리 등이 있습니다<br>
참고 - 중위 순회 방식으로 정렬된 순서대로 읽을 수 있음.
<br><br>
꼬리질문 - 둘의 차이점에 대해 설명해주세요.<br>
둘다 트리의 형태를 가진 데이터 구조이지만, 그 구조와 사용 방식에서 차이점이 있습니다.<br>
이진 트리는 각 노드가 최대 두개의 자식 노드를 가질수 있는 트리 데이터 구조입니다.<br>
이진 트리에서 노드는 특별한 순서로 배열되지 않습니다. 이는 이진 트리에서의 데이터 검색,삽입,삭제 연산이 효율적이지 않을 수 있습니다.<br>
이러한 이진 트리는 주로 트리 순회나 트리 기반 알고리즘의 구현 등에 사용합니다.<br>
반면 이진 탐색 트리는 이진 트리의 한 종류이지만, 데이터가 특정한 순서를 따라 배열됩니다. 모든 노드는 왼쪽 서브 트리의 노드들보다 크고 오른쪽 서브 트리의 노드들 보다 작습니다.<br>
이러한 특성으로 인해 연산을 효율적으로 수행할 수 있습니다.<br>
그러나, 이러한 성능은 트리가 균형이 잡혀있는 경우에만 보장됩니다.<br>
즉 요약하자면, 주요 차이점은 데이터의 정렬 상태에 있습니다.<br>
참고 - 이진 트리는 모든 노드를 방문해야 할 수 있겠지???
<br><br>
꼬리질문2 - 이진 탐색 트리의 연산 과정들에 대해 설명해주세요.<br>
이진 탐색 트리에서 검색 연산은 루트 노드에서 시작합니다.<br>
검색하려는 값이 루트 노드의 값보다 작으면 왼쪽 서브트리로, 크면 오른쪽 서브트리로 이동합니다.이 과정에서 검색하려는 값이 나타날때까지 반복합니다.<br>
삽입 연산 또한 루트 노드에서 시작하며, 삽입하려는 값이 루트 노드의 값보다 작으면 왼쪽, 크면 오른쪽으로 이동합니다.<br>
이 과정을 적절한 위치를 찾을때까지 반복합니다.<br>
삭제의 경우에는 삭제하려는 노드를 찾은후, 그 노드가 자식노드를 가지고 있는지 확인합니다.<br>
이때 리프노드라면 그냥 삭제하고, 하나의 자식 노드가 있으면 삭제하려는 노드를 제거하고 그 자식 노드를 삭제된 노드의 부모 노드로 연결합니다.<br>
그리고 두개의 자식 노드가 있으면 삭제할 노드의 오른쪽 서브트리에서 가장 작은 값이나 또는 왼쪽 서브트리의 가장 큰 값을 찾아 교체하게됩니다.<br>
참고 - 자식 두개 일때 BST 특성을 유지하기 위해 위와 같이 진행<br>
<br>
</details>

<details markdown = "1">
<summary>AVL 트리와 Red Black 트리에 대해 설명해주세요</summary>
AVL 트리와 Red black 트리 모두 BST의 단점인 트리의 불균형을 해결하기 위해 고안된 자료구조로 트리의 균형을 맞추어 탐색시간을 최소화하는데 사용됩니다.<br>
탐색 시간을 O(log N)으로 유지하면서 삽입,삭제 연산을 효율적으로 처리할 수 있도록 개발된 자료구조입니다.<br>
이진 탐색 트리는 탐색이나 삽입,삭제 연산시 평균적으로 O(log N)의 시간복잡도를 보입니다.<br>
그러나 트리의 구조가 한쪽으로 치우쳐져 있거나, 노드의 갯수가 많아질수록, 탐색 시간이 더욱 증가할 수 있습니다.<br>
이러한 문제를 해결하기 위해 AVL 트리와 Red-Black 트리가 개발되었습니다.<br>
AVL 트리는 모든 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1이하인 트리를 의미합니다.<br>
이러한 트리 구조를 유지하기 위해 삽입,삭제 연산시에는 회전(rotate)연산을 이용해 트리의 균형을 맞추어줍니다.<br>
Red-Black 트리는 AVL 트리보다 균형을 덜 맞춘 대신, 노드의 색깔을 이용하여 트리의 균형을 유지하는 BST입니다.<br>
레드 블랙 트리는 모든 노드가 레드 또는 블랙 중 하나의 색깔을 가지도록 구성되며, 일정한 규칙에 따라 노드를 삽입,삭제 하며 균형을 유지하며 다음과 같은 규칙을 따릅니다.<br>
루트 노드는 블랙이다, 모든 리프 노드는 블랙, 레드노드의 자식 노드는 모두 블랙, 어떤 노드에서 루트 노드까지 경로상에 있는 블랙 노드의 수는 모두 같다.<br>
이러한 규칙을 통해 red-black 트리는 균형을 맞추면서도 AVL트리보다 회전 연산의 발생 횟수가 적어 더욱 효율적인 탐색이 가능합니다.<br>
이러한 레드블랙 트리의 탐색 시간은 O(log N : 편향트리가 안되게끔 균형을 유지하므로)입니다.<br>
<br>
AVL 트리와 Red-Black 트리중 어떤 경우에 어떤 트리를 사용하면 좋을까요?<br>
AVL 트리는 트리의 높이를 균형 잡히게 유지하기때문에 탐색 중심의 연산이 많은 경우 유리합니다.<br>
반면 Red-Black 트리는 삽입과 삭제가 빈번히 일어나는 경우 유리합니다.왜냐하면 Red-Black 트리는 AVL 트리에 비해 리밸런싱 연산이 덜 발생하기 때문입니다.<br>
위 질문에 대한 추가질문 나올시<br>
AVL 트리는 자식 노드들 간의 높이가 최대 1이 되도록 유지하는 자료구조입니다.즉 트리의 균형을 비교적 엄격하게 유지합니다.<br>
이러한 특성때문에 AVL 트리는 깊이가 작고, 탐색 연산에 있어 효율적입니다.<br>
하지만, 이러한 엄격한 균형 유지로 인해 삽입,삭제 시 발생할 수 있는 회전연산이 빈번히 발생합니다.<br>
반면 AVL 트리는 노드 색상을 이용하여 트리의 균형을 부분적으로만 유지합니다.<br>
즉 AVL트리에 비해 균형 조건이 덜 엄격하고, 리밸런싱 연산이 덜 빈번하게 발생합니다.<br>
하지만 AVL트리에 비해 트리의 높이가 조금 더 높아질수있어, 탐색 연산이 AVL트리보다 조금 덜 효율적일순 있습니다.<br>
<br>
참고 - (자가)균형 이진 트리란 모든 노드에 대해 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 특정 값 이하면 이진 트리를 의미합니다.(AVL,REd-black)<br>
균형 이진 트리의  목적은 트리의 높이를 최소화하여 연산의 효율성을 보장하는 것입니다.<br>
</details>

<details markdown = "1">
<summary>레드 블랙 트리에 대해 아시는 한 상세히 설명해주세요.</summary>
레드 블랙 트리는 이진 탐색 트리의 확장 개념으로, 어떠한 연산이 일어나더라도 상대적으로 균형을 유지하는 특성이있습니다.<br>
레드블랙 노드는 총 5가지의 규칙을 가지고있습니다.<br>
첫번째로 각 노드는 레드 혹은 블랙이라는 색을 가지며, 이 색 정보는 노드 균형 유지를 위해 사용됩니다.<br>
두번째로 트리의 루트노드는 항상 블랙입니다.세번째로 모든 리프노드(null또는 NIL 노드)는 블랙입니다.<br>
네번째로 레드 노드의 자식은 언제나 블랙입니다. 즉 레드 노드가 연속으로 등장할수 없습니다.<br>
마지막으로 모든 노드에 대해 해당 노드로부터 자손인 리프 노드에 이르는 모든 경로에는 동일한 개수의 블랙 노드가 있습니다.<br>
또한 특성에 대해 조금더 설명드리자면, 루트 노드부터 리프노드까지의 모든 경로 중 최소 경로와 최대 경로의 크기비율은 2보다 크지 않습니다.(ex: 검검검, 검빨검빨 ....)<br>
이러한 상태를 balanced 상태라고 합니다.<br>
그리고 노드의 자식이 없는 경우, 자식 노드를 가리키는 포인터에 NIL 값을 저장하고 이를 리프노드이며, 검정색으로 간주하여 규칙(마지막 규칙)을 유지하게 됩니다.<br><br>
삽입 연산시에는 값을 삽입하다보면 Double Red가 발생할수있습니다.(일반적으로 삽입되는 노드는 레드 생각으로 설정) <br>
이때 엉클노드 즉 부모의 형제노드가 검정이면 Restructing, 빨강이면 Recoloring을 진행하게 됩니다.<br>
Restrucing은 현재 인서트된 노드, 그 노드의 부모노드, 조부모 노드를 가지고 진행합니다.<br>
이때 세 노드를 오름차순으로 정렬 후, 가운데 값을 부모로 만들고 나머지 둘을 자식으로 하게됩니다.<br>
이후 가운데 값을 검정, 나머지 두 자식을 빨강색으로 하게됩니다.<br>
이는 다른 서브트리에 영향을 끼치지 않아 한번에 Restrucint이면 끝나게 됩니다.(이러한 연산 진행 시 더블레드 해결 전후의 black 노드의 갯수 변화가 없으므로)<br>
또한 자체 시간 복잡도는 O(1)에 끝나지만(순서 결정 - 상수, 트리로 만드는- 상수, 노드 구조바꾸기 - 상수) 어디에 삽입될지 위치를 찾아야 하므로 수행시간은 O(log N)입니다.<br>
리 컬러링은 현재 인서트된 노드의 부모와 그 형제를 검정으로 하고 조부모를 빨강으로 합니다.<br>
이때 조부모가 루트노드가 아니고, 서브트리인 경우 더블레드가 발생할 수 있기에 여러번 진행 될 수 있습니다.<br>
연산 자체는 O(1)이지만, root까지 연산이 계속될수 있기에 최악의 경우 log(N)입니다.
이러한 규칙을 통해 레드-블랙 트리는 삽입,삭제 연산이 일어날때 트리의 균형을 유지하게 됩니다.<br><br>
삭제의 경우에는 그 노드가 레드 색상일 경우는 제거해도 균형 규칙을 위반하지 않기에 간단히 삭제해도됩니다.<br>
그러나 삭제 노드가 블랙인 경우에는 균형을 재조정해야합니다. 블랙 노드를 삭제하면 그 경로에 있는 블랙 노드 숫자가 줄어들어 규칙에 위반하기 때문입니다.<br>
이를 위해 삭제된 블랙 노드의 자리를 차지하는 노드의 색을 블랙으로 변경합니다.<br>
그런데 이때 새로운 노드가 이미 블랙이였다면,이중 흑색 노드가 되어 따로 처리를 해야 합니다.<br>
이때 형제 노드가 레드 노드이면, 형제 노드를 블랙, 부모 노드를 레드로 변경후, 부모 중심으로 왼쪽 회전을 합니다.<br>
형제노드가 블랙이고, 형제 양쪽 자식이 모두 블랙인 경우, 이중 블랙 노드에서 블랙하나를 제거하고, 형제 노드를 레드로 변경한 후, 부모 노드에 블랙을 추가합니다.<br>
형제 노드가 블랙이고, 형제 노드의 왼쪽 자식은 레드, 오른쪽 블랙인 경우, 형제 노드를 레드로, 형제 노드의 왼쪽 자식을 블랙으로 변경후, 형제 노드 중심으로 오른쪽 회전합니다.<br>
형제 노드가 블랙이고, 형제 노드의 오른쪽 자식은 레드인 경우, 부모 노드의 색을 형제에게 넘기고, 부모는 검, 형제 노드의 오른쪽 자식은 검으로변경 후 부모 기준 좌회전을 합니다.<br>
이러한 삭제 연산은 O(log N)의 시간복잡도를 가집니다.<br>
왜냐하면 레드 블랙트리는 균형 이진 탐색 트리의 한종류이기에, 높이가 log N을넘지 않습니다.<br>
삭제 연산은 탐색,삭제 및 앞서 말한 밸런싱 과정을 거치는데, 탐색 및 삭제는 log N의 시간복잡도를 가지며, 재 균형화 작업은 상수 시간 복잡도(루트 까지 반복되는 경우 이또한 log(N)를 가집니다.<br>
따라서 삭제 연산의 시간복잡도는 O(log N)입니다.<br>
<br>
참고 - 리컬러링에서 부모랑 엉클을 검정으로막 바꿔도되나? - 바꿔도 black depth는 일제히 1 증가하기에 문제 없습니다.<br>
</details>

<details markdown = "1">
<summary>트리와 그래프에 대해 설명해주세요.</summary>
둘다 복잡한 객체 간의 관계를 표현하는데 사용하는 자료구조입니다.<br>
트리는 계층적인 구조를 가지는 그래프의 일종입니다.<br>
트리는 루트 노드라 불리는 최상위 노드가 존재하며, 그 아래로 다수의 자식 노드가 붙어있는 형태입니다<br>
즉 부모 노드에서 자식 노드로의 방향성이 있습니다.<br>
이러한 트리는 사이클이 없습니다.즉 어떤 노드에서 출발하여 자신으로 다시 돌아오는 경로가 존재하지 않습나.<br>
그리고 두 노드를 잇는 경로는 유일하다는 특징을 가집니다.<br>
반면 그래프는 트리보다 더 일반적인 구조를 가집니다.<br>
그래프는 노드(or 정점:vertex)와 이들을 연결하는 간선으로 구성됩니다.(간선은 방향성을 가질수도 가지지 않을수도)<br>
요약하자면, 모든 트리는 그래프이지만, 모든 그래프가 트리인것은 아닙니다.<br>
트리는 순환없이 연결된 그래프의 특별한 형태로, 계층적인 구조를 가지나, 그래프는 좀더 일반적인 집합으로, 순환이나 다중 경로를 포함할 수 있습니다.<br><br>
참고 - 트리 용어 정리<br>
노드 : 트리의 핵심적인 구성 요소로, 정보를 저장, 그래프의 꼭짓점<br>
루트 : 트리의 가장 상위에 위치하는 노드로, 부모 노드가 없는 최상위노드<br>
자식 : 어떤 노드 아래, 부모 : 어떤 노드 위<br>
자손 노드 : 어떤 노드에서 리프 노드에 이르는 경로에 포함된 모든 노드<br>
조상 노드 : 루트 노드에서 어떤 노드에 이르는 경로에 포함된 모든 노드<br>
Leaf Node,Terminal Node : 자식 없는 노드<br>
내부 노드(Internal Node : 중간노드) : 루트 노드나 리프 노드가 아닌 로드<br>
간선 : 노드와 노드 연결하는 선<br>
형제 : 같은 부모를 가지는 노드를 형제 노드 라고함<br>
레벨 : 트리에서 루트 노드가 위치한 곳을 레벨0이라고 하고, 아래로 갈수록 1씩 증가<br>
깊이(depth) : 자신을 제외한 조상 노드의 갯수<br>
높이 : 트리의 높이는 루트 노드에서 가장 멀리 떨어지느 노드의 레벨 : 트리의 최대 레벨<br>
노드의 높이 : 해당 node가 리프 노드면 0이며, 해당 노드의 자식들의 height 중 가장 높은값 + 1<br>
차수 : 트리의 노드가 가지고 있는 자식의 노드 수를 의미<br>
</details>

<details markdown = "1">
<summary>트리를 순회하는 방법에 대해 아시는대로 설명해주세요.</summary>
트리를 순회하는 방법에는 주로 전위(inOrder)순회, 중위 순회(inorder), 후위 순회(post-order)가 있습니다.<br>
이 방법들 모두 트리의 모든 노드를 한번씩 방문하지만, 방문하는 순서에서 차이를 보입니다.<br>
전위 순회란 루트 노드를 먼저 방문하고, 그다음 왼쪽 서브트리를, 마지막으로 오른쪽 서브트리를 순회합니다.<br>
중위 순회는 왼쪽 서브트리를 먼저 순회하고, 그다음 루트 노드를 방문 한 후, 마지막으로 오른쪽 서브트리를 순회합니다.<br>
후위 순회는 왼쪽 서브트리를 먼저 순회하고, 그다음 오른쪽 서브트리를 순회한후, 마지막으로 루트 노드를 방문합니다.<br>
이 외에도 level-order 순회가 있습니다. 이는 트리의 노드를 레벨 순서대로, 각 레벨내에서는 왼쪽에서 오른쪽으로 방문합니다.(보통 큐로)<br>
</details>

<details markdown = "1">
<summary>HashTable과 HashMap 무엇인지 말씀해주세요.</summary>
HashTable이란 키-값 쌍으로 데이터를 저장하는 자료구조중 하나입니다.해시 충돌이 발생하지 않은 경우 데이터의 조회, 삽입, 삭제 등의 작업을 상수시간(충돌시:O(N))에 처리할 수 있어 자주 사용하는 자료구조입니다.
HashTable의 핵심 원리는 Hashing입니다. 해싱을 통해 키를 바탕으로 값을 빠르게 찾을 수 있습니다.<br>
이러한 해싱시에는 다른 값임에도 같은 해시 값을 가지게 되는 해시 충돌이 발생할 수 있습니다.<br>
자바에서는 hash를 사용하는 collection들의 해시 충돌을 해결하기 위해 체이닝 방법을 사용합니다.(임계점 넘으면 리해싱도 진행)<br>
즉 open Address 방식과 같이 다른 공간을 찾아 저장하는 것이 아니라, 해당 버킷에 LinkedList를 추가하여 충돌을 처리합니다.<br>
이러한 해시테이블은 HashMap과 동기화 지원 여부 및 null값 허용 여부에서 차이를 보입니다.<br>
HashMap에서는 null값을 허용하지만 HashTable은 null키나 값이 있으면 NPE를 던집니다.<br>
또한 HashMap은 동기화 처리가 되어있지 않아 멀티 스레드 환경에서 사용할 때 Thread Safe 하지 않은 반면, HashTable은 자체적으로 동기화 기능을 제공하기에, 멀티 스레드 환경에서도 안정적으로 사용할 수 있습니다.<br>
하지만 단일 스레드 환경에서는 동기화가 필요없기에 HashMap이 HashTable보다 더 빠른 성능을 제공합니다.<br>
동기화를 위한 오버헤드가 발생하지 않으며, 자바 8이후로 HashMap은 LinkedList의 크기가 임계값을 넘으면 밸런스 트리로 바꾸는 변경사항을 적용하여 성능이 더욱 향상되었습니다(O(n) -> O(log N).<br>
<br>
꼬리질문1 - 그렇다면 멀티쓰레드 상황에서는 HashTable을 사용하는 것이 가장 바람직한가요?<br>
HashTable은 메서드가 동기화 되어있으므로, 한번에 하나의 쓰레드만이 HashTable의 메서드를 사용할 수 있습니다.<br>
이는 공유 자원에 대한 동시 엑세스를 방지하지만 성능에 대한 오버헤드가 발생합니다.<br>
하지만 ConcurrentHashMap은 HashTable과 달리 내부적으로 여러개의 bucket(segment)를 가지며, 각 Segment별로 잠금 처리가 되어 동시에 여러 스레드가 작업을 수행할 수 있습니다.(해시 테이블 개선 버전)<br>
즉, ConcurrentHashMap은 동시에 여러 스레드가 데이터를 읽거나 쓸 수 있도록 허용하므로, 동시성 환경에서 성능 향상을 가져옵니다.<br>
따라서 동시성 환경이라면 HashTable 보다 ConcurrentHashMap을 사용하는 것이 성능적으로 더 좋습니다.<br>
<br>
참고 - 멀티스레드 환경이지만 동시에 매우 적은 수의 스레드만 접근한다면 hashtable이나 hashmap이 더 작합할 수 있음<br>
<br><br>
꼬리질문2 - 결국 데이터가 많아지면, 다른 데이터가 같은 해시 값으로 충돌 나는 현상이 발생하는데도 해시 테이블을 사용하는 이유는 무엇인가요?<br><br>
먼저, 데이터의 양이 증가하면서 해시 충돌의 가능성이 증가하는 상황에서도 해시 테이블이 유용한 이유는, 여전히 평균적으로 빠른 조회 속도를 제공하기 때문입니다<br>
물론, 해시 충돌이 발생하면 성능이 저하될 수 있지만, 이러한 충돌을 최소화하는 해시 함수의 선택과 충돌이 발생했을 때 이를 해결하는 기법(예: 체이닝 또는 개방주소법 등)을 통해 성능 저하를 최소화할 수 있습니다.<br>
두 번째로, 해시 테이블은 크기가 제한된 공간에서 효율적인 데이터 관리를 가능하게 합니다. 즉, 용량이 큰 데이터 집합을 상대적으로 작은 공간에 매핑하여, 공간 효율성을 극대화합니다. 이는 데이터베이스 시스템, 캐시 메모리와 같이 공간의 제약이 있는 상황에서 매우 중요한 특성입니다<br>
결국, 해시 테이블의 선택은 데이터의 양, 공간 효율성, 그리고 성능 사이에서의 트레이드오프를 고려해 결정됩니다. 충돌의 가능성에도 불구하고, 해시 테이블은 이러한 여러 요소를 적절히 조합하여 매우 효율적인 데이터 구조를 제공하기 때문에 널리 사용되고 있는 것입니다<br>
<br>
참고 - 예를들어 10만개의 데이터가 있고,이중 john이라는 이름을 가진 사람을 찾고 싶다고 하자.<br>
배열에서 john을 찾기 위해서는, 첫번째 부터 마지막 요소까지 하나하나 확인(O(N))<br>
반면 해시테이블에서는 John이라는 키가 이미 저장되어있으며, 해당 키에 대응하는 값을 해시 함수를 통해 계산된 인덱스에 저장되어있음.<br>
따라서 즉시 해당 값을 찾아낼 수 있다. 즉 둘의 차이는 값을 어떻게 찾느냐에 따라 다르다.
<br><br>
꼬리질문3 - 동기화된 자료구조란 무엇인가요?<br>
이것은 멀티스레드환경에서 안전하게 사용할 수 있는 자료구조입니다.<br>
멀티스레드 환경에서 여러 개의 스레드가 동시에 접근하면 데이터 불일치가 발생할 수 있습니다.이를 위해 동기화된 자료구조를 사용합니다.<br>
동기화된 자료구조는 일반적으로 락이라는 동기화 기술을 사용하여 여러 스레드가 동시에 접근할 수 없도록 막습니다.<br>
하지만 동기화된 자료구조를 사용하면 락을 획득하고 반납하는 과정에서 오버헤드가 발생하므로, 성능에 영향을 미칩니다.<br>
따라서 가능하면 스레드 안전하지 않은 자료구조를 사용하는 것이 좋을 수 잇찌만, 이 경우에는 스레드간 접근을 제어하기 위한 다른 방법을 사용해야합니다.<br>
<br>
참고<br>
hashmap - 삽입(평균 1, 최악의 경우 logn(자바8 이후)), 조회(평균 1: 최악의 경우 log n)), 삭제(1, log n)<br>
hashtable - 삽입(평균 1, 최악의 경우 n), 조회 삭제 다 같음<br>
linkedHashMap : hashmap과 같음<br>
TreeMap : 삽입,조회,삭제 (log n)<br>
</details>

<details markdown = "1">
<summary>LinkedHashMap과 TreeMap에 대해 설명해주세요.</summary>
LinkedHashMap은 순서를 고려하는 HashMap의 확장형입니다. 기본적인 HashMap의 특성을 가지면서도, 원소들이 추가된 순서에 따라 이중 연결 리스트로 연결되어 있습니다<br>
이 특성 덕분에 입력 순서가 중요한 상황에서, 예를 들어 최근에 입력된 원소에 빠르게 접근하거나 원소를 순차적으로 처리해야 하는 상황에 적합합니다.<br>
하지만, 이런 순서 정보를 저장하기 위해 추가적인 메모리를 사용하므로, 공간 효율성이 중요한 상황에서는 주의해야 합니다.<br>
반면에 TreeMap은 키-값 쌍을 Red-Black 트리 구조로 저장하는 구현체입니다. 이 트리의 균형 유지 속성 때문에, 삽입, 조회, 삭제 연산에 O(log N)의 시간 복잡도를 가집니다.<br>
특히, TreeMap은 키를 기준으로 자동 정렬하는 기능을 제공하므로, 키에 따른 순서가 중요한 상황에서 유용하게 사용될 수 있습니다. 다만, TreeMap은 동기화를 지원하지 않으므로, 멀티 스레드 환경에서 사용할 때는 주의해야 합니다.<br>
</details>

<details markdown = "1">
<summary>LinkedHashSet에 아시는 대로 설명해주세요.</summary>
linkedHashSet은 HashSet의 서브클래스로, 입력 순서에 따라 요소를 저장합니다.<br>
이는 HashSet과 달리 내부적으로 이중 연결 리스트를 유지하기 때문입니다.<br>
그 외에는 HashSet과 유사하게 중복된 요소를 허용하지 않고, equals()와 hashCode() 메서드를 통해 동일성을 결정합니다.<br>
<br>
참고 - 노드 내부에 다음 노드와 이전 노드를 가리키는 변수가 있다.
</details>

### Operation System

# 인터넷에서 있는 면접 질문 내용들 좀 추가하고, 쓰레드 멀티쓰레드 이런 내용처리하면 끝남

## 운영체제 관련 질문
<details markdown = "1">
<summary>운영체제란 무엇이죠?</summary>
<img src = https://github.com/wookjongkim/cs-study/assets/121083077/049d3667-ced9-43f7-bd7e-83c84690a1fe>
운영체제란 컴퓨터 하드웨어와 소프트웨어 리소스를 관리하며 사용자(응용프로그램)와 컴퓨터(하드웨어) 사이의 인터페이스 역할을 하는 시스템 소프트웨어입니다.<br>
이를 좁은 의미로 보면 커널 그 자체를 의미하고, 넓은 의미로 보면 커널과 시스템을 위한 유틸리티(GUI, 시스템콜, 드라이버(하드웨어 제어하기 위한 SW 등)를 포함합니다.<br>
<br>
인터페이스란 서로 다른 두개의 시스템 사이에서 정보나 신호를 주고받는 경우의 점점이나 경계면<br>
<br>
꼬리질문 1 - 그렇다면 커널이란 무엇인가요??<br>
커널은 운영체제 코드 중에서도 핵심적인 부분을 나타냅니다. 커널은 하드웨어 제어 뿐만 아니라 메모리 및 프로세스 관리 등 다양한 운영체제 기능을 수행하고 부팅 이후 메모리에 항상 상주하고 있습니다.<br>
<br>
꼬리질문 2 - 운영체제의 역할은 무엇인가요?? or 왜 필요한가?<br>
운영체제는 사용자가 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공해주고(ex: GUI, 멀티태스킹으로 작업 동시에 하는것 처럼 느끼게),<br>
컴퓨터 시스템 내의 자원(하드웨어 + 소프트웨어)을 효율적으로 관리하는 역할을 합니다.<br>
<br>
</details>

<details markdown = "1">
<summary>커널은 어떻게 구성되어있나요?</summary>
커널 또한 프로그램이기에 코드,데이터,스택으로 구성된 주소 공간을 가집니다.<br>
이때 코드 영역에는 하드웨어를 관리하기 위한 코드나 사용자에게 인터페이스를 제공하기 위한 코드, 시스템 콜 및 인터럽트 처리를 위한 코드 들을 담고있습니다.<br>
커널의 데이터 영역에는 각종 자원을 관리하기 위한 자료구조가 저장되어있으며, 여기에 PCB가 저장되어있습니다.<br>
커널의 스택 영역은 커널 모드에서 실행되는 프로세스나 함수들의 지역 변수나 리턴 주소 등을 저장하는 공간입니다.<br>
<br>
꼬리 질문1 - 커널 스택 영역과 스택 영역의 차이점이 있나요??
사용자 스택 영역은 해당 프로그램만 접근할 수 있습니다. 이에 반해 커널 스택 영역은 커널이 실행 중인 모든 프로세스에서 접근할 수 있습니다<br>
</details>

<details markdown = "1">
<summary>커널 모드와 사용자 모드에 대해 설명해주세요.</summary>
커널모드란 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행하도록 하는 모드로, 이 모드에서는 모든 종류의 명령을 다 실행할 수 있습니다.<br>
반면 사용자모드란 일반 사용자 프로그램이 실행되는 모드로, 이 모드에서는 제한적인 명령만 실행 가능하며, 시스템에 중요한 영향을 미치는 연산은 커널모드에서만 실행될 수 있도록 설정되어있습니다<br>
</details>

## 하드웨어 관련 질문
<details markdown = "1">
<summary>(운영체제의 or 컴퓨터 시스템의) 하드웨어는 어떻게 구성되어있을까요??</summary>
운영체제의 하드웨어는 크게 CPU, 메모리, 디스크, 입출력 장치로 구성되어 있습니다.<br>
<br>
꼬리질문 1 - 각각의 역할을 무엇인가요?<br>
CPU는 중앙 처리 장치로서, 프로그램의 연산 및 처리를 담당하는 핵심적인 역할을 합니다.<br>
메모리는 CPU가 직접 접근할 수 있는 저장 공간으로, CPU 처리를 위해 임시적으로 프로그램의 코드나 데이터 등이 저장되는 공간입니다.<br>
디스크는 메모리와 마찬가지로 데이터를 저장하는 공간입니다. 하지만 앞서 설명드린 메모리는 휘발성 기억장치인 것과 달리, 디스크는 비휘발성 기억장치이기에 한번 디스크에 저장되면 컴퓨터가 꺼지더라도 데이터가 보존됩니다.<br>
입출력장치는 사용자와 컴퓨터간의 상호작용을 가능하게 하는 장치로서, 키보드나 마우스 모니터 등이 이에 해당합니다. 이들은 사용자의 입력을 받아들이거나, 컴퓨터의 처리 결과를 사용자에게 보여주는 역할을 합니다.<br>
</details>

<details markdown = "1">
<summary>DMA(Direct Memory Access)란 무엇이죠?</summary>
DMA란 컴퓨터에서 입출력 장치와 메모리 사이의 데이터 전송을 CPU의 개입 없이 직접적으로 처리하는 기능을 뜻합니다.<br>
일반적으로, 데이터를 메모리와 입출력 장치(로컬 버퍼) 사이에 이동시키는 작업은 CPU가 담당합니다. 하지만 이런 방식은 CPU의 부하를 증가시키고, 이로 인해 CPU의 다른 중요한 작업이 지연될 수 있습니다.<br>
DMA는 이러한 문제를 해결하기 위해 설계되었습니다. DMA 컨트롤러는 CPU의 개입 없이 메모리와 입출력 장치 사이에서 데이터를 직접 이동시켜 CPU의 부하를 줄이고, CPU가 더 중요한 작업에 집중할 수 있게 해줍니다.<br>
</details>

<details markdown = "1">
<summary>CPU가 무엇인지랑 구성 요소 및 연산 처리 과정을 간단히 설명해주세요.</summary>
CPU는 중앙 처리 장치로서, 프로그램의 연산 및 처리를 담당하는 핵심적인 역할을 합니다.(메모리에 있는 명령어 해석해서 실행하는 일꾼)<br>
이러한 CPU는 제어 장치, 레지스터, 산술 논리 연산 장치로 구성되어있습니다.<br>
제어장치는 명령어를 읽고 해석하며, 데이터 처리를 위한 순서를 결정합니다.<br>
레지스터는 CPU 안에 있는 매우 빠른 임시기억 장치로 연산에 사용되는 데이터나 중간 결과를 보관하고 있습니다.<br>
산술 논리 연산 장치(ALU)는 덧셈 뺄셈과 같은 두 숫자의 산술 연산과, 논리 연산을 계산하는 디지털 회로입니다.<br>
연산 처리 과정에서 우선 제어장치가 메모리와 레지스터에 계산할 값을 로드합니다.<br>
이후 제어장치가 레지스터에 있는 값을 계산하라고 산술논리연산 장치에 명령 한 후, 계산된 값을 다시 레지스터에서 메모리로 계산한 값을 저장합니다.<br>
</details>

<details markdown = "1">
<summary>메모리 계층 구조에 대해 설명해주세요.</summary>
메모리 계층 구조는 레지스터, 캐시 메모리, 주기억 장치, 보조기억 장치로 나뉩니다.<br>
레지스터는 CPU 내에 위치하며, CPU가 접근할 수 있는 고속의 메모리입니다.<br>
캐시 메모리는 CPU와 직접 연결되어 있는 메모리로, 자주 사용되는 데이터를 저장합니다.(L1,L2,L3 등 계층으로 구성될 수 있음)<br>
주기억장치는 RAM을 가리키며, CPU가 필요로 하는 데이터와 프로그램을 임시적으로 저장합니다.<br>
보조 기억 장치는 대용량의 데이터를 영구적으로 저장하는 상용되며, 접근 속도는 느리지만 저장 용량이 크고 비용이 저렴합니다.<br>
</details>

<details markdown = "1">
<summary>타이머란 무엇인가요?</summary>
타이머는 정해진 시간이 지나면, 인터럽트를 발생시켜 운영체제가 CPU의 제어권을 획득할 수 있도록 하는 하드웨어입니다.<br>
보통 이때 운영체제가 CPU 제어권을 얻으면, 현재 실행 중인 프로세스를 중지하고(현재 프로세스가 너무 오래 점유하거나, 자원 과도히 사용) 다음 프로세스에게 CPU를 넘겨줍니다.<br>
</details>

<details markdown = "1">
<summary>MMU(Memory Management Unit)이 무엇인가요?</summary>
MMU(Memory Management Unit)는 CPU와 메모리 사이에 위치한 하드웨어 장치로서, 논리적 주소를 물리적 주소로 변환하는 주소 변환 역할을 합니다. 예를 들어, CPU가 논리적 주소 1번지에 있는 내용을 요청하면, MMU는 기준 레지스터에 저장된 값을 이 주소에 더해 물리적 주소를 계산합니다. 이렇게 변환된 주소는 물리 메모리의 실제 위치를 가리킵니다.<br>
<br>
참고 - 이는 메모리 상 데이터가 연속적으로 존재할때만 가능<br>
</details>

## 프로세스와 스레드 관련 질문
<details markdown = "1">
<summary>프로세스란 무엇이죠?</summary>
프로세스란 운영체제에서 실행 중인 프로그램의 인스턴스로 운영체제로부터 CPU,메모리 공간 등의 시스템 자원을 할당받아 작업을 수행합니다.<br>
각 프로세스는 독립된 메모리 영역(code,data,stack,heap)을 가지며, 이 영역은 다른 프로세스로 부터 보호되어 접근 할 수 없습니다.<br>
<br>
꼬리질문 1 - 어떻게 다른 프로세스가 해당 프로세스 영역에 접근하지 못하는 것이죠??<br>
프로세스가 자신에게 할당되지 않은 메모리 영역에 접근하려고 하면 운영체제가 이를 잘못된 메모리 접근으로 판단하고 해당 프로세스를 종료하기 때문입니다.<br>
</details>

<details markdown= "1">
<summary>프로세스의 주소 공간(프로세스 or 프로그램 구조)에 대해 설명해주세요</summary>
프로세스 주소 공간이란 운영체제가 각 프로세스에게 할당하는 독립적인 메모리 영역으로 코드, 데이터, 스택, 힙 영역으로 나누어져 있습니다.<br>
코드 영역에는 프로그래머가 작성한 프로그램 함수들의 코드가 (CPU가 해석 가능한) 기계어 형태로 저장되는 영역입니다.(읽기 전용)<br>
데이터 영역에는 코드가 실행되면서 사용되는 전역 변수나 각종 데이터(정적 변수)가 저장되는 영역입니다.<br>
스택 영역은 함수 호출과 관련된 정보, 예를 들어 지역 변수나 복귀 주(함수 종료 후 제어가 돌아갈 곳)등이 저장되는 공간입니다. <br>
이때 함수 호출이 발생하면 해당 정보는 스택에 푸쉬되고, 함수가 반환되면 스택에서 팝됩니다.<br>
마지막으로 힙 영역은 프로세스가 동적으로 메모리를 할당받는 공간입니다. 즉 프로세스 실행 중에 필요 따라 메모리를 할당하거나 해제하는 영역입니다.<br>
<br>
나눈 이유 - 프로그램의 각 요소들이 수행하는 역할에 따라 필요한 메모리 영역을 제공함. 메모리 효율적 관리.<br>
영역 분리하면 메모리 접근 권한을 통해 보안을 강화 가능.
</details>

<details markdown = "1">
<summary>프로세스 상태 변화 과정을 설명해주세요.</summary>
프로세스는 다양하게 상태가 변경되며 수행됩니다. new 상태는 프로세스가 생성중인 상태를 뜻합니다(메모리 획득 승인 받지 못한 상태). 그러다 프로그램이 메모리에 올라가고 CPU를 할당받기 위해 기다리는 경우 이를 ready 상태라고 합니다.<br>
ready 상태에서 CPU를 획득하여 명령을 수행중인 상태는 running 상태라고합니다. 입출력 명령을 기다리는 동안 프로세스는 CPU를 빼앗기게 되고 CPU를 할당 받더라도 당장 명령을 수행할 수 없는 상태가 되는데, 이를 blocked(봉쇄)상태라고 합니다.<br>
운영체제는 너무 많은 프로세스가 메모리에 올라와 있으면 당장 사용하지 않는 프로세스를 통째로 디스크에 쫓아냅니다. 이렇게 통째로 디스크로 swap out된 프로세스의 상태는 suspended 상태라고 합니다. 또한, ready 상태의 프로세스가 swap out 되어서 디스크에 있는 상태를 Ready Suspend (Suspended Ready) 상태라고 하고, blocked 상태의 프로세스가 swap out된 상태를 Blocked Suspend (Suspended Blocked) 상태라고 합니다.<br>
이후 수행이 끝난 상태는 terminated 상태라고 합니다. 추가로, 운영체제가 메모리 공간이 충분해질 때, 디스크에서 메모리로 프로세스를 다시 옮기는 과정을 swap in이라고 합니다. 이 과정을 통해 프로세스는 다시 ready 상태로 돌아오게 됩니다.<br>
<br>
꼬리질문 1 - 흠.. blocked 상태와 suspended 상태의 차이가 뭐죠?<br>
Blocked 상태와 Suspended 상태의 차이는 크게 두 가지입니다.<br>
Blocked 상태는 프로세스가 메모리에 있지만 특정 이벤트(예를 들어, 입출력 작업의 완료)를 기다리고 있어 CPU를 사용할 수 없는 상태를 나타냅니다. 이와는 달리, Suspended 상태는 시스템의 메모리 부족 혹은 운영체제의 관리 정책 등에 의해 프로세스가 메모리에서 디스크로 옮겨진 상태를 의미합니다<br>
두 번째 차이점은 프로세스가 Ready 상태로 돌아가는 방법에 있습니다. Blocked 상태의 프로세스는 자신이 기다리고 있는 이벤트가 완료되면 바로 Ready 상태로 돌아갑니다. 반면에, Suspended 상태의 프로세스는 외부에서 명시적으로 Resume 명령을 받아야만 다시 Ready 상태로 돌아갈 수 있습니다<br>
<br>
Resume 명령은 일반적으로 프로세스가 Suspended 상태에서 다시 Ready 상태로 돌아가기 위해 필요한 명령을 의미<br>
유저 모드 Running -> 커널 모드 Running은 시스템콜,인터럽트, 트랩등에 의해, 이후 복귀<br>
Running -> Blocked : 입출력 요청, Blocked -> Suspended Blocked 스왑 아웃, 스왑 인, Ready -> Suspended Ready : 스왑아웃, 스왑 인<br>
block -> wait : 입출력 작업이 완료된 경우 Suspended Blocked -> Suspended Ready : 입출력 작업 완료된 경우<br>
</details>

<details markdown = "1">
<summary>프로세스는 다양한 상태가 존재하네요. 스케줄러를 통해 이를 어떻게 관리하는지 설명해주세요.</summary>
운영체제는 프로세스들을 관리하고 스케줄링 하기 위한 큐를 두고 있습니다.(커널 데이터 영역에)<br>
Ready Queue는 ready 상태의 프로세스들을 줄세우고, device queue는 device 입출력 작업을 대기하고 있는(blocked) 큐입니다.<br>
그리고 job Queue는 시스템 내의 모든 프로세스를 관리하는 큐(위 두개 다 포함하는 상위개념)입니다.<br>
각 큐에 줄서 있는 프로세스들을 관리하기 위한 스케줄러는 총 3종류로 존재합니다.<br>
장기 스케줄러는 프로세스를 ready queue에 진입시킬지를 결정합니다. 즉 프로세스의 메모리 할당에 관여합니다.<br>
중기 스케줄러는 어떤 프로세스를 스왑 아웃(메모리 공간의 효율성을 위해) 시킬지 결정하고, 단기 스케줄러는 ready 상태 프로세스 중 어떤 프로세스에게 CPU를 줄지 결정합니다.<br>
<br><br>
중기 스케줄러 스왑 아웃 우선순위 1순위 - block 상태 프로세스, 2순위 타이머 인터럽트에 의해 ready 상태가 된 프로세스<br>
중기 스케줄러로 인해 프로세스 상태에는 중지라는 상태가 추가됨<br>
중지 상태에 있는 프로세스(ex: 메모리가 부족하여 봉쇄 상태에서 중지 상태로 바뀐 경우, 준비 상태에서 중지 상태로 바뀐 경우)는 외부에서 재개시키지 않는 이상 다시 활성화될 수 없기에 메모리 자원이 당장 필요하지 않습니다. 따라서 중지 상태의 프로세스는 메모리를 통째로 빼앗기고 디스크로 스왑아웃됩니다.<br>
</details>

<details markdown = "1">
<summary>PCB란 무엇인가요?</summary>
운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내(데이터 영역)의 자료 구조를 뜻합니다<br>
이러한 PCB에는 프로세스 구분자, 프로세스 상태, PC값, 메모리 관리 정보, CPU 스케줄링 정보 등을 담고있습니다.<br>
<br>
꼬리질문 1 - 위와 같은 정보들이 왜 필요한거죠??
이러한 정보들이 필요한 이유는 운영체제가 각 프로세스를 효율적으로 관리하고, 필요한 작업을 수행하기 위함입니다
예를 들어, 프로세스의 상태 정보는 프로세스가 어떤 상태에 있는지를 알려주어, 해당 프로세스에 대한 적절한 작업을 수행하게 합니다.<br>
메모리 관리 정보는 프로세스의 메모리 사용을 추적하고 관리하는데 사용되며, 이는 메모리 누수와 같은 문제를 방지하고, 메모리 사용의 효율성을 높이는 데 도움이 됩니다<br>
프로그램 카운터와 레지스터들의 정보는 프로세스가 중단된 후에도 프로세스의 실행을 재개할 수 있도록 돕습니다. 이 정보를 이용하면 프로세스의 현재 상태를 저장하고, 필요한 경우에 원래의 상태로 복원할 수 있습니다.
<br>
따라서, 이러한 정보들은 프로세스의 관리와 실행을 위해 꼭 필요한 정보들입니다.<br>
<br>
참고 - 포인터,프로그램 우선순위, 각종 레지스터 정보, 계정정보, PPID CCID 정보도 담고있음.<br>
</details>

<details markdown = "1">
<summary>Context Switching이란 무엇이고 왜 필요한것이죠??</summary>
컨텍스트 스위칭(Context Switching)은 CPU가 하나의 태스크(프로세스 혹은 스레드)에서 다른 태스크로 작업을 전환하는 과정을 말합니다. 이 과정에서 현재 실행 중인 태스크의 상태를 프로세스 제어 블록(Process Control Block, PCB)에 저장하고, 실행할 다음 태스크의 상태 값을 PCB에서 읽어와 CPU의 레지스터에 적재합니다<br>
이렇게 컨텍스트 스위칭을 통해 CPU는 I/O 작업이 실행되어 블로킹 상태에 놓인 태스크에서 다른 태스크로 전환할 수 있습니다. 이는 CPU가 I/O 작업의 대기 시간 동안 유휴 상태에 놓이는 것을 방지하고, 더 효율적으로 CPU를 활용할 수 있게 합니다<br>
또한, 컨텍스트 스위칭 덕분에 운영체제는 여러 프로세스를 동시에 처리하는 것처럼 보이게 함으로서 시분할 시스템 또는 멀티태스킹을 실현합니다<br>
그러나 이 과정은 오버헤드를 발생시키며, 이 시간 동안 CPU는 실제 작업을 수행할 수 없습니다. 그렇지만 일반적으로 이 오버헤드 시간은 I/O 작업 시간에 비해 훨씬 짧기 때문에, 컨텍스트 스위칭이 시스템의 전반적인 효율성을 향상시키는 데에 기여합니다<br>
<br>
유사질문 1 - 컨텍스트 스위칭은 주로 어떤 경우 발생하나요??
컨텍스트 스위칭은 타이머 인터럽트나, 입출력 요청 등에 의해 주로 발생합니다.<br>
실행 중인 프로세스가 할당된 시간을 모두 소비하면, 운영체제는 타이머 인터럽트를 발생시키고 CPU의 제어권을 넘겨받습니다. 운영체제는 실행 중이던 프로세스의 상태를 저장하고, 다음으로 실행할 준비 상태의 프로세스를 선택하여 그 프로세스에게 CPU의 제어권을 넘깁니다. 이를 통해 CPU는 다양한 프로세스를 공평하게 실행할 수 있게 됩니다<br>
실행 중인 프로세스가 입출력 작업을 요청하면, 해당 프로세스는 봉쇄 상태로 전환됩니다. 이때 운영체제는 준비 상태에 있는 다른 프로세스를 선택하여 CPU의 제어권을 넘깁니다. 이는 입출력 작업이 완료될 때까지 CPU가 유휴 상태에 머무르는 것을 방지하고, CPU의 활용도를 높입니다<br>
<br>
참고- 이때 준비 상태에 있는 프로세스중 어떤 프로세스에게 CPu를 할당할지 결정하고, 해당 CPU에게 제어권을 넘겨주는 과정을 디스패치라고 함.
</details>

<details markdown = "1">
<summary>프로세스는 어떻게 생성되나요?</summary>
시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만, 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성하게 됩니다.<br>
이때 프로세스를 생성한 프로세스를 부모 프로세스, 새롭게 생성된 프로세스를 자식 프로세스라고 합니다.<br>
<br>
자식 프로세스는 부모 프로세스의 context(레지스터 상태나 Pc값들)을 그대로 복제하여 생성됨(fork() 시스템콜을 통해)<br>
이때 독자적인 작업을 시키고 싶다면 exec() 시스템 콜을 사용해야 함<br>
<br>
exit 시스템콜은 프로세스가 실행 완료했을때나, 어떤 이유로 더 이상 실행을 계속할 수 없을때 exit()을 통해 운영체제에 알림(자발적 종료), 이후 운영체제는 시스템 자원 회수하고 종료상태로 바꿈<br>
wait() 시스템콜은 부모 프로세스가 자식 프로세스 종료를 기다리기 위해 사용. 이를 통해 서로 동기화 가능<br>
</details>

<details markdown = "1">
<summary>IPC(Inter Process communication)란 무엇인가요?</summary>
IPC란 다른 프로세스간에 데이터를 주고 받을 수 있게 해주는 메커니즘입니다. 즉 독립적으로 실행되는 프로세스들 사이에 정보를 교환하게 해줍니다.<br>
이러한 IPC 메커니즘은 다양한 방식으로 구현될 수 있습니다.<br>
첫번째는 익명 파이프(PIPE)입니다. 여기서 파이프란 두 프로세스간 파이프를 연결해서 통신하는 방식으로, 이때 한 프로세스는 쓰기만 가능하고 한 프로세스는 읽기만 가능합니다.<br>
그리고 이는 한쪽 방향으로만 통신이 가능하기에 반 이중 통신이라 부르기도 합니다.(이 또한 전이중 통신위해서는 파이프 2개를 만들어야 함)<br>
<br>
두번째로 Named Pipe(FIFO) 방식이 있습니다. 앞서 설명드린 PIPE는 통신하는 프로세스가 명확할 경우(ex: 부모-자식 프로세스간) 사용하는 반면, NamedPIPE는 전혀 모르는 사이의 프로세스들의 통신에 사용합니다.<br>
하지만, 익명 PIPE와 동일하게 동시에 읽기/쓰기가 불가능 하고, 전 이중 통신을 위해서는 익명 파이프처럼 2개를 만들어야 가능합니다.<br>
<br>
메세지 큐는 프로세스 간 메세지를 주고 받는 방식으로, 일반적으로 큐 자료구조를 이용하여 구현됩니다.이때 메세지를 보내는 프로세스는 메세지 큐에 메세지를 넣고, 메세지를 받는 프로세스는 메세지 큐에서 메세지를 가져옵니다.<br><br>
공유 메모리 방식은 두개 이상의 프로세스가 동일한 물리적 메모리 공간을 공유하여 데이터를 주고 받는 방식입니다.<br>
프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당해줍니다. 이후 어떤 프로세스건 해당 메모리영역에 접근할 수 있습니다. 공유 메모리는 곧바로 메모리에 접근할 수 있기 때문에 IPC 방식 중 속도가 제일 빠릅니다(근데 동기화 고려해야).<br>
<br>
소켓(Socket)은 네트워크에서 동작하는 프로세스 간에 데이터를 교환하는 방식으로 서로 다른 시스템에 있는 프로세스들 사이에서 데이터를 주고 받을 때 적합합니다.<br>
이때 서버 프로세스는 특정 포트에서 들어오는 클라이언트 연결을 수신하기 위해 소켓을 열고 대기하고, 클라이언트 프로세스는 서버의 IP와 포트를 알고 있어야 연결을 수립할 수 있습니다.<br>
<br>
참고 - 메세지큐는 FIFO, 여러 프로세스가 동시에 큐에 접근하여 메세지를 읽고 쓸 수 있다는 것입니다. 각 프로세스는 메세지를 큐에 추가하거나 큐에서 메세지를 꺼내어 처리하며, 이 방식을 통해 여러 프로세스 간에 데이터를 공유할 수 있습니다.<br>
메세지 큐는 메모리 내에 위치하여 빠른 속도로 데이터를 전달하고, 프로세스가 종료되어도 큐에 있는 메세지는 사라지지 않습니다. 이러한 특성 때문에 메세지 큐는 서로 다른 라이프 사이클을 가진 프로세스간의 통신에 적합합니다.<br>
</details>

## CPU 스케줄링 관련 질문
<details markdown = "1">
<summary>CPU 버스트와 I/O 버스트에 대해 아시나요?</summary>
사용자 프로그램이 CPU 제어권을 가지고 빠른 명령을 수행하는 일련의 단계를 CPU 버스트라고 부르고, I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 비교적 느린 단계를 I/O 버스트라고 부릅니다.<br>
<br>
참고 - CPU 프로세싱은 이와 같이 패턴이 상이한 여러 프로그램이 동일한 시스템 내부에서 함께 실행되기에 필요<br>
대부분은 CPU를 오래 사용하기보단, 잠깐 사용하고 I/O 작업을 수행하며, 짧은 CPU 버스트를 가진 프로세스에게 우선적으로 CPU 할당하는 것이 이득일 수 있다.<br>
</details>

<details markdown="1">
<summary>디스패치에 대해 아시나요?</summary>
디스패치는 현재 실행 중인 프로세스의 문맥(context)을 해당 프로세스의 PCB(Process Control Block)에 저장한 다음, 다음으로 선택된 프로세스의 문맥을 해당 프로세스의 PCB에서 복원하여 CPU의 제어를 그 프로세스에게 넘기는 과정을 의미합니다.<br>
</details>

<details markdown = "1">
<summary>CPU 스케줄링이란 무엇이고, 어떠한 경우 필요할까요??</summary>
CPU 스케줄링이란 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 것으로, 비 선점형 방식과, 선점형 방식이 있습니다.<br>
비 선점형은 CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지 CPU를 빼앗기지 않는 방법이고, 선점형 방식은 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을수 있는 방식입니다.<br>
만약 실행 상태에 있던 프로세스가 I/O 요청에 의해 봉쇄 상태가 되거나(비선점형), 실행 상태에 있던 프로세스가 타이머 인터럽트(선점형)에 의해 준비상태로 바뀌는 경우, CPU 이용률을 높이기 위해 다른 프로세스에게 CPU 제어권을 넘기는 과정에서 CPU 스케줄링이 필요합니다.<br>
또한 CPU에서 실행상태에 있던 프로세스가 종료되는 경우도 예시로 들수 있습니다.
</details>

<details markdown="1">
<summary>여러가지 CPU 스케줄링 기법은 어떻게 평가되나요?</summary>
A) 시스템 관점에서는 CPU 이용률과 처리량(throughput)을 높이는 데 목적이 있고 개별 프로세스 관점에서는 응답시간, 대기시간, 소요시간을 짧게 하는 것이 목적입니다. <br>
이때 응답시간(response time)은 준비상태의 프로세스에게 최초로 CPU가 할당되기까지 걸린 시간, <br>
대기 시간은 ready 상태에서 CPU를 기다린 총 시간(시분할 시스템의 경우 타이머 인터럽트로 인해 기다리는 시간 여러번 있겠지?), <br>
소요시간은 준비큐에서 기다린 시간과 실제로 CPU를 사용하는 시간의 합을 뜻합니다.(원하는 만큼 CPU 다쓰고 CPU 버스트가 끝나기 까지 걸린 시간).<br>
<br>
참고 - CPU 이용률은 전체 시간 중 CPU가 일을 한 시간의 비율을 나타냅니다<br>
처리량(Throughput)은 주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지를 의미합니다.<br>
</details>

<details markdown="1">
<summary>여러가지 CPU 스케줄링 기법에 대해 간략히 설명해주세요.</summary>
CPU스케줄링은 두 가지로 나눌 수 있습니다. 비 선점형은 CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지 CPU를 빼앗기지 않는 방법이고, 선점형 방식은 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을수 있는 방식입니다<br>
<br>
FCFS(선입 선출: First Come First Served) 스케줄링은 먼저 온 프로세스부터 CPU를 할당하며, 비 선점형 스케줄링입니다. 이때 소요시간이 긴(CPU 버스트가 긴) 프로세스가 먼저 도착해 버리면 전체적으로 프로세스들의 효율성을 낮춘다는 단점을 갖고 있습니다.(콘 보이)<br>
<br>
SJF 스케쥴링은 CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식으로, 이 또한 비 선점형 방식으로 동작합니다.<br>
이때 CPU 버스트가 긴 프로세스는 오랜시간 CPU를 할당받지 못해 starvation 문제가 발생할 수 있습니다.<br>
<br>
SRTF는 SJF와 유사하나 중간에 새로운 프로세스가 도착하면 새로 스케줄링을 합니다. 따라서 선점형 스케줄링이며 현재 실행중인 프로세스의 남은 CPU버스트 시간보다 더 짧은 CPU버스트시간을 가지는 프로세스가 도착하면 CPU를 빼앗깁니다. 즉 잔여시간을 우선으로 하는 스케줄링 방식입니다.<br>
<br>
Priority Scheduling은 우선순위대로 CPU를 할당해주는 스케줄링으로 비선점형,선점형 방식으로 각각 구현할 수 있습니다. 선점형 스케줄링 방식에서는 더 높은 우선 순위의 프로세스가 도착하면 그 프로세스에게 CPU를 빼앗기고 비선점형 스케줄링 방식에서는 더 높은 우선순위의 프로세스가 도착하더라도 그 프로세스는 우선 ready queue에 위치하게 됩니다.<br>
우선순위가 높은 프로세스가 계속 도착하는 상황에서는 우선순위가 낮은 프로세스는 CPU를 얻지 못한 채 계속 기다려야하는 starvation 문제가 발생할 수 있습니다.<br>
이는 보통 aging 기법으로 해결할 수 있는데, aging 기법이란 오래 기다린 프로세스에게 우선순위를 높여주는 방법입니다.<br>
<br>
마지막으로 Round-Robin 방식은 시분할 시스템의 성질을 가장 활용한 스케줄링 방식으로, 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간을 특정 시간으로 제한하고, 시간 경과 시 해당 프로세스로부터 CPU를 회수해 준비 큐에 줄 서 있는 다음 프로세스(준비 큐 맨앞)에게 CPU를 할당하는 방식입니다.<br>
이러한 라운드 로빈의 경우에는 프로세스의 CPU 사용량에 비례해 소요시간이 증가해 공평성을 중시하는 스케줄링 방법으로 평균 응답시간(버스트 시간 긴놈이 빠르게 받을 수 있기에)이 빠르다는 장점이 있습니다.<br>
<br>
참고
CPU 버스트가 짧은 프로세스가 CPU 버스트가 긴 프로세스 보다 나중에 도착해 오랜 시간을 기다려야 하는 현상을 콘보이 현상(Convoy Effect)<br>
라운드 로빈에서 만약 할당 시간을 너무 크게 한다면 FCFS처럼 동작하게 되고, 너무 짧다면 Context Switching(문맥 교환) 오버헤드가 커지기 때문에 적절한 시간을 할당하는 것이 중요합니다!<br>
<br>
꼬리질문 1 - 어떠한 경우 선점형, 어떠한 경우 비선점형을 쓰는것이 좋은가요?<br>
빠른 응답시간이 필요하거나 새로운 고 우선순위 작업을 즉시 처리해야 하는 경우 선점형 스케줄링을 사용하고, 예측 가능한 스케줄링이 필요하거나 오버헤드(스위칭)를 최소화해야 하는 경우 비선점형 스케줄링을 사용하는 것이 좋습니다.<br>
</details>

<details markdown = "1">
<summary>MLQ 스케줄링 알고리즘과 MLFQ 스케줄링 알고리즘의 차이점은 무엇인가요?</summary>
MLQ(Multi Level Queue)와 MLFQ(Multi Level Feed Back)는 여러 개의 큐를 이용하고, 각 큐(대기열)에 별도의 스케줄링 알고리즘을 사용할 수 있는 방식입니다.(ex: 하나의 대기열엔 RR, 하나는 FCFS)<br>
MLQ에서는 프로세스의 우선순위가 사전에 정적으로 결정되며, 한번 큐에 할당된 프로세스는 그 큐에서 실행이 완료될 때까지 다른 큐로 이동하지 않습니다.<br>
반면에 MLFQ에서는 프로세스의 우선순위가 동적으로 결정됩니다. 이는 프로세스의 실행 상황(CPU 버스트 시간의 길이, I/O 요청의 빈도 등)에 따라 우선순위를 조정하며, 프로세스가 실행 중에 우선순위가 높아질 경우 더 높은 우선순위의 큐로 이동할 수 있게 됩니다(할당받을 가능성이 더 높아짐).<br>
<br>
꼬리질문 - 왜 이렇게 여러개의 큐를 두는 것이죠??
여러 개의 큐를 사용하는 이유는 프로세스의 우선순위와 요구 사항에 따라 유연하게 스케줄링을 수행하기 위해서입니다.<br>
예를 들어, CPU 집중적인 프로세스와 I/O 집중적인 프로세스가 같은 큐에 있다면, CPU 집중적인 프로세스가 계속해서 CPU를 점유할수 있고 이에 따라 I/O 작업이 필요한 프로세스는 기아 상태에 빠질 수 있습니다. 그래서 이런 상황을 피하기 위해 여러 개의 큐를 두고 각 큐에 대한 스케줄링 알고리즘을 다르게 설정하는 것입니다<br>
<br>
</details>

<details markdown = "1">
<summary>비선점과 선점 SJF 스케줄링 알고리즘에 대해 설명해주세요.</summary>
둘다 CPU 점유시간이 짧은 순서대로 프로세스를 처리하는 방식입니다. 하지만 선점형의 경우엔 작업을 하고 있는 동안에 실행 시간이 짧은 프로세스가 도착하면, 작업을 멈추고 도착한 프로세스에게 CPU를 넘겨줍니다.<br>
비선점형 SJF 방식은 실행시간이 짧은 프로세스가 계속 도착하는 경우 기아현상이 발생할 수 있고, 선점형 SJF는 잦은 context switching으로 인한 성능저하의 문제점이있습니다.(선점형도 역시 기아현상 가능)<br>
</details>

## 입출력 관련 질문
<details markdown = "1">
<summary>입출력이란 무엇인가요?</summary>
외부 장치로부터 필요한 외부 장치로 부터 필요한 데이터를 받아 프로그램에서 사용하는 메모리에 저장하거나, 메모리에 있는 데이터를 외부 장치로 보내는 것을 뜻합니다.<br>
<br>
</details>

<details markdown = "1">
<summary>동기식 입출력과 비동기식 입출력의 차이에 대해 아시나요?</summary>
동기식 입출력에서는 I/O 작업이 완료될 때 까지 프로세스가 대기 상태를 유지하는 반면, 비동기식 입출력에서는 I/O 작업을 요청한 후, 그 작업의 완료를 기다리지 않고 바로 다음 작업으로 넘어갑니다.<br>
동기식 입출력은 CPU가 낭비된다는 단점이 있으므로, 보통 기다리는 시간 동안 CPU 제어권은 다른 프로세스에게 넘어가게 됩니다. 반면 비동기식 입출력은 시스템 콜로 운영체제에게 입출력 명령을 부탁한 뒤 다시 바로 CPU 제어권을 얻습니다.<br>
<br>
</details>

## 인터럽트 관련 질문
<details markdown = "1">
<summary>인터럽트란 무엇이고 왜 필요한가요?</summary>
인터럽트는 주변 장치나 입출력 장치가(정확하게는 입출력 장치의 컨트롤러) CPU 서비스를 필요로 할때 신호를 발생시켜 서비스를 요청하는 메커니즘입니다.<br>
예를 들어, 하드디스크에서 데이터를 읽는 작업을 CPU가 요청을 했다면, CPU는 작업이 완료될 때 까지 기다리는 대신, 다른 작업을 계속해서 수행할 수 있습니다.<br>
이후 하드디스크가 데이터를 읽기 작업을 완료하면 (컨트롤러에서) 인터럽트를 발생시켜 CPU에 알립니다. 이러한 방식으로 CPU의 효율성을 높일 수 있습니다.<br>
<br>
참고 - 컨트롤러란 장치내 작은 CPU로 인터럽트를 발생시켜 CPU에 보고를 하는 역할<br>
로컬 버퍼 - 컨트롤러 내에 위치하며, 장치로 부터 들어오고 나가는 데이터의 임시 저장을 위한 작은 메모리<br>
<br>
꼬리질문 1 - 인터럽트가 발생한 후 어떻게 프로세스는 다시 이어서 실행하나요?<br>
인터럽트가 발생하면, CPU는 먼저 현재 수행 중이던 작업의 상태를 저장합니다. 그리고 인터럽트 요청을 처리한 후, 인터럽트가 발생하기 직전의 상태를 복구시키면서 중단되었던 작업을 재개하게 됩니다. 이렇게 함으로써, CPU는 인터럽트에 반응하면서도 본래의 작업을 계속 수행할 수 있습니다<br>
<br>
꼬리질문 2 - 인터럽트 처리루틴이란 무엇인가요?<br>
인터럽트 처리루틴은 운영체제가 각 인터럽트의 종류마다 가지고 있는 처리 절차입니다. 예를 들어, 키보드에서 입력이 들어오면, 운영체제는 키보드 인터럽트 처리루틴을 실행시켜 키보드로부터 입력받은 내용을 메모리의 특정 부분에 저장하고 해당 프로그램에 키보드 입력이 들어왔음을 알립니다. 이런 방식으로 운영체제는 다양한 인터럽트에 대응할 수 있습니다.<br>
<br>
꼬리질문 3 - CPU는 인터럽트가 발생했을 때 이를 어떻게 인지하나요?<br>
CPU는 명령하나를 수행할때마다 인터럽트가 발생했는지 인터럽트 라인을 확인하게 됩니다.<br>
이때 인터럽트 신호가 있다면, CPU는 다음 명령을 수행하기 전 인터럽트 처리를 하게 되고, 그렇지 않으면 다음 명령을 계속 수행하게 됩니다.<br>
</details>

<details markdown = "1">
<summary>인터럽트 종류에는 어떤 것들이 있을까요?</summary>
인터럽트의 종류에는 하드웨어 인터럽트와 소프트웨어 인터럽트가 있습니다.<br>
이 둘은 CPU의 서비스가 필요한 경우, CPU 옆에 있는 인터럽트 라인에 신호를 보내어 인터럽트가 발생했다는 것을 알려주는것은 동일하나, 하드웨어 인터럽트는 컨트롤러등 하드웨어 장치가 인터럽트 라인을 세팅하는 반면, 소프트웨어 인터럽트는 소프트웨어가 인터럽트를 세팅한다는 차이점이 있습니다.<br>
소프트웨어 인터럽트는 trap이라는 용어로 주로 불리며 예외상황, 시스템 콜 등이 있습니다.<br>
하드웨어 인터럽트는 보통 IO 디바이스에서 발생하는 인터럽트 뜻합니다.(ex: 키보드 연결, 마우스 연결)<br>
소프트웨어 인터럽트 중 예외상황이란 사용자 프로그램이 0으로 나누는 연산 등 비정상적 작업을 시도하거나, 자신의 메모리 영역 밖을 접근하려는 등 권한 없는 작업을 시도할때, 이에 대한 처리를 위해 발생시키는 인터럽트 입니다.<br>
시스템콜은 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법입니다.<br>
<br>
참고- 예외상황 시스템콜 모두다 인터럽트를 발생시킨 후 CPU의 제어권이 운영체제로 넘어감<br>
</details>

<details markdown = "1">
<summary>인터럽트가 발생한 후 동작 방식에 대해 설명해주세요.</summary>
예를들어 B라는 프로그램이 실행 중에 I/O 작업이 필요해 시스템 콜을 통해 작업을 요청한 후 대기 상태(봉쇄 상태)에 있고, 현재 CPU는 A라는 프로그램을 실행 중이라고 가정해 보겠습니다.<br>
장치(ex: 디스크)의 컨트롤러가 B 프로그램에 작업을 완료 시키면, CPU에게 인터럽트를 발생시킵니다.<br>
CPU는 인터럽트를 받으면, 우선 현재 실행 중인 프로그램 A의 상태를 저장해야 합니다.<br>
이를 위해 CPU는 프로그램 A의 정보들, 예를 들어 PC(CPU가 수행해야할 메모리 주소를 담고 있는 레지스터)나 레지스터 정보등을 PCB에 저장합니다. 이는 나중에 프로그램 A의 작업을 재개하기 위함입니다.<br>
그런 다음에, CPU의 제어는 현재 실행 중인 프로그램에서 인터럽트를 처리하기 위한 처리루틴으로 전환됩니다.이때 CPU의 제어가 현재 프로그램에서 다른 프로그램(여기서는 처리루틴)으로 넘어가는 것을 컨텍스트 스위칭이라고합니다.<br>
이제 CPU는 해당 인터럽트를 처리하는 루틴을 수행하게 됩니다. 이 루틴은 일반적으로 운영체제 커널의 일부로, I/O 작업의 결과를 메모리에 적재하는 등의 작업을 수행합니다.(이때 blokced를 ready 상태로 바꾸는 것도 함)<br>
인터럽트 처리 완료후엔 앞서 저장했던 PCB에서 프로그램 A의 정보를 불러와 CPU에 복원합니다.<br>
복원 후에 CPU는 프로그램 A의 작업을 이어서 수행할 수 있게 됩니다.<br>
<br>
참고<br>
레지스터란 무엇인가 - CPU내부에 있는 빠른 저장 공간으로 계산에 사용되는 데이터나 중간 결과를 보관하고 있다. 이의 예로는 PC, 명령어 레지스터, 누산기, 일반 레지스터 등이 있다.<br>
PC란 현재 CPU가 실행중인 명령어의 주소를 가리키는 레지스터입니다.<br>
PCB는 운영체제가 각 프로세스를 관리하기 위해 사용하는 자료구조로, 실행 중인 코드의 메모리 주소와 레지스터 및 PC의 값들이 저장됩니다.<br>
</details>

## 메모리 및 가상 메모리 관련 질문
<details markdown = "1">
<summary>기준 레지스터와 한계 레지스터가 무엇인지 설명하고, 이들을 어떻게 이용해 메모리 보호를 수행하는지 설명해주세요(ex: 영역 밖에 접근하려할때).</summary>
기준 레지스터와 한계 레지스터는 운영체제의 메모리 보호 방법에 사용되는 두 가지 레지스터입니다.<br>
기준 레지스터는 프로그램이 접근할 수 있는 메모리 상의 가장 작은 주소를 저장하고, 한계 레지스터는 그 프로그램이 기준 레지스터 값부터 접근할 수 있는 메모리의 범위를 보관하고 있습니다. 따라서 프로그램은 기준 레지스터의 주소부터 기준 레지스터의 값과 한계 레지스터 값을 더한 주소 사이의 영역에만 접근할 수 있습니다. 만약 이 범위를 넘어서는 메모리 영역에 접근하려고 하면, 운영체제는 예외 상황으로 처리하고, 프로그램을 강제 종료시키는 등의 처리를 합니다.<br>
이렇게 하면, 프로그램이 메모리의 허가되지 않은 영역, 예를 들어 다른 프로그램이나 운영체제가 위치하는 영역 등에 침범하는 것을 방지할 수 있습니다. 다만 이 방법은 프로그램이 메모리의 한 영역에 연속적으로 위치할 경우에만 사용할 수 있습니다.<br>
<br>
참고<br>
그리고 메모리 접근 명령 자체는 특권 명령이 아니지만, 기준 레지스터와 한계 레지스터의 값을 설정하는 연산은 특권 명령입니다. 그래서 운영체제만이 기준 레지스터와 한계 레지스터 값을 변경할 수 있고, 사용자 프로그램은 이 값들을 변경할 수 없습니다. 이렇게 함으로써 보안을 유지할 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>물리적 주소와 논리적 주소(가상 주소)의 차이는 무엇인가요?</summary>
가상 주소는 프로세스의 관점에서 볼때의 메모리 주소로, 프로세스가 메모리를 참조할 때 사용하는 주소입니다.<br>
이러한 주소는 프로세스가 생성될 때 부터 시작되며, 0번지 부터 시작됩니다.<br>
반면 물리적 주소는 실제 시스템 메모리에서 데이터가 위치한 주소를 의미합니다. 주소 바인딩 과정(MMU가 진행)을 통해 논리적 주소는 물리적 주소로 변환됩니다.<br>
<br>
참고 - 동일한 가상 주소 값이 더라도 각 프로세스마다 서로 다른 내용을 담고 있다.<br>
</details>

<details markdown = "1">
<summary>동적 로딩과 스와핑에 대해 아시나요?</summary>
동적 로딩(주로 다중 프로그래밍 상황에서)이란 프로세스가 시작될 때, 그 프로세스의 주소 공간 전체를 메모리에 올려 놓는 것이 아니라, 해당 부분이 불릴때 그 부분만을 메모리에 적재하는 방식입니다.<br>
그리고 스와핑은 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑영역에 일시적으로 내려놓는 것을 말합니다.<br>
(종료가 아닌 특정 이유로 인해, ex: 너무 많은 프로그램이 메모리에 동시에 올라와 성능이 떨어지는 경우 막기 위해)<br>
<br>
참고 - 그냥 링킹은 개발자가 작성한 소스 코드를 컴파일하여 생성된 목적 파일과 이미 컴파일된 라이브러리 파일을 묶어 하나의 실행파일을 생성하는 과정<br>
참고 - 동적 linking(연결)이란 컴파일을 통해 생성된 파일과 라이브러리 파일 사이의 연결을 프로그램 실행 시점까지 지연시키는 기법입니다.<br>
이때 실행 파일의 라이브러리 호출 부분에 스텁이라는 작은 코드를 두고, 라이브러리 호출시 스텁을 통해 해당 라이브러리가 메모리에 존재하는지 살펴보고, 존재한다면 메모리 위치를 직접 참조하고, 그렇지 않은 경우엔 디스크에서 라이브러리 파일을 찾아 메모리에 적재 후 수행하는 것입니다.<br>
</details>

<details markdown = "1">
<summary>외부 단편화와 내부 단편화에 대해 설명해주세요(Fragmentation)</summary>
외부 단편화란 메모리의 물리적인 공간에서 발생하는 문제로, 여러 프로세스들이 메모리에 할당되고 해제되는 과정에서 남은 메모리 조각들이 프로세스에 필요한 공간보다 작아 사용하지 못하는 상황을 말합니다.<br>
이 문제는 메모리 공간이 충분하더라도 연속적이지 않은 여러 공간으로 나뉘어져 있어 원하는 크기의 메모리를 할당받을 수 없는 상황을 초래합니다.<br>
내부 단편화는 메모리 블록 내부에서 발생하는 문제로, 할당된 메모리 블록 내에서 프로세스가 실제로 사용하지 않는 메모리가 남아있는 상황을 말합니다.<br>
예를들어 프로세스가 100바이트의 메모리를 필요로 하지만, 시스템이 128바이트 블록을 할당하면, 28바이트는 사용되지 않고 남아 내부 단편화를 초래합니다.<br>
<br>
외부 단편화 - 컴팩션으로 해결가능<br>
컴팩션이란 메모리 내의 모든 프로세스들을 재배치하여 메모리 공간을 연속적으로 만드는 것<br>
<br>
외부 단편화 이해 예시<br>
예를 들어, 우리가 가지고 있는 메모리가 1,000바이트라고 가정합시다. 이 때, 첫 번째 프로세스가 200바이트를 필요로 하므로 운영 체제는 이 프로세스에게 첫 200바이트를 할당합니다. 이어서 두 번째 프로세스가 300바이트를 필요로 하면, 이 프로세스는 다음의 300바이트(즉, 201-500바이트)를 할당받습니다. 그런 다음 세 번째 프로세스가 400바이트를 요구하면, 그것은 다음의 400바이트(즉, 501-900바이트)를 할당받습니다.
이 상태에서 첫 번째 프로세스와 두 번째 프로세스가 종료되어 해당 메모리를 반납하게 되면, 500바이트(1-200바이트와 201-500바이트)의 메모리가 사용 가능해집니다. 이 시점에서 새로운 프로세스가 400바이트의 메모리를 요청하면, 운영 체제는 충분한 메모리가 있다고 판단하고 이를 할당하려고 할 수 있습니다.
그러나 문제는 이 500바이트가 연속적인 블록이 아니라 200바이트와 300바이트 두 개의 분리된 블록으로 존재한다는 것입니다. 만약 새로운 프로세스가 400바이트의 연속적인 메모리를 필요로 한다면, 이 프로세스는 메모리를 할당받지 못하게 됩니다. 이렇게 충분한 메모리가 있음에도 불구하고 연속적이지 않은 메모리 공간 때문에 메모리를 할당받지 못하는 상황이 바로 외부 단편화를 의미합니다.<br>
</details>

<details markdown = "1">
<summary>연속 메모리 할당에서 고정 분할 방식과 가변 분할 방식에 대해 설명해주세요.</summary>
연속 할당 방식은 각각의 프로세스를 물리적 메모리의 연속적인 공간에 올리는 방식으로, 물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적대되도록 합니다.<br>
고정 분할 방식은 물리적 메모리를 정해진 개수 만큼의 영구적인 분할로 나누어 두고, 각 분할에 하나의 프로세스를 적재하는 방식입니다.<br>
이는 프로세스를 분할된 메모리에 할당하는 과정에서 내부/외부 단편화가 발생할 수 있습니다.<br>
가변 분할 방식은 프로세스가 필요한 만큼 메모리를 동적으로 할당하는 방식입니다.<br>
프로세스에 딱 맞게 메모리 공간을 사용하기 때문에 내부 단편화는 발생하지 않지만, 프로세스의 할당 및 해제가 반복되면 사용가능한 메모리 공간이 흩어지게 되고, 외부 단편화가 발생할 수 있으며, 이때 외부 단편화가 발생할 수 있습니다.<br>
이러한 외부 단편화를 해결하기 위해 흩어진 메모리 공간을 한쪽으로 몰고 가용 공간을 확보하는 컴팩션이라는 방법이 있으나 overhead가 많이 발생하는 단점이 있습니다.<br>
<br>
추가 내용 - 불연속할당은 하나의 프로세스를 여러 물리적 메모리에 나누어 적재하는 방법이며 페이징, 세그먼테이션, 페이지드 세그먼테이션 기법 등이 있습니다<br>
가변 분할 방식에서는 프로세스를 메모리에 올릴때 물리적 메모리 내 가용 공간중 어떤 위치에 올릴것인지 다루어야 함(동적 메모리 할당 문제)<br>
</details>

<details markdown = "1">
<summary>가변 분할 방식에서의 메모리 배치 전략을 설명해주세요.</summary>
우선 최초적합(First Fit) 방법은 충분한 크기를 가진 첫번째 메모리 공간에 프로세스를 할당하는 방식입니다.<br>
이는 간단하고 overhead가 적게 발생하나 공간 활용률이 떨어질수 있습니다.<br>
최적 적합(Best Fit)는 프로세스가 할당될 수 있는 공간 중 가장 작은 곳을 선택하는 방식입니다.<br>
모든 메모리 공간을 탐색하기에 overhead가 많이 발생하며, 다수의 매우 작은 가용 공간들이 생성될 수 있지만, 공간적인 측면에서 효율적입니다.<br>
최악 적합(Worst Fit)은 프로세스가 할당도리수 있는 메모리 공간 중 가장 큰 곳을 선택한 방식입니다.<br>
이는 모든 메모리 공간을 탐색하기에 overhead가 크며, 활용하기 어려운 작은 크기의 공간이 생기는 것을 방지할 수 있지만, 큰 크기의 메모리 공간 확보가 어렵습니다.<br>
</details>

<details markdown = "1">
<summary>페이징 기법이란 무엇인가요??</summary>
페이징 기법이란 프로그램(or 프로세스 주소 공간)을 동일한 크기의 페이지 단위로 나누고 물리적 메모리도 동일 크기의 프레임으로 나눈 뒤 이 곳에 페이지를 적재하는 기법입니다.<br>
이러한 페이징 기법에서는 하나의 프로세스라 하더라도 페이지 단위로 물리적 메모리에 올리는 위치가 상이하므로 모든 프로세스가 각각의 주소변환을 위한 페이지 테이블을 가지게 되고, 이 테이블은 프로세스가 가질 수 있는 페이지의 개수만큼 주소 변환 엔트리를 가지고 있습니다.<br>
MMU(CPU와 물리 메모리 사이 위치 하드웨어)가 주소 변환을 위해 페이지 번호와 페이지 오프셋을 사용하여 물리적 주소의 위치를 알아냅니다. 페이지 번호를 인덱스로하여 페이지 테이블 접근 시 프로세스의 물리적 메모리 상 시작 위치를 얻고, 이 값에 오프셋을 더함으로써 논리적 주소에 대응하는 물리적 주소를 얻을 수 있습니다.<br>
이러한 주소 변환 과정에서 페이지 테이블에 접근하고, 실제 데이터에 접근하는 두번의 메모리 접근이 필요해, 이때 테이블 접근 오버헤드를 줄이기 위해 TLB라는 하드웨어가 사용되기도 합니다.<br>
여기서 TLB란 빈번히 참조되는 페이지에 대한 주소 변환 정보만을 담게 됩니다.<br>
이러한 페이징 기법을 활용하면 프로세스의 전체 주소 공간을 한번에 메모리에 올릴 필요가 없다는 장점을 가집니다. 각 페이지는 개별적으로 메모리에 로드되거나, 백킹 스토어(하드디스크, 주 메모리와 함께 사용하는 보조 저장장치)에 저장될 수 있습니다.<br>
이를 통해 메모리를 효율적으로 관리할 수 있게 해줍니다.<br>
<br>
꼬리질문 - 페이징 기법에서 단편화 현상이 발생하나요?<br>
페이징 기법에서는 프로세스를 동일한 크기의 페이지로 분할하고, 메모리도 같은 크기의 프레임으로 분할하므로 어떤 프레임에도 어떤 페이지가 할당될 수 있어 외부 단편화는 발생하지 않습니다.<br>
하지만 페이지 단위로 메모리를 할당하게 되면 마지막 페이지에서 프로세스가 모든 공간을 사용하지 않는 경우 내부 단편화가 발생할 수 있습니다.<br>
예를 들어, 페이지 크기가 4KB라고 가정하겠습니다. 만약 10KB 크기의 프로세스가 메모리에 로드된다면, 이는 세 개의 페이지 (4KB, 4KB, 2KB)로 분할됩니다. 여기서 마지막 2KB 페이지는 그 페이지의 나머지 2KB가 사용되지 않는 상태로 남아 있게 되므로, 이는 내부 단편화의 예시가 됩니다<br>
<br>
꼬리질문 2 - TLB가 무엇이죠?<br>
TLB(Translation Lookaside Buffer)는 하드웨어 캐시로서, 가장 최근에 참조된 페이지 번호와 해당 페이지의 물리 주소를 저장합니다. 페이지 주소 변환 요청이 있을 때, 먼저 TLB를 확인하여 빠르게 변환 정보를 얻을 수 있습니다. 만약 TLB에 해당 정보가 없다면 페이지 테이블을 참조하게 됩니다<br>
<br>
꼬리질문 3 - 페이징 기법을 사용하면 어떤 장단점이 있나요?<br>
페이징 기법의 장점으로는 메모리 관리의 유연성이 있습니다. 프로세스 전체를 메모리에 적재하지 않고 필요한 부분만 로드하여 메모리 사용을 최적화할 수 있습니다.<br>
 단점으로는 페이지 테이블 관리에 따른 오버헤드와 페이지 교체 알고리즘에 따른 복잡성이 있을 수 있습니다.<br>
<br>
참고 - CPU가 생성한 논리주소를 MMU에 전달함<br>
페이지 테이블은 주 메모리에 위치하고, MMU에 의해 관리됨<br>
페이지 테이블에는 번호 오프셋 빼고 보호비트(각 페이지 접근 권한)와 유효 무효 비트(해당 페이지 내용이 유효한지)를 둠<br>
</details>

<details markdown = "1">
<summary>세그멘테이션 기법에 대해 설명해주세요.</summary>
세그멘테이션이란 프로세스의 주소 공간을 의미 단위인 세그먼트로 나누어 물리적 메모리에 올리는 기법입니다.<br>
세그멘테이션 기법에서 주소 변환 과정은 페이징 기법과 유사하나 세그멘테이션 기법의 경우 세그먼트 크기가 각각 다르기 때문에 세그먼트 테이블에는 세그먼트 번호에 따른 시작 주소(베이스)뿐만 아니라, 길이(리미트)정보가 담겨있습니다.<br>
이때 오프셋 값이 세그먼트의 길이를 넘어서는 경우에는 잘못된 주소로 판단하고 시스템이 예외를 발생시킵니다.<br>
그렇지 않다면 베이스 값과 오프셋 값을 사용하여 물리적 주소의 위치를 알아냅니다.<br>
이러한 세그먼트 방식은 의미 단위로 나누어져 있기 때문에 공유와 보안의 측면에서 페이징 기법에 비해 훨씬 효과적입니다. 예를 들어 페이지 기법에서 동일한 크기로 주소 공간을 나누다 보면 공유하려는 코드와 사유 데이터 영역이 동일 페이지에 공존하는 경우가 발생할 수 있습니다.<br>
반면 세그멘테이션 기법에서는 이러현 현상이 발생하지 않으므로 공유나 보안처럼 의미 있는 단위에 대해 수행하는 업무에서는 페이징 기법보다 세그멘테이션 기법이 장점을 가집니다.<br>
하지만 세그멘테이션 방식은 세그먼트의 크기가 균일하지 않기 때문에 메모리 관리에서 외부 조각이 발생하게 되며, 어떤 가용 공간에 세그먼트를 할당할 것인지 결정하는 문제가 생깁니다.<br>
이 문제는 가변 분할 방식에서 발생하는 문제와 유사하여, 최초 적합 또는 최적 적합과 같은 방식을 사용해 해결할 수 있습니다.<br>
<br>
꼬리질문 1 - 세그멘테이션에서 외부 단편화가 발생할 수 있나요?<br>
세그멘테이션 기법에서는 각 세그먼트의 크기가 다르기 때문에 메모리를 할당하고 해제하는 과정에서 이러한 외부 조각이 발생할 수 있습니다.<br>
<br>
꼬리질문 2 - 세그멘테이션 기법에서는 어떻게 메모리 보호를 구현하나요?<br>
세그멘테이션 기법에서는 세그먼트 테이블의 각 항목에 보호비트와 유효비트를 둠으로써 메모리 보호를 구현합니다. 보호 비트는 각 세그먼트에 대해 읽기, 쓰기, 실행 등의 권한이 있는지를 나타내며, 유효비트는 해당 세그먼트의 주소 변환 정보가 유효한지, 즉 해당 세그먼트가 현재 물리적 메모리에 적재되어 있는지를 나타냅니다.<br>
<br>
꼬리질문 3 - 페이지 세그멘테이션에 대해 아시나요?<br>
페이지드 세그멘테이션 방법은 페이징과 세그멘테이션이라는 두가지 메모리 관리 기법을 결합한 것입니다.<br>
세그먼테이션 기법과 마찬가지로 프로세스를 여러 개의 세그먼트로 나누지만 이때 세그먼트 들이 임의의 길이를 가질 수 있는 것이 아니라 반드시 동일한 크기 페이지들의 집합으로 구성되어야 합니다.<br>
즉 페이지드 세그먼테이션 기법에서는 하나의 세그먼트 크기를 페이지 크기의 배수가 되도록 함으로써 세그먼테이션 기법에서 발생하는 외부 조각 문제점을 해결하는 동시에 세그먼트 단위로 프로세스 간의 공유나 프로세스 내의 접근권한 보호가 이루어지도록 함으로써 페이징 기법의 약점을 해소합니다.<br>
<br>
가정해봅시다. 페이지의 크기를 4KB로 정하고, 우리가 두 개의 세그먼트를 가진 프로세스를 메모리에 로드하려고 합니다. 이때 하나의 세그먼트는 7KB이고, 다른 하나는 13KB라고 가정해봅시다.

페이지드 세그멘테이션 기법에서는 각 세그먼트가 페이지 크기의 배수가 되도록 만듭니다. 따라서 첫 번째 세그먼트는 4KB 페이지 2개로 분할되며, 두 번째 세그먼트는 4KB 페이지 4개로 분할됩니다. 이렇게 되면, 우리는 세그먼트를 각각 8KB와 16KB로 취급할 수 있습니다. 이는 페이지의 크기(4KB)의 배수이며, 따라서 세그멘테이션 기법에서 발생하는 외부 조각 문제를 해결합니다.<br>
<br>
어떤 경우 세그멘테이션 어떤 경우 페이징 - 공유와 보안이 중요한 경우에는 세그멘테이션 기법을, 메모리의 효율적인 활용과 쉬운 관리가 중요한 경우에는 페이징 기법을 선호<br>
</details>

<details markdown = "1">
<summary>가상 메모리에 대해 설명해주세요.</summary>
가상 메모리란 실제 물리적 메모리의 크기를 초과하는 프로그램의 실행을 가능하게 하는 기법입니다. <br>
가상 메모리는 필요한 부분만을 실제 물리적 메모리에 올려 사용하고, 나머지 부분은 하드 디스크와 같은 저장 장치에 임시로 저장해둡니다. 이렇게 함으로써 더 큰 양의 메모리를 가지고 있는 것처럼 동작하게 됩니다.<br>
가상 메모리는 프로세스가 필요로 하는 페이지가 실제 메모리에 없는 경우, 즉 페이지 폴트가 발생하면, 이를 하드웨어로 부터 가져오는 I/O 작업이 발생하기에 성능 저하의 요인이 될 수 있습니다.<br>
이때 효율적인 페이지 교체 알고리즘을 사용하면 페이지 폴트 빈도를 줄일 수 있습니다.<br> 
<br>
참고<br>
OS는 프로세스들의 내용(페이지) 중에서 덜 중요한 것들을 하드디스크에 옮겨 놓고, 관련 정보를 페이지 테이블에 기록합니다. CPU는 프로세스를 실행하면서 페이지 테이블을 통해 페이지를 조회하는데, 실제메모리에 원하는 페이지가 없는 상황이 발생할 수 있습니다(Valid bit를 통해 확인)<br>
가상 메모리는 프로세스들이 독립적인 메모리 공간을 갖는 것처럼 느끼게 하여, 프로세스 간의 메모리 보호와 독립성을 제공하는 데도 중요한 역할을 합니다.<br>
페이지 교체 알고리즘이란 운영 체제에서 가상 메모리를 관리하는 방법 중 하나로, 물리적 메모리가 가득 찬 상황에서 새로운 페이지를 메모리에 로드해야 할 때 어떤 페이지를 교체해야 하는지 결정하는 방법을 정의합니다.<br>
가상 메모리 방식은 보통 요구 페이징 방식으로 구현됨
</details>

<details markdown = "1">
<summary>요구페이징이 무엇이죠?</summary>
요구 페이징이란 프로그램 실행 시 프로세스를 구성하는 모든 페이지를 한꺼번에 올리는 것이 아니라, 당장 사용될 페이지만 메모리에 올리는 방식을 말합니다.<br>
이러한 요구 페이징은 당장 필요한 페이지만을 메모리에 적재하기에 메모리 사용량이 감소합니다.<br>
각 페이지가 메모리가 존재하는지 판단하기 위해 요구 페이징에서 유효-무효 비트를 표시하게 되며, 이는 페이지 테이블에 저장되어있습니다.<br>
만약 CPU가 현재 참조하려는 페이지가 메모리에 있지 않다면 페이지 폴트가 발생하고, 이때 운영체제가 페이지 폴트 처리루틴을 거쳐 해당 페이지를 메모리에 적재하게 됩니다.<br>
<br>
1이면 해당 페이지가 메모리에 존재, 0이면 안존재
</details>

<details markdown = "1">
<summary>페이지 폴트가 무엇인지랑 처리 과정에 대해 설명해주세요.</summary>
페이지 폴트란 CPU가 참조하려는 페이지가 물리적 메모리에 없는 상황을 말합니다. 이때 페이지 폴트 예외를 발생시키며, 이를 처리하기 위해 페이지 폴트 처리 루틴이 호출됩니다.<br>
<br>
프로세스가 실행되면서 CPU가 특정 페이지에 접근하려할때, 먼저 해당 페이지가 메인 메모리에 있는지 확인해야합니다.<br>
이는 페이지 테이블에서 해당 페이지의 Valid bit를 확인함으로써 이루어지고, valid bit가 1이면 해당 페이지는 메모리에 존재하므로 CPU는 메모리에서 해당 페이지를 참조하여 연산을 수행합니다.<br>
<br>
만약 valid bit가 0, 즉 invalid 상태라면 MMU는 페이지 폴트 예외(페이지 폴트 트랩)를 발생시킵니다.<br>
그러면 커널모드로 전환되고, 운영체제의 페이지 처리 루틴이 호출됩니다. 이때 운영체제는 invalid한 경우가 메모리 경계를 넘는 것이나, 페이지에 대한 접근 권한을 위반한 경우엔 해당 프로세스를 종료시키고, 페이지 폴트라면 free frame을 할당받습니다.<br>
이때 만약 free frame이 없다면 페이지 교체 알고리즘을 바탕으로 swap out을 진행합니다.<br>
<br>
할당 받은 프레임에 페이지를 로드하기 위해 운영체제는 디스크에 I/O 요청을 하고, 페이지 부재를 발생시킨 프로세스는 CPU를 빼앗기고 봉쇄상태가 됩니다. 이때 PCB에 레지스터 상태 및 PC값을 저장함으로서 나중에 다시 CPU를 할당받았을 때 같은 상태에서 명령을 수행할 수 있습니다.<br>
<br>
이후 디스크에서 I/O가 완료되어 인터럽트가 발생하면 해당 페이지를 메모리에 적재하고, 페이지 테이블에서 해당 페이지의 비트를 valid(1)로 설정합니다.그리고 봉쇄 상태에 있던 프로세스를 ready 상태로 변경 시켜 준비 큐로 이동시킵니다.<br>
<br>
이후 이 프로세스가 다시 CPU를 할당받으면 PCB에 저장되어있던 값을 복원시켜 이전에 중단되었던 명령부터 실행을 재개합니다.<br>
<br>
꼬리 질문 1 - 페이지 폴트 발생 빈도를 줄이기 위해서는 어떻게해야할까요??<br>
서비스의 특성에 맞게 효과적인 페이지 교체 알고리즘을 선택하거나 페이지 크기를 적절히 선택함으로서 페이지 폴트 발생 빈도를 줄일 수 있습니다.<br>
그리고 메모리의 크기를 증가시키거나, 프로그램 코드를 최적화하여 자주 사용되는 데이터가 같은 페이지에 위치하도록 하는 방법도 있습니다.<br>
<br>
페이지가 너무 작으면 페이지 테이블이 커져 메모리 사용이 늘어나고, 페이지 폴트 빈도가 증가할 수 있습니다(한번에 로드할 수 있는 데이터 양이 적음, 공간지역성도 고려). 반대로 페이지가 너무 크면 내부 조각화 문제가 발생할 수 있습니다<br>
</details>

<details markdown = "1">
<summary>페이징 교체 알고리즘이 무엇인지랑 종류에 대해 설명해주세요.</summary>
페이징 교체 알고리즘이란 물리적 메모리가 가득 찬 상황에서 새로운 페이지를 메모리에 로드해야 할 때 어떤 페이지를 교체해야 하는지 결정하는 방법입니다.<br><br>
우선 선입선출 알고리즘(FIFO)은 페이지 교체시 물리적 메모리에 가장 먼저 올라온 페이지를 우선적으로 내쫓는 방식입니다.<br>
이는 페이지의 향후 참조 가능성을 고려하지 않기에 가장 먼저 메모리에 들어온 페이지가 계속해서 많은 참조가 이어지더라도 내쫓기게 됩니다.<br>
그리고 FIFO 알고리즘에서는 페이지 프레임 수를 증가 시켰음에도 페이지 부재가 더 많이 발생하는 이상현상 또한 발생할 수 있습니다.<br>
<br>
Optimal 알고리즘은 가장 먼 미래에 참조되는 페이지를 내보내는 알고리즘입니다. 이 알고리즘은 미래에 참조될 페이지를 모두 알고 있다고 가정하는 알고리즘이라 현실적으로 구현에 어려움이 있습니다.<br>
따라서 이는 보통 다름 알고리즘 성능의 상한선을 제공하는 역할을 하게 됩니다.<br>
<br>
LRU(Least Recently Used) 페이지 교체 알고리즘은 가장 오랫동안 사용되지 않은 페이지를 교체하는 방식입니다.<br>
프로그램은 보통 지역성 원칙에 따라 실행됩니다. 즉 특정 시간 동안 특정 부분을 집중적으로 참조하는 경향이 있습니다(시간 지역성).<br>
LRU 알고리즘은 이런 지역성 원칙을 활용하여 페이지 폴트 발생 확률을 감소시킨다는 장점이 있지만, 페이지 교체를 위해 페이지마다 사용된 시간을 기록해야 하기에 추가적인 메모리 공간이 필요합니다.<br>
<br>
LFU(Least Frequently Used) 페이지 교체 알고리즘은 가장 적게 사용된 페이지를 교체하는 방식입니다.(이 또한 지역성을 따름)<br>
이는 자주 사용되지 않는 페이지를 교체함으로서 메모리를 효율적으로 사용한다는 장점이 있지만, 페이지 사용횟수를 기록하기 위해 추가적인 메모리 공간이 필요하고<br>
처음에 자주 참조되던 페이지가 이후에는 거의 참조되지 않더라도, 초기에 높았던 참조 횟수때문에 메모리에 계속 유지될 수 있습니다. 즉 시간에 따른 페이지 참조변화를 반영하지 못합니다.<br> 
<br>
NUR(Not Used Recently)는 LRU를 근사시킨 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 방식입니다.<br>
LRU 알고리즘은 가장 오래전에 참조된 페이지를 교체하는 것에 비해 NUR는 오랫동안 사용하지 않은 페이지중 하나를 교체합니다.즉 교체되는 페이지의 참조시점이 가장 오래되었다는 것을 보장하지 못합니다.<br>
최근 참조 여부를 확인하기 위해 각 페이지 마다 참조 비트(참조되지 않은 경우 0, 참조된경우 1)와 변형 비트(페이지 내용 변경 X : 0, 변경 시 1)를 둡니다.
동작 방식에 대해 간단히 설명드리자면 운영체제가 일정 시간 간격으로 모든 페이지의 참조 비트를 검사하고, 이를 0으로 리셋합니다.이는 최근에 참조된 페이지를 판별하기 위해 진행되는 과정입니다.<br>
그리고 페이지가 참조될 때마다 참조 비트를 1로, 페이지가 수정될때마다 변형비트가 1로 설정됩니다.<br>
페이지 교체가 필요할때 운영체제는 두 비트 모두를 고려하여 교체 페이지를 선정합니다.이때 참조와 변형 비트가 둘다 0인 페이지가 최우선적으로 교체 대상이 되고,
만약 그런 페이지가 없다면 참조0,변형1 참조1,변형0, 참조1 변형 1 순서로 검색을 진행하여 교체 대상을 찾습니다.<br>
<br>
꼬리질문 1 - NUR는 변형 비트를 왜 사용할까??<br>
페이지를 디스크로 내릴 때 해당 페이지가 수정되었는지 아닌지 알면 효율성을 높일 수 있습니다.<br>
만약 페이지가 수정되지 않았다면 디스크에 이미 같은 내용의 페이지가 있을테니, 페이지를 디스크에 쓰지 않고 그냥 무시할 수 있습니다.<br>
반면 페이지가 수정된 경우에만 디스크에 쓰는 작업을 수행하면 됩니다. 이러한 방식으로 I/O 연산을 줄여 시스템 성능을 향상시킬 수 있습니다.<br>
<br>
꼬리질문 2 - NUR이 LRU, LFU에 비해 어떤 장점을 가지는가?<br>
LRU,LFU의 경우엔 각 페이지에 대한 메타데이터(참조에 대한 상세한 정뷰 유지 및 추적)를 유지(페이지가 언제 마지막으로 참조되었는지,페이지가 얼마나 자주 참조되었는지) 및 추적해야 하는 반면 
NUR 알고리즘은 2bit만 추가하여 LRU,LFU과 유사한 성능을 낼 뿐만아니라 쉽게 구현할 수 있다는 장점을 가집니다.
</details>

<details markdown = "1">
<summary>스레싱(thrashing)이 무엇인가요??</summary>
스레싱이란 할당받은 페이지 프레임의 크기가 작아서(프로세스가 너무 많이 올라와 있어서), 집중적으로 참조되는 페이지들의 집합을 메모리에 한꺼번에 적재하지 못하면서 페이지 폴트가 자주발생하고, 이에 따라 CPU 이용률이 급격이 떨어지는 상태를 말합니다.<br>
즉 스레싱은 페이지 폴트가 과도하게 발생하여 CPU가 실제 연산을 수행하기보다는 페이지를 교체하는 데 대부분의 시간을 소비하는 현상을 의미합니다. 이는 실제 메모리에 적재되어 있어야 할 페이지들이 대부분 디스크에 존재하므로 발생합니다.<br>
</details>

<details markdown = "1">
<summary>이러한 스레싱은 어떻게 해결할까요?</summary>
우선 메모리에 동시에 올라와 있는 프로세스를 수를 제한하여, 각 프로세스가 사용할 수 있는 메모리 공간을 증가시키는 것으로 해결할 수 있습니다.<br>
이를 통해 각 프로세스가 필요로 하는 페이지를 더 많이 메모리에 로드할 수 있을 것입니다.<br>
그리고 효율적인 페이지 교체 알고리즘을 사용하여 페이지 폴트 빈도를 줄이거나, 가능하다면 물리적 메모리 용량을 증가시킴으로서도 해결 할 수 있습니다(스레싱 발생 지점 늦춤).<br>
<br>
CPU 스케줄링, 가상 메모리를 통해서도 가능<br>
<br>
참고<br>
워킹셋 알고리즘은 지역성 집합(자주 참조되는 페이지 집합)이 메모리에 동시에 올라갈 수 있도록 보장하는 메모리 관리 알고리즘이며,
여기서 워킹셋이란 프로세스의 원할한 수행을 위해 한꺼번에 메모리에 올라와야 하는 페이지들의 집합을 말합니다. 이는 워킹셋을 구성하는 페이지들이 한꺼번에 메모리에 올라갈 수 있는 경우에만 그 프로세스에게 메모리를 할당하고, 그렇지 않은 경우엔 프로세스에게 할당된 페이지 프레임을 모두 반납시킨 후 그 프로세스의 주소 공간 전체를 디스크로 스왑아웃 시키는 방식으로 동작합니다.<br>
<br>
페이지 부재 빈도 알고리즘(PFF)는 프로세스의 페이지 부재율을 주기적으로 조사하고, 이 값에 근거해서 각 프로세스에 할당할 메모리 양을 동적으로 조절하는 알고리즘입니다.<br>
만약 어떤 프로세스의 페이지 부재율이 시스템에서 미리 정해둔 상한 값을 넘게된다면, 이 프로세스에게 프레임을 추가로 더 할당하고, 하한 값 이하로 떨어진다면 필요 이상의 많은 프레임이 할당된 것으로 간주해 프레임의 수를 줄이게 됩니다!<br>
</details>

## 디스크 관련 질문
<details markdown = "1">
<summary>디스크 스케줄링이 무엇이고 종류에 대해 설명해주세요.</summary>
디스크 스케줄링이란 운영체제에서 디스크 I/O 요청들을 어떤 순서로 처리할지 결정하는 알고리즘을 의미하고, 디스크 헤드의 이동 거리를 최소화 하는 것이 주 목적입니다.<br>
우선 FCFS 스케줄링은 디스크에 먼저 들어온 요청을 먼저 처리하는 방식으로 동작합니다.<br>
이는 입출력 요청이 한쪽 끝과 반대쪽 끝에 번갈아 도착한다면, 디스크가 계속 왕복해야 하기에 탐색 시간이 매우 길어질 수 있습니다.<br><br>
SSTF(Shortest Seek Time First) 스케줄링은 헤드의 현재 위치로부터 가장 가까운 위치에 있는 요청을 제일 먼저 처리하는 방식입니다.<br>
이때는 starvation 문제가 발생할 수 있습니다(ex : 가까운 곳에 요청만 지속적으로 올경우 먼 곳에 떨어진 요청은 무한히 기다려야 하는 상태 될수도).<br>
<br>
SCAN은 디스크의 안쪽 끝과 바깥쪽 끝을 오가며, 그 경로에 존재하는 모든 요청을 처리하는 방식입니다.(엘리베이터와 유사)<br>
이러한 SCAN 방식은 FCFS처럼 불필요한 헤드의 이동이 발생하거나, SSTF처럼 일부 지역이 지나치게 오래 기다리는 현상이 발생하지 않으나, 헤드가 가운데 위치를 지나가는 주기가 양끝을 지나가는 주기의 절반에 불과하기에 기다리는 시간이 공평하지 않을 수 있습니다.<br>
이를 해결하기 위해 생겨난 알고리즘이 C-SCAN 알고리즘입니다. 이는 SCAN 처럼 헤드가 한쪽 끝에서 다른 쪽 끝으로 이동하며 가는 길목에 모든 요청을 처리하지만, <br>
스캔과 달리 헤드가 다른쪽 끝에 도달해 방향을 바꾼 후에는 요청을 처리하지 않고 곧바로 출발점으로 이동합니다.(SCAN 보다 균일한 탐색시간)<br><br>

LOOK 알고리즘은 SCAN 알고리즘을 개선한 방법으로 헤드가 한쪽 방향으로 이동하다가, 그 방향에 더 이상 대기 중인 요청이 없으면 헤드의 이동 방향을 즉시 반대로 바꾸는 스케줄링 방식입니다.<br>
C-LOOK 알고리즘은 전방에 요청이 없을때 방향을 바꾼다는 측면에서 Look과 유사하지만, 한쪽 방향으로 이동할때만 요청을 처리한다는 점에서 차이를 보입니다.<br> 
ex) 예를들어 왼쪽끝에서 오른쪽 끝으로 이동할때만 요청 처리, 요청 처리후 디스크 헤드는 다시 왼쪽 끝으로 이돌아감(이때 요청을 처리하지 않음)<br>
<br>
참고 - 디스크 헤드의 이동거리 과정 <br>
디스크는 데이터를 저장하는 매체인 플래터(Platter)와, 데이터를 읽고 쓰는 장치인 헤드(Head)로 구성되어 있습니다. 디스크에서 데이터를 읽거나 쓰려면 디스크 헤드가 해당 데이터가 위치한 트랙(Track)에 도달해야 합니다<br>
디스크 헤드의 이동 거리를 최소화한다는 것은, 디스크 헤드가 데이터에 접근하기 위해 플래터 위에서 움직이는 거리를 줄이는 것을 의미합니다. 디스크 헤드의 이동 (Seek)은 디스크 I/O 작업에서 가장 시간이 많이 소요되는 부분이기 때문에, 이 이동 거리를 최소화함으로써 전체적인 디스크 I/O 성능을 향상시킬 수 있습니다.<br>
</details>


## 기타 질문
<details markdown = "1">
<summary>커널 모드와 사용자 모드의 차이에 대해 간단히 설명해주세요.</summary>
커널 모드는 운영체제가 CPU를 제어하고 있을 때에 해당합니다. 여기에서 운영체제는 코드가 실행되며, 모든 종류의 명령, 특히 하드웨어를 직접 제어하는 등의 특권 명령을 수행할 수 있습니다.<br>
반면 사용자 모드는 사용자 프로그램이 CPU의 제어권을 가지고 제한적인 명령만 실행할 수 있는 모드입니다.<br>
사용자 프로그램이 특권 명령을 실행 하기 위해서는 운영체제에게 이 명령을 대신해줄 것을 요청하는데, 이를 시스템 콜이라고 합니다.<br>
즉 프로그램이 자신의 주소 공간 내에 있는 함수가 아닌 커널의 함수를 호출하는 것을 뜻합니다.<br>
<br>
특권 명령 - 사용자 프로그램이 사용했을 때 큰 문제가 발생할 수 있는 명령으로, 보안 과 관련되어있으며 mode bit가 0일때 사용 가능
</details>

<details markdown = "1">
<summary>시스템 콜이란 무엇인가요?</summary>
시스템 콜(system call)은 사용자 모드에서 실행되는 프로그램이 운영체제의 서비스를 요청하기 위한 일종의 인터페이스입니다. 사용자 모드에서 실행되는 프로그램이 보안이 필요한 작업을 수행하거나 하드웨어와 같은 시스템 자원에 접근하고자 할 때 직접적으로 이를 수행할 수 없기 때문에, 운영체제가 이런 작업을 대신해주도록 요청하는데 이것이 바로 시스템 콜입니다.<br>
예를 들어, 파일을 열거나 네트워크 통신을 하고자 하는 등의 작업이 시스템 콜을 통해 이루어지게 됩니다. 시스템 콜을 사용하면 운영체제는 프로그램에 필요한 서비스를 제공하면서도, 보안을 유지하고 시스템의 안정성을 보장할 수 있습니다.<br>
<br>
이거 또한 인터럽트처럼 인터럽트 라인에 인터럽트를 세팅함으로서 이루어짐.
</details>

<details markdown = "1">
<summary>시스템 콜을 발생시킨 후 어떤 과정이 발생하나요?</summary>
사용자 프로그램이 시스템 콜을 호출하면 (예: 디스크로 파일을 읽어오는 경우), CPU의 제어권이 운영체제로 넘어갑니다. 이때 사용자 프로그램의 상태, 즉 프로세스의 컨텍스트(Context)는 프로세스 제어 블록(Process Control Block, PCB)에 저장됩니다.<br>
다음으로 CPU는 커널 모드로 전환되고, 운영체제는 시스템 콜에 해당하는 서비스 루틴을 실행합니다. 예를 들어, 디스크에서 파일을 읽어오는 시스템 콜의 경우, 운영체제는 디스크 컨트롤러에게 해당 파일을 읽어오라는 명령을 내립니다<br>
만약 시스템 콜이 블로킹 연산이라면, 해당 시스템 콜을 호출한 프로세스는 봉쇄 상태로 전환되며, CPU 제어권은 다른 프로세스에게 넘어갑니다. 시스템 콜이 완료되면, 원래의 프로세스는 준비 상태(ready state)가 되고, 스케줄러에 의해 다시 실행 상태(running state)로 전환될 수 있습니다<br>
반면, 시스템 콜이 논-블로킹 연산이라면, 해당 시스템 콜을 호출한 프로세스는 제어권을 즉시 다시 얻게 되고, 다른 작업을 계속 수행할 수 있습니다.<br>
<br>
블로킹 - 특정 작업이 완료될때까지 프로그램의 실행이 멈춤. 이 시간 동안 프로세스는 CPU를 사용하지 않고, 다른 CPu가 사용할 수 있도록 봉쇄상태<br>
논블로킹 - 특정 작업(예: 입출력 요청)이 완료되지 않더라도 프로그램의 실행이 계속됩니다. 이 방식에서는 작업의 완료 여부와 관계 없이 즉시 제어가 프로그램으로 돌아갑니다<br>
이 경우, 프로세스는 시스템 콜의 결과를 나중에 확인하게 될 수도 있습니다.<br>
</details>

<details markdown = "1">
<summary>모드 비트가 무엇인지 설명해주세요.</summary>
모드 비트(mode bit)는 CPU의 상태를 나타내는 비트로서, 현재 CPU가 어떤 모드에서 실행되고 있는지를 표시합니다. 일반적으로 이 비트는 1 또는 0의 값을 가질 수 있습니다.<br>
모드 비트가 0일 경우, CPU는 커널 모드(Kernel Mode)에서 실행되고 있는 것으로, 모든 종류의 명령어를 실행할 수 있는 상태를 나타냅니다. 이 모드에서는 입출력 관리, 메모리 관리, 파일 시스템 관리 등의 중요한 시스템 연산을 수행할 수 있습니다.<br>
반면, 모드 비트가 1일 경우, CPU는 사용자 모드(User Mode)에서 실행되고 있는 것으로, 제한된 명령어만 실행할 수 있는 상태를 나타냅니다. 이 모드에서는 일반적인 프로그램 실행을 수행하며, 보안이 필요한 작업이 필요할 경우 시스템 콜을 통해 이를 커널 모드로 전환하여 수행하게 됩니다.<br>
따라서 모드 비트는 운영체제가 사용자 프로그램과 시스템의 민감한 자원 간의 보안을 유지하면서도 필요한 작업을 수행할 수 있도록 하는 중요한 역할을 합니다.<br>
<br>
사용 이유 - 사용자 프로그램이 CPU 제어권을 가지고 있을 때 운영체제가 이를 제어하지 못하므로<br>
</details>

<details markdown = "1">
<summary>시분할 시스템(Time Sharing)이란 무엇이죠??</summary>
시분할 시스템이란 다중 사용자 지원을 위해 컴퓨터 응답 시간을 최소화하는 시스템입니다. 이때 응답 시간을 최소화 하기 위해 각 응용 프로그램이 CPU를 점유하는 시간을 잘게 쪼개어 실행 될 수 있게 해줍니다.<br>
이를 통해 각 사용자는 독립적인 컴퓨팅 환경을 가진것 처럼 느낄 수 있습니다.<br>
(만약 100시간 짜리 프로세스가 1,2시간 짜리 보다 먼저 등록되었다면??? 비효율적 -> 이를 해결하기 위해 등장)<br>
<br> 
유사 질문 1 - 멀티 태스킹이란 무엇인가??<br>
단일 CPU 환경에서 여러 응용프로그램이 동시에 실행되는 것처럼 보이게 하는 시스템입니다.<br>
이때 응답시간 ~~~ (위랑 똑같이 대답)<br>
<br>
참고 -  멀티태스킹은 시분할 시스템과 목표는 다르지만, 결과적으로 구현방식은 거의 동일한 시스템이라고 이해<br>
<br>
유사질문 2 - 멀티 프로그래밍이란 무엇인가??<br>
멀티 프로그래밍이란 메모리에 여러 프로그램을 동시에 올리는 기능입니다. 이를 통해 CPU가 한 프로그램에서 다른 프로그램으로 빠르게 전환함으로써,CPU의 이용률을 극대화할 수 있습니다.<br>
<br>
만약 예시를 들어보라 할 경우<br>
예를들어 만약 프로그램이 입출력 작업을 수행한다면, 이는 CPU처리 속도에 비해 느리기 때문에 CPU는 유휴 상태에 빠지게 됩니다.<br>
이런 상황에서 메모리에 다른 프로그램이 올려져 있다면, 입출력 작업 동안 CPU는 대기 하는 것이 아닌, 다른 프로그램을 실행함으로서 CPU를 효율적으로 사용할 수 있습니다.<br>
<br>
유사질문 3 - 멀티 프로세싱은 무엇인가?<br>
멀티 프로세싱은 여러 CPU에 하나의 프로세스를 여러 단위로 쪼개 병렬로 실행하게끔 해서 실행 속도를 극대화 시키는 시스템입니다.<br>
</details>

### Spring

<details markdown = "1">
<summary>클라이언트가 웹 브라우저에서 특정 URL로 요청을 보냈을때, 이 요청이 내장 웹서버를 거쳐 스프링 MVC 프레임웤의 컨트롤러에 도달하고 최종적으로 뷰를 통해 클라이언트에게 응답되는 과정을 설명해주세요.</summary>
<br>
클라이언트가 웹 브라우저에서 특정 URL로 요청을 보내면, 이 요청은 내장 웹 서버를 통해 스프링 애플리케이션에 도달합니다.<br>
내장 웹 서버는 이 요청을 분석하고, 해당 URL과 매핑된 컨트롤러의 메서드를 호출합니다.<br>
이때 메서드는 스프링 프레임워크가 생성한 Model 객체를 인자로 받아, 필요한 데이터를 Model에 저장합니다.<br>
이때 Model 객체는 컨트롤러와 뷰 사이에서 데이터를 주고받는 매개체의 역할을 합니다.<br>
메서드가 뷰의 이름을 문자열로 반환하면, ViewResolver는 기본 설정 디렉토리에서 반환된 문자열에 해당하는 파일을 찾습니다.<br>
<br>
찾아진 뷰 파일은 템플릿 엔진에 의해 렌더링 되며, 이 과정에서 Model객체에 저장된 데이터를 사용하여 동적인 웹 페이지를 생성합니다.<br>
최종적으로 생성된 웹 페이지는 클라이언트에게 응답으로 전달되어, 웹 브라우저에 표시됩니다.<br>
</details>

<details markdown = "1">
<summary>@Responsebody 어노테이션의 역할을 무엇인가요?</summary>
<br>
@ResponseBody 어노테이션은 컨트롤러의 메서드가 반환하는 결과를 HTTP 응답 본문에 직접 작성하는데 사용합니다.<br>
일반적으로 이 어노테이션은 JSON 형태의 데이터를 반환하는 Restful 웹 서비스에서 사용합니다.<br>
<br>
참고 - 이 애너테이션이 없다면 뷰 리졸버한테 던져줌
</details>

<details markdown = "1">
<summary>스프링에서는 어떻게 객체를 JSON으로 변환하나요?</summary>
<br>
스프링에서는 HttpMessageConverter를 사용하여 객체를 JSON으로 변환합니다. 컨트롤러에서 반환한 객체가 있다면, 기본 정책은 이 객체를 JSON으로 변환하여 HTTP 응답 본문에 작성하는 것입니다.<br>
이때 클라이언트의 HTTP Accept 헤더와 서버의 컨트롤러 반환 타입 정보 둘을 조합해서 HttpMessageConverter가 선택됩니다.<br>
<br>
참고 - 단순 문자면 StringConverter가 동작하고 객체인 경우엔 jsonConverter가 동작
</details>

<details markdown = "1">
<summary>@Component에 대해 설명해주세요</summary>
<br>
해당 클래스가 Spring Bean임을 나타내는 어노테이션입니다. 이 클래스는 Spring의 컴포넌트 스캐너에 의해 자동으로 감지되고, ApplicationContext에 등록됩니다.<br>
</details>

<details markdown = "1">
<summary>@SpringBootTest와 @Transactional은 무엇인가요?</summary>
<br>
전자는 스프링 컨테이너와 테스트를 함께 실행하기 위한 어노테이션으로 통합 테스트시 주로 사용<br>
후자 어노테이션 사용시 테스트 시작 전에 트랜잭션을 시작하고, 테스트 완료 후에 항상 롤백을 진행하는 어노테이션<br>
이는 데이터 조회가 아니라, 데이터 저장 및 변경시에 필요함!!!!<br>
</details>

<details markdown = "1">
<summary>스프링이란 무엇인가요???</summary>
<br>
스프링은 엔터프라이즈용 자바 애플리케이션 개발을 편하게 할 수 있게 해주는 오픈소스 애플리케이션 프레임워크입니다.<br>
<br>
참고 - 스프링이 등장하기 이전에는 EJB(Enterprise Java Bean)이라는 기술이 주로 사용되었고 이 또한 이전 기술의 단점을 보완하기 위해 등장하였습니다.<br>
하지만 여전히 불필요하게 복잡한 코드를 작성해야 했고, 이에 따라 많은 개발자들이 불필요한 코드를 걷어내고 어떻게 코드의 복잡성을 줄일지 고민한 결과 탄생하였습니다.<br>
<br>
참고 - 프레임워크란, 어떠한 목적을 쉽게 달성할 수 있도록 해당 목적과 관련된 코드의 뼈대를 미리 만들어 둔것<br>
</details>

<details markdown = "1">
<summary>스프링이 가지고 있는 특징들을 설명해주세요</summary>
<br>
스프링의 가장 큰 특징은 POJO를 지향한다는 것입니다. 여기서 POJO(Plain Object Java Object)란 순수 자바, 즉 java 및 java 스펙에 정의된 기술만 사용한다는 의미입니다.<br>
예를들어 외부 라이브러리를 import해서 라이브러리 메서드를 사용하고 있다는 객체가 있다고 가정해보겠습니다.<br>
이 객체는 순수 Java외의 외부 기술을 사용하므로, POJO가 아닙니다. 이때 이 객체가 사용하고 있는 기술이 Deprecated가 되거나, 개선된 신기술이 등장하여 기존 기술과 관련된 코드를 모드 고쳐야 한다면<br>
해당 기술을 사용하고 있는 모든 객체들의 코드를 전부 바꿔주어야만 합니다.<br>
반면 POJO는 순수 자바를 사용하여 만든 객체이기에 특정 기술이나 환경에 종속되지 않아, 보다 유연하게 변화와 확장에 대처할 수 있습니다.<br>
이러한 POJO 프로그래밍을 위해 스프링이 지원하는 기술이 IOC/DI, AOP,PSA 등이 있습니다.<br>
<br>
애플리케이션 개발 시 구현해야 할 기능들은 크게 공통 관심 사항(모든 핵심 사항에 공통으로 적용되는 관심 사항)과 핵심 관심 사항(애플리케이션의 핵심 기능과 관련된 관심사항)으로 분류됩니다.<br>
이때 AOP란 애플리케이션 전반에 걸쳐 적용되는 공통 관심사항을 핵심 관심 사항인 비즈니스 로직으로부터 분리해 내는 것을 뜻합니다.<br>
ex) 핵심 사항 예시 : 배달앱 기준 메뉴 등록 주문, 주문 변경 등, 공통 관심 사항 예시 : 로깅이나 보안과 관련된 기능을 공통적으로 적용<br>
<br>
PSA(Portable Service Abstraction , 일관된 서비스 추상화)는 특정 기술에 종속되지 않도록 서비스를 추상화하여 일관된 방식으로 사용될 수 있도록 한것을 뜻합니다.<br>
<br>
ex) PSA 예시<br>
예를들어 스프링 데이터 JPA를 사용하면 특정 데이터베이스 기술에 종속되지 않는 코드를 작성할 수 있고, 이는 다른 DB로 마이그레이션이 필요할때 유용합니다. <br>
어떤 DB를 사용하든 간에 JPA 스펙을 준수하는 DB로 마이그레이션을 하면, 대부분의 코드를 변경하지 않고도 DB를 변경할 수 있습니다.<br>
또는<br>
예를들어 MySQL을 사용하여 개발을 완료했는데 다른 디비로 바꿔야 한다면 기존의 코드를 전부 지우고 새로 작성하거나, 두 디비의 간에 사용방법이 다른 코드를 찾아서 일일히 수정해야 할 수도있습니다.<br>
하지만 스프링은 데이터베이스 접근하는 방법을 규정한 인터페이스인 JDBC를 제공해 주기에 동일한 사용방법을 유지한채로 디비를 바꿀수 있습니다.<br>
각 DB를 만든 회사들은 자신의 DB에 접근하는 드라이버를 JAVA 코드의 형태로 배포하는데, 이 드라이버에 해당하는 Java 코드의 클래스가 JDBC를 구현합니다.<br>
따라서 JDBC를 기반으로 하여 DB접근 코드를 작성해두면, 이후에 DB를 바꿔도 기존에 작성한 DB 접근 로직을 그대로 사용할 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>IOC란 무엇인가요??</summary>
<br>
IOC란 프로그램의 제어 흐름을 코드 내에서(개발자) 직접 제어한 것이 아니라 외부에서 관리하는 것을 의미합니다.<br>
스프링 애플리케이션에서는 빈의 생성과 의존관계 설정 등의 작업을 애플리케이션 코드 대신 스프링 컨테이너가 담당하고 있습니다.<br>
이를 스프링 컨테이너가 코드 대신 오브젝트에 대한 제어권을 가지고 있다고 해서 IOC 컨테이너라고도 부릅니다.<br>
<br>
꼬리질문- IOC 컨테이너란 무엇인가요?<br>
스프링 애플리케이션에서는 객체의 생성과 관계 설정, 사용, 제거 등의 작업을 애플리케이션 코드 대신 스프링 컨테이너가 담당하는데, 이를 IOC 컨테이너라고 합니다.<br>
<br>
IOC 컨테이너 장점은 스프링 애플리케이션의 객체(빈)을 IOC 컨테이너가 관리해줌으로써 개발자의 부담이 줄고 비즈니스 로직에 집중할 수 있다는 장점이 있습니다.<br>
<br>
스프링 컨테이너는 빈들을 인스턴스 형식으로 관리함, 즉 한번 생성 후 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유함<br>
따라서 상태를 유지하게 끔 설계하면 안됨. restful이 아닌 stateless로 설계해야 함<br>
특정 클라이언트에 의존적인 필드나, 특정 클라이언트가 값을 변경할 수 있는 필드가 존재하면 안됨<br>
</details>

<details markdown = "1">
<summary>BeanFactory와 ApplicationContext의 차이가 무엇인가요??</summary>
<br>
빈 팩토리는 스프링 컨테이너의 최상위 인터페이스로 스프링 빈을 관리하고 조회하는 역할을 담당하고 있습니다.<br>
애플리케이션 컨텍스트는 빈 팩토리의 기능을 모두 상속받아 제공할 뿐 아니라, 국제화 기능이나, 환경 변수(로컬,개발,운영등을 구분해서 처리) 등의 추가 부가 기능을 제공합니다.<br>
</details>

<details markdown = "1">
<summary>DI가 무엇이죠?</summary>
<br>
DI란 객체의 의존관계를 객체 내부가 아닌 외부에서 주입해주는 것입니다.<br>
이를 통해 각 객체가 가지는 역할에만 집중하도록 하고, 변경 사항이 생겼을때 유연하게 대처할 수 있게 됩니다.<br>
<br>
꼬리질문 - DI이해를 위해 예시를 들어주시겠어요??<br>
예를들어 버거 레시피라는 하나의 인터페이스가 있고 그 구현체로 일반버거 레시피, 치즈 버거 레시피가 있다고 가정해보겠습니다.<br>
이때 버거 요리사라는 클래스가 있고 현재 이 버거 요리사는 구현체인 일반버거 레시피에 의존하고 있다고 해보겠습니다.<br>
근데 만약 일반버거 레시피가 아닌 치즈 버거 레시피를 사용하려면 클라이언트인 버거 요리사 클래스의 코드를 수정해야 합니다.<br>
하지만, 만약 버거 요리사 클래스가 구체적인 일반 버거 레시피 대신에 버거 레시피라는 인터페이스에 의존하게 된다면, 버거 레시피를 구현하는 어떤 객체라도 요리사 클래스는 그것을 사용할 수 있습니다. 이 경우, 요리사 클래스가 사용할 레시피를 바꾸고 싶을 때에는 그저 외부에서 다른 타입의 레시피 객체(예: 치즈 버거 레시피)를 요리사 클래스에 주입하면 됩니다. 이렇게 되면 요리사 클래스 코드 자체는 그대로 두고 외부에서 주입하는 객체만 바꿔서 요리사의 동작을 변경할 수 있게 됩니다<br>
<br>
꼬리질문 - DI의 장점은 무엇이죠?<br>
DI를 사용하여 구현을 했다면, 주입받는 대상이 변하더라도 해당 클래스 자체를 수정할 일이 없거나 줄어들기에 의존성이 줄어듭니다.<br>
따라서 서로 결합도가 낮아지기에, 각 구성요소를 독립적으로 개발하고 테스트하는데 유리합니다.<br>
그리고 코드에서 직접적으로 객체를 생성하거나 관리할 필요가 없으므로 코드가 더 간결해 집니다.<br>
그러나 DI는 주로 런타임에 의존성을 주입하기에 컴파일 시점에 발생하는 오류를 잡아내기 어렵습니다(수정자나 필드의 경우)<br>
</details>

<details markdown = "1">
<summary>DI 방법엔 어떤 것들이 있죠??</summary>
생성자 주입 방식은 객체가 생성될때 생성자를 통해서 의존성이 주입되는 방법입니다. 이 방식은 주입받을 의존성이 변하지 않아야 할때 주로 사용됩니다.<br>
생성 시점에 의존성을 주입(new로 생성시 생성자 호출)받기에 final 키워드를 사용할 수 있어 불변성을 보장합니다.<br>
<br>
세터 주입 방식은 주입받을 의존성이 실행 중에 변경될 수 있는 경우에 주로 사용됩니다. 생성 후에도 의존성을 변경할 수 있으므로 유연성이 있습니다.<br>
필드 주입은 @Autowired를 통해 클래스의 필드에 직접 의존성이 주입하는 방식입니다.<br>
<br>
꼬리질문 1 - 필드 주입에 장단점이 무엇이죠??<br>
필드 주입시 코드가 간단해 진다는 장점이 있지만, Solid 원칙 중 단일 책임 원칙을 위반할 수 있고, final 키워드를 사용할 수 없어 불변성이 보장되지 않고, 객체가 변할 수 있습니다.<br>
또한 Unit Test가 어렵습니다.<br>
필드 주입 방식을 사용하면 필드가 변경될 수 있어 해당 클래스가 필드의 상태 관리 책임을 가지게 됩니다.<br>
즉 핵심 비즈니스 로직에 집중하는 것 외에도 필드의 상태를 체크하고 관리하는 부가적인 책임을 가져야 하는 것입니다.<br>
또한 필드 주입방식에서는 객체를 먼저 생성하고, 이후에 필드에 값을 주입하는 과정을 거치기 때문에 final 필드에 값을 주입할 수 없습니다.<br>
final의 경우엔 선언과 동시에 초기화하거나, 생성자에서 초기화하는 것만 허용하기 때문입니다.<br>
<br>
꼬리질문 2 - 수정자 주입의 장단점은 무엇이죠?<br>
객체의 생명 주기 중에 의존성을 변경할 수 있고, 의존성이 생성시점에 필요하지 않은 경우 선택적으로 일부 의존성만 주입할 수 있다는 장점을 가집니다.<br>
하지만 수정자 주입 방식시 의존성이 변경될 수 있어, 의존성의 상태를 체크해야 하는 부가적인 책임을 지닐수 있어 SRP에 위배됩니다.<br>
또한 선택적인 의존성을 사용할 수 있기에 필수적이지 않은 의존성을 주입하지 않고도 객체를 생성할 수 있지만, 이렇게 선택적 의존성이 주입되지 않았을때, 해당 의존성을 사용하는 메서드가 호출되면 NPE가 발생할 수 있습니다.<br>
<br>
(객체 생성 이후에 별도의 setter 메서드를 호출하여 필요한 의존성을 주입합니다.따라서 final 키워드 사용 불가)
<br>
꼬리질문 - 생성자 주입을 사용해야 하는 이유는?<br>
생성자 주입 방법 사용시 객체가 생성되는 지점에 의존성을 생성자 인자로 주입받기에, 필드에 final 키워드를 사용할 수 있어 불변성을 보장할 수 있습니다.<br>
또한 생성자 주입을 사용하면 순환참조를 컴파일 시점에 확인할 수 있습니다.<br>
즉 클래스 생성과 동시에 의존성이 주입되어야 해서, 생성자 호출 시점에 모든 의존성이 주입되어야 하므로 만약 순환참조가 발생한다면 애플리케이션이 실행되지 않습니다.(컴파일 시점에 에러잡음)<br>
(반면 필드 주입이나 수정자 주입은 객체가 생성된 후에 의존성 주입이 일어나므로 ㅇ런타임에 이를 알 수 있따)<br>
그리고 생성자 주입 사용시 테스트 코드 작성 또한 용이합니다.<br>
만약 테스트를 하고자 하는 클래스에 필드 주입이나 수정자 주입으로 빈이 주입되어 있으면 Mockito를 이용해 목킹후 테스트를 진행해야합니다.<br>
하지만 생성자 주입의 경우엔 단순히 원하는 객체를 생성한 후 생성자에 넣어주는 방식으로도 진행이 가능합니다.<br>
<br>
(DI Container 없이 직접 의존성 주입 가능)<br>
꼬리질문 - 순환 참조가 무엇이고 언제 발생하는가?<br>
순환 참조란 서로 다른 여러 빈들이 서로를 참조하고 있음을 의미한다. 필드 주입이나 수정자 주입은 객체 생성 후 비즈니스 로직 상에서 순환 참조가 일어나기 때문에 컴파일 단계에서 순환 참조를 잡아낼 수 없다. 반면에 생성자 주입을 사용하면 스프링 컨테이너가 빈을 생성하는 시점에 순환 참조를 확인하기 때문에 컴파일 단계에서 순환 참조를 잡아낼 수 있다<br>
</details>

<details markdown = "1">
<summary>Spring IoC/DI의 동작 과정</summary>
<br>
먼저, 개발자는 각각의 컴포넌트(빈)와 이들 사이의 의존성에 대한 설정 정보를 XML, Annotation, Java Configuration 등을 통해 정의합니다.

이 설정 정보를 바탕으로 Spring IoC 컨테이너는 빈의 생명주기를 관리하고, 필요한 경우 의존성을 주입합니다.

컨테이너가 구동되면 개발자는 컨테이너로부터 필요한 빈을 가져와 사용합니다. 이때, 개발자는 빈의 생성과 소멸, 그리고 의존성에 대해 걱정할 필요가 없습니다.<br>
</details>

<details markdown = "1">
<summary>DI와 IoC의 차이</summary>
<br>
**IoC(Inversion of Control)**는 더 넓은 개념으로, 제어 흐름의 주도권이 사용자(개발자)에서 프레임워크나 컨테이너로 이동한 것을 말합니다.<br>
**DI(Dependency Injection)**는 IoC의 한 형태로, 객체 간의 의존성을 프레임워크나 컨테이너가 주입해주는 것을 말합니다<br>
그러나 이 둘은 서로 독립적인 개념이며 DI가 반드시 IoC를 요구하는 것은 아닙니다. DI를 구현하는 방법은 여러가지가 있고 그 중 IoC 컨테이너를 사용하는 것이 하나의 방법일 뿐입니다. IoC 컨테이너 없이도 DI는 구현이 가능합니다. 예를 들어, 개발자가 직접 코드 내에서 객체를 생성하고 의존성을 주입하는 방식도 가능합니다. 이런 방식은 IoC의 개념을 적용하지 않지만, 의존성 주입(DI)을 구현하는 것입니다.<br>
IoC는 제어의 역전에 초점을 둔다면, DI는 객체간의 의존성을 어떻게 관리할 것인지에 초점을 두는 것이라고 말할 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>Bean Definition이 무엇이죠?</summary>
<br>
BeanDefinition은 BeanFactoryPostProcessor가 읽을 수 있는 형태로 Bean 설정 메타데이터를 정의하는 인터페이스입니다.<br>
Bean Definition은 Bean의 클래스 이름, Bean이 생성되는 방법, Bean 사이의 의존성, Bean의 범위(scope) 등을 정의합니다<br>
<br>
스프링 컨테이너는 다양한 형식(ex: 자바 코드, XML, Groovy)의 설정 정보를 받아드릴 수 있게 유연하게 설계되어있습니다.
그렇다면 스프링은 어떻게 이런 다양한 설정 형식을 지원하는 것일까요??? 이 중심에는 BeanDefinition이라는 인터페이스가 있습니다.<br>
</details>

<details markdown = "1">
<summary>스프링에서는 빈을 어떤 형식으로 관리하죠?</summary>
<br>
스프링에서는 빈을 싱글톤 형태로 관리합니다. 즉 스프링 컨테이너에서 생성된 빈은 기본적으로 싱글톤 스코프를 가지고, 같은 타입의 빈을 요청하면 항상 같은 인스턴스를 반환합니다.<br>
이렇게 싱글턴 형태로 빈을 관리하면 메모리 사용량을 줄일 수 있고, 이미 생성된 빈을 재사용할 수 있어서 효율적입니다.<br>
<br>
원래 스프링이 적용되어있지 않는 순수한 DI 컨테이너의 경우, 요청이 올때마다 객체를 새로 생성하였습니다.
즉 고객 트래픽이 초당 100이 나오면 초당 최소 100개의 객체가 생성되고 소멸되는 것이죠(메모리 낭비)

이를 해결하려면 해당 객체가 딱 1개만 생성되고, 공유하도록 설계하면 됩니다(싱글톤 적용).

싱글톤 패턴이란 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴입니다. 이는 객체 인스턴스를 2개 이상 생성하지 못하도록 막기 위해 private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막습니다.<br>

</details>

<details markdown = "1">
<summary>@Configuration과 @Bean의 차이점은 무엇인가요?</summary>
<br>
@Configuration은 해당 클래스가 빈 설정을 담당하는 클래스임을 스프링에 알려줍니다. 스프링은 이 클래스를 통해 빈을 생성하고 의존성을 주입합니다. 반면, @Bean은 해당 메서드가 빈을 생성하는 책임을 가지며, 이 메서드가 반환하는 객체를 스프링 빈으로 등록하게 됩니다. 이때 @Configuration이 붙은 클래스 내부의 @Bean 메서드는 항상 동일한 인스턴스를 반환하도록 보장하며, 이를 통해 스프링의 싱글톤 빈이 유지되게 합니다.<br>
</details>

<details markdown = "1">
<summary>스프링에서 싱글톤 빈이 유지되는 원리를 설명해주세요.</summary>
<br>
스프링에서는 @Configuration이 붙은 클래스에 대해 CGLIB 바이트코드 조작 라이브러리를 사용하여 클래스를 상속받은 임의의 다른 클래스를 만듭니다<br>
이 임의의 클래스는 싱글톤 빈이 유지되도록 도와주는 역할을 합니다.<br>
<br>
참고 - 바이트 코드 조작이란<br>
Java의 경우, JVM이 이해할 수 있는 바이트코드 형태로 컴파일이 되는데, 이렇게 컴파일된 바이트코드를 조작하여 새로운 클래스를 생성하거나 기존 클래스의 기능을 변경하는 것을 말합니다. <br>
</details>

<details markdown = "1">
<summary>@Component랑 @ComponentScan @Configuration에 대해 설명해주세요.</summary>
<br>
@Component는 해당 클래스가 Spring에서 관리되는 빈임을 나타냅니다.<br>
이 어노이션이 달린 클래스는 Spring 시작 시 빈으로 등록되고, 필요할때 Spring에 의해 자동으로 주입될 수 있습니다.<br>
<br>
@ComponentScan은 Spring에서 @Component나 이로부터 파생된 어노테이션,@Service,@Repository,@Controller, @Configuration와 같은 어노테이션이 붙은 클래스를 찾아 Bean으로 등록하도록 지시하는 어노테이션입니다.<br>
이를 통해 개발자는 직접 빈으로 등록하지 않아도, Spring이 애플리케이션의 구성 요소를 자동으로 찾아내고 관리하도록 할 수 있습니다.<br>
<br>
@configuration은 해당 클래스가 Spring의 설정 클래스임을 나타내는 어노테이션입니다.<br>
이러한 어노테이션이 붙은 클래스 안의 Bean 어노테이션이 붙은 메서드들은 각각 하나의 빈 객체를 생성하고 초기화하는 역할을 합니다.<br>
또한 Configuration이 붙은 클래스는 스프링에 의해 CGLIB Proxy로 처리되므로, 같은 설정 클래스 내부에서 Bean 어노테이션이 붙은 메서드를 호출하면 항상 같은 인스턴스를 반환합니다.<br>
</details>

<details markdown = "1">
<summary>조회 대상 빈이 2개 이상일때 해결하는 방법에는 어떤것이 있나</summary>
<br>
@Qualifier 어노테이션을 통해 추가 구분자를 붙여주거나, @Primary 어노테이션을 통해 우선순위를 정해줌으로서 해결할 수 있습니다.<br>
<br>
꼬리질문 - 만약 동적으로 빈을 선택해야 할경우엔 어떻게 하나?<br>
Map을 사용해서 해결 가능!<br>
예를들어 문자열과 그에 대응하는 클래스를 넣어둠<br>
</details>

<details markdown = "1">
<summary>스프링 빈의 생명주기에 대해 설명해주시겠어요?</summary>
<br>
스프링 애플리케이션의 실행은 스프링 IoC(Inversion of Control) 컨테이너의 생성으로 시작됩니다. 이 컨테이너는 Bean Definition에 정의된 대로 각 Bean 객체를 인스턴스화합니다.<br>
Bean이 인스턴스화 된 후에는, IoC 컨테이너는 Bean Definition에 명시된 의존관계를 참조하여 의존성을 주입합니다.<br>
<br>
모든 의존성 주입이 완료되면, 해당 Bean이 InitializingBean 인터페이스를 구현하고 있거나, 커스텀 초기화 메서드가 @Bean 어노테이션에 지정되었거나, @PostConstruct 어노테이션이 붙은 메서드가 있다면, 이들은 초기화 콜백 메서드로 작동하여 호출됩니다.<br>
이 단계가 완료되면, 애플리케이션은 필요에 따라 IoC 컨테이너에서 Bean을 요청하여 사용하게 됩니다.<br>
<br>
컨테이너가 종료되는 시점에, IoC 컨테이너는 Bean의 생명주기를 관리하는 과정으로서, 소멸 전 콜백 메서드를 호출합니다. 이 때는 DisposableBean 인터페이스의 destroy() 메서드, @PreDestroy 어노테이션이 붙은 메서드, 또는 @Bean 어노테이션에 지정한 사용자 정의 소멸 메서드가 호출됩니다.<br>
이 단계에서 Bean은 자원 해제, 네트워크 연결 종료 등 소멸과정에 필요한 동작을 수행합니다. 이후, IoC 컨테이너 자체가 종료되며 이 과정에서 Singleton 범위의 모든 Bean들이 소멸됩니다.<br>
</details>

<details markdown = "1">
<summary>빈 생명주기 콜백을 적용하는 방법엔 어떤 방법들이 있죠?</summary>
<br>
InitalizingBean, Disposable Bean과 같은 인터페이스를 구현하거나, Bean 어노테이션 설정 정보에 초기화 메서드, 종료 메서드를 지정하거나, <br>
@PostConstruct, @PreDestroy 애노테이션을 지정함으로서 콜백을 적용할 수 있습니다.<br>
<br>
꼬리질문 - 각 방법의 특징 간단히<br>
인터페이스 방식은 프링 전용 인터페이스에 의존하게 되며, 초기화와 소멸 메서드의 이름을 변경할 수 없고, 외부 라이브러리에 적용할 수 없다는 단점이 있습니다. 이는 초기 스프링에서 사용되던 방식으로, 현재는 권장하지 않습니다.<br>
Bean 어노테이션 설정 정보에서 적용하는 방법은 메서드 이름을 자유롭게 지정할 수 있고, 스프링에 의존하지 않습니다. 설정 정보를 활용하므로 코드를 수정할 수 없는 외부 라이브러리에서도 적용할 수 있습니다<br>
@PostConstruct, @PreDestroy 어노테이션 사용 방식은 최신 스프링에서 가장 권장하는 방법으로, 어노테이션 하나를 붙이는 것으로 편리하게 콜백을 지정할 수 있습니다<br>
 이 어노테이션들은 JSR-250이라는 자바 표준을 준수한 것으로, 스프링이 아닌 다른 컨테이너에서도 동작합니다. 다만, 외부 라이브러리에 적용할 수 없다는 단점이 있습니다. 이때는 @Bean의 기능을 활용하는 것이 좋습니다.<br>
</details>

<details markdown = "1">
<summary>빈 스코프에 대해 아시는대로 설명해주세요</summary>
<br>
빈 스코프는 빈이 존재할 수 있는 범위를 나타내는 개념입니다.<br>
싱글톤 스코프의 경우 기본 스코프로, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프입니다.<br>
프로토타입 스코프의 경우, 스프링 컨테이너가 빈의 생성과 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프입니다.<br>
이러한 프로토타입 스코프의 빈을 요청하게 되면, 스프링은 매 요청마다 항상 새로운 프로토타입의 빈을 생성해서 반환합니다.(개발자가 관리할 책임을 가짐)<br>
웹 관련 스코프에는 Request와 Session 스코프가 있습니다.<br>
Request 스코프는 HTTP 요청이 하나 들어오고 나갈때 까지 유지되는 스코프로, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리됩니다.<br>
Session 스코프는 웹 세션이 생성되고 종료될떄 까지 유지되는 스코프로 HTTP Session과 동일한 생명주기를 가지는 스코프입니다.<br>
<br>
참고<br>
프로토타입 빈과 싱글 톤 함께 사용시 프로토타입 빈이 매번 새로 생성되게 할려면 Provider를 사용함.<br>
Provider는 지정한 빈을 컨테이너에서 대신 찾아주는 역할을 함<br>
리퀘스트 스코프로 로그남길때 Provider를 통해 해결 가능(프록시를 통해서도 가능).<br>
이는 리소스를 효율적으로 사용하고, 동시에 여러 요청이 들어오더라도 각 요청마다 독립적인 빈을 사용할 수 있도록 해줍니다<br>
웹 세션이란 웹 서버에서 사용자가 브라우저를 통해 웹 서버에 접속할 때부터 브라우저를 닫거나 로그아웃하여 접속을 종료할 때까지 유지되는 사용자의 상태를 의미합니다. 웹이 기본적으로 상태를 유지하지 않는(stateless) 특성을 가지고 있는데, 이 상태를 유지하기 위해 사용하는 것이 세션입니다.<br>
<br>
세션은 서버에 생성되어 서버 내부에 저장되고, 일정 시간동안 같은 사용자(정확히는 브라우저)로부터 들어오는 요청을 하나의 상태로 보고 유지하게 됩니다. 사용자가 로그인을 하면 해당 사용자의 세션 정보가 서버에 생성되고, 그 세션 정보와 연결되는 세션 ID가 사용자의 웹 브라우저 쿠키로 발급됩니다. 이후 사용자가 웹 서버에 접근할 때마다 이 세션 ID가 함께 전송되어 사용자를 식별하게 됩니다. 이렇게 함으로써, 로그인 정보, 사용자의 이전 작업 내역 등을 유지할 수 있습니다.<br>
세션의 관리(생성, 삭제 등)는 서버의 책임이며, 세션의 유효 시간이 지나거나 사용자가 로그아웃을 하면 세션이 종료되게 됩니다. 이렇게 세션을 사용하여 사용자의 상태 정보를 유지함으로써 사용자 별로 개인화된 서비스를 제공하는 것이 가능해집니다.<br>
</details>

## 네트워크

<details markdown = "1">
<summary>네트워크 간단 지식 정리</summary>

- `네트워크` : 노드와 링크가 서로 연결되어 있으며 리소스를 공유하는 집합을 의미합니다.
- `노드` : 서버, 라우터, 스위치등 네트워크 장치
- `링크(엣지)` : 노드와 노드를 연결하는 매체, 유선 또는 무선과 같은 연결매체(와이파이나 LAN)
- `트래픽` : 특정 시점에 링크 내의 흐르는 데이터의 양 (트래픽 이많다 == 흐르는 데이터가 많아졌다, 처리량이 많다 == 처리되는 트래픽이 많다)
- `대역폭` : 주어진 시간 동안 네트워크 연결을 통해 흐를 수 있는 최대 비트 수 or 최대로 처리할 수 있는 트래픽
- `RTT(Round Trip Time)` : 데이터 패킷이 송신자로부터 수신자까지 가는 시간과 그 반대 방향으로 돌아오는 전체 시간을 의미
- `네트워크 토폴로지` : 네트워크에 참여하는 링크 및 노드들의 배치 형태 및 망구성방식을 의미(버스,스타,트리 형 존재), 병목현상을 해결하는 척도
- `버스 토폴로지` : (하나의 링크에 여러 노드 있는 형태) 소규모 네트워크 구축하기 쉽고, 한 노드 장애나도 따른데 영향 X, 메인 링크에 많은 트래픽 생기면 정체 현상 발생, 메인 링크 망가지면 문제
- `스타 토폴로지` : (중앙에 노드를 기반으로 연결된 형태) 중앙 노드 아닌 한 노드에 장애 발생 시 따른 영향 X, 다른 노드 가려면 중앙 노드 거쳐야함(중앙에 방화벽), 안정적, 중앙 노드 에러 시 큰 문제
- `트리 토폴로지(계층적)` : 노드 추가 삭제는 보통, 리프 노드 에러는 나머지 영향 X, 특정 노드 트래픽 집중시 하위 노드에 영향, 루트 노드 문제 시 다 문제(백본 케이블 기반으로 연결)
- `백본 케이블` : 여러 소형 네트워크를 묶어 대규모 파이프 라인을 통해, 높은 대역폭으로 다른 네트워크 집합과 연결되는 네트워크
- `링형 토폴로지` : (고리 형태), 연결리스트 처럼 노드 추가 삭제 쉬움, 토큰을 기반으로 연속적으로 노드 거치며, 권한이 없는 노드는 데이터 안받음, 토큰이 없는 노드는 통신 참여 불가
- `메시 토폴로지` : (그물망으로 다 연결된 상태) 노드 추가 및 삭제 어려움(많이 연결되어있어서), 안정성은 높음(한 노드 장애 나도 다른 노드 영향 X), 트래픽 분산, 구축 비용이 고가라는 단점
- `병목현상(bottleNek)` : 트래픽에 의해 데이터의 흐름이 제한된 상황(토폴로지를 안다면 어떤 회선 또는 서버의 용량을 증가시켜야 하는지 파악 가능)
- `유니캐스트` : 1대1 통신으로 대표적으로 HTTP 통신
- `멀티캐스트` : 1대N 통신으로 연결된 모든 노드들에게 데이터를 전달하지는 않고, 특정 그룹에게만 데이터를 전달
- `애니캐스트` : 연결된 모든 노드에게 데이터를 전달(대표적으로 ARP)
- `근거리 통신망(LAN)` : 근거리 통신망으로, 높은 안정성과 속도를 가집니다. 하나의 논리적 주소인 IP를 기반으로 여러개의 물리적 주소인 MAC 주소로 구별하는 네트워크(허브나 스위치로 연결됨)<br>
- `대도시 통신망(MAN)` : 도시와 도시의 통신망을 뜻하며 2개 이상의 LAN이 연결되어 구성됩니다.(라우터 브리지 등으로 연결되어 있음)
- `광역 통신망(WAN)` : 국가와 국가와의 통신, 제일 혼잡
- `TCP/IP 4계층` : 장치들이 인터넷 상에서 데이터를 주고받을 때 쓰는 독립적인 프로토콜 집합
- `애플리케이션 계층` : HTTP, SMTP, SSH, FTP 등이 있다. 웹 서비스, 이메일 등 서비스를 실질적으로 사람들에게 제공하는 층
- `전송 계층` : TCP, UDP등이 있다. 애플리케이션 계층에서 받은 메세지를 기반으로 세그먼트 또는 데이터그램으로 쪼개고, 데이터가 오류없이 순서대로 전달되도록 하는 층
- `인터넷 계층(network 계층)` : IP, ICMP, ARP 등이 있음. 세그먼트 또는 데이터그램을 패킷화하여 목적지로 전송하는 역할
- `링크 계층` : 물리 계층 + 데이터 링크 계층, 전선 광섬유 등이 있다. 데이터가 네트워크를 통해 물리적으로 전송되는 방식 정의
- `캡슐화` : 캡슐화는 데이터를 보낼때(송신자 -> 수신자), 데이터가 각 계층을 지나며 각 계층의 특징들이 담긴 헤더들이 붙여지는 과정 의미
- `비캡슐화` : 캡슐화 역과정, 캡슐화된 데이터를 역순으로 제거하면서 응용계층까지 도달하는 과정
- `PDU(Protocol Data Unit)`: 각 계층의 데이터 단위
    - 애플리케이션(메세지), TCP(세그먼트), UDP(데이터그램), 인터넷(패킷), 데이터 링크(프레임), 물리계층(비트)
- `세그먼트 or 데이터 그램` : 적절한 크기로 쪼갠 조각
- `패킷` : 세그먼트에 SP(송신자 IP)와 DP(수신자 IP)가 포함된 IP헤더가 붙은 형태의 조각
- `프레임` : MAC 주소 헤더와 CRC/체크섬 트레일러가 붙은 조각
- `MTU(Maximum Transmission Unit)` : 네트워크에서 전송될 수 있는 최대 데이터 패킷의 크기를 의미하며, 이 크기를 초과하는 데이터는 패킷으로 분할되어 전송됩니다
- `SSH(Secure Shell Protocol)` : 보안되지 않은 네트워크에서 네트워크 서비스를 안전하게 운영하기 위한 암호화 네트워크 프로토콜
- `FTP(File Transfer Protocol)` : 노드와 노드간 파일을 전송하는데 사용되는 프로토콜
- `SMTP` : 인터넷을 통해 메일을 보낼때 사용되는 프로토콜
- `TCP` : 가상 회선 패킷 교환 방식 사용, 오류 검사 메커니즘으로 재전송이나 체크섬 사용, 헤더 크기가 가변적
- `UDP` : 데이터 그램 패킷 교환 방식(순서 보장 X), 오류검사는 단순한 체크섬만 제공, 헤더가 8바이트로 고정, 쓰리웨이 포웨이 핸드쉐잌도 안함
- `ICMP(Internet Control Message Protocol)` : 노드와 노드사이에서 통신이 잘되나 확인하는 프로토콜
- `3-웨이 핸드쉐이크` : TCP의 연결 성립 과정. 
    - 클라이언트는 서버에 클라이언트의 ISN(고유번호)을 담아 SYN을 보냄(SYN 단계)
    - 서버는 클라이언트의 SYN을 수신하고, 서버의 ISN을 보내며, 승인번호로 클라이언트의 ISN + 1을 보냄(SYN/ACK)
    - 클라이언트는 서버의 ISN+1한 값인 승인번호를 담아 ACK를 서버에 보냄(ACK)
- `ISN` : TCP 기반 통신에서, 각각의 새연결에 할당된 고유한 시퀀스 번호
- `라우팅` : 네트워크에서 패킷(데이터)를 보낼때 최적의 경로를 선택하는 과정이며 라우터가 이를 수행. 데이터는 목적지로 가능동안 여러 라우터를 거치며 여러 번 라우팅 수행
- `라우터` : 네트워크 사이에서 데이터를 전달하는 장치로, 둘 이상의 서로 다른 네트워크에 연결. 데이터를 목적지로 보낼 때 최적의 경로를 결정하고, 경로가 결정되면 해당 경로로 데이터를 넘겨주는 일을 수행(라우팅 테이블 기반)<br>
- `게이트 웨이` : 서로 다른 네트워크나 프로토콜 간의 통신을 가능하게 하는 장치(라우터랑 비슷)
- `홉` : 데이터 패킷이 소스에서 목적지로 전송되는 동안 거치는 네트워크 장치(예 : 라우터) 숫자
- `IP주소` : 인터넷 프로토콜에 할당된 장치의 고유한 숫자 주소로, 네트워크 상에서 특정 장치를 식별하기 위해 사용
- `MAC주소` : NIC(네트워크 인터페이스 카드)에 할당된 고유한 하드웨어 주소로, 물리적 네트워크 상에서 장치를 식별하기 위해 사용
- `ARP(Address Resolution Protocol)` : IP 주소를 기반으로 해당 장치의 MAC 주소를 알아내기 위한 프로토콜 (반대로 하면 RARP)
    - MAC 주소 찾기 위해 브로드 캐스팅을 통해 데이터를 연결된 네트워크 장치에 모두 보냄
    - 맞는 장치가 있다며해당 장치는 유니캐스트로 데이터를 전달해 주소를 찾음
- `IPV4` : 32비트로 표현되는 주소체계로 8비트씩 4개로 구분(10진수로 표현)
- `IPV6` : 128비트로 표현되는 주소체계로 16비트씩 8개로 구분(16진수로 표현)
    - IPV6에는 데이터 패킷을 암호화하는 IPSec이 내장되어있고, 불필요한 필드를 제거하여 빠른 처리가 가능(보안도 좋고)
- `서브넷 마스크` : IP주소의 네트워크 부분과 호스트 부분을 구분하는데 사용. 4개의 8비트 옥텟으로 구성되어있음.(네트워크 주소 부분은 모두 1, 호스트 주소는 0)
- `IP 주소 클래스` : 주소 공간 효율적으로 관리하기 위해 클래스로 나누어짐.클래스 A에서 네트워크 주소는 첫 옥텟, 나머지는 호스트 주소. B는 1,2옥텟이 네트워크 나머지 호스트, C는 1,2,3 옥텟이 네트워크 나머지 호스트
- `프라이빗 IP` : 네트워크 내부(ex: 가정 회사)에서만 사용되는 주소로, 전세계적으로 유일하진 않지만 하나의 네트워크 내에서 유일함, 외부에서 직접 접근은 불가
- `공용 IP` : 인터넷 서비스 공급자에 의해 할당되는, 전세계 유일한 IP주소, 외부에서 접근 가능
- `NAT(Network Address Translation)` : 사설 IP를 공인 IP로 변환하거나, 반대로 변환하는 기술. 라우터나 방화벽에서(공유기도) 주로 사용되며, 내부 네트워크의 기기가 외부와 통신할때 IP 주소변환 담당
- `대칭 암호화` : 암호화와 복호화에 같은 키를 사용하는 방식(AES, DES)
- `비대칭 암호화` : 암호화와 복호화에 사용하는 키가 다른 방식. 공개키로 암호화하면 비밀키로만 복호화 가능(RSA, ECC, DSA)
- `TLS` : 웹 브라우저와 서버간의 통신을 암호화하여 다양한 공격으로부터 보호하는 프로토콜, SSL 후속 버전. HTTPS를 가능하게 하는 프로토콜.
- `로컬 스토리지` : 웹 스토리지 객체로 브라우저 내에 key:value 형태로 오리진에 종속되어 저장되는 데이터
    - 로컬 스토리지의 경우엔 탭이나 창을 닫어도, 만료 안됨. 캐시를 위해 주로 사용. 사용자 행위나 로그인을 유지하기 위한 값등으로 사용되며, 여기 있는건 자동으로 서버 전송X(쿠키는 전송됨)
- `오리진` : 프로토콜 + 호스트 네임 + port 형식 -> ex)search.shopping.naver.com
- `웹 캐싱 사용 이유` : 로그인 유지, 캐싱, 자동완성 등
- `세션 스토리지` : 로컬 스토리지와 개념 같게 말해도됨, 근데 사용자가 탭을 닫으면 데이터가 만료된다는 특징
- `쿠키` : 웹 캐시와 관련있음, 브라우저에 저장된 데이터 조각. 보통 서버에서 먼저 쿠키를 만들어 Set-Cookie 헤더에 추가해서 보내면, 클라이언트에서 요청헤더 Cookie에 설정되어 자동으로 서버에 전달되고 브라우저에도 저장됨
    - 세션 쿠키 : Expires 또는 Max-Age 적용 안한거. 브라우저 종료되면 쿠키도 사라짐
    - 영구 쿠키 : Expires, Max-Age 적용해서. 특정 날짜 또는 기간 지나며 삭제되는 쿠키. 브라우저 닫을때 만료 X
    - Secure : https로만 쿠키를 주고받을 수 있게 하는 옵션
    - httpOnly : 공격자가 자바스크립트로 뺴낼수 없게함
- `로컬, 세션 스토리지, 쿠키의 공통점과 차이점` : 브라우저에 캐싱을 함으로서 서버로의 요청을 줄여 부하 방지함
- `세션, 세션 ID` : 세션이란 서버와 클라이언트의 연결이 활성화된 상태 의미, ID는 웹 서버 또는 DB에 저장되는 클라이언트에 대한 유니크 ID
- `세션 기반 로그인 프로세스` : 처음 로그인 -> 세션 ID 생성 -> 서버에서 세션 ID를 쿠키로 설정해서 클라이언트에 전달 -> 클라이언트가 서버에 요청 보낼때 세션 ID를 추가해서 보냄 -> 이를 통해 전에 로그인한 아이디인지 확인 가능
- `토큰 기반 인증` : refresh토큰과 access 토큰 두개를 기반으로 구현. 보통 액세스(인증위한)는 짧게, 리프레시 길게
- `HTTP 상태 코드` : 1xx는 요청 잘 받았고 처리하는 중, 2xx 요청 잘 처리 후 데이터 보냄, 3xx : 클라이언트 요청에 대한 완료 위해 추가 작업 필요, 4xx : 요청한 페이지 제공할 수 없거나 요청이 잘못됨, 5xx : 서버가 요청을 처리하지 못하는 상태
- `레이어별 네트워크 장치` : `애플리케이션 계층` -> L7 `전송 계층` -> L4 `네트워크 계층` -> 라우터, L3 `데이터 링크 계층` -> L2 스위치, 브리지  `물리 계층` -> NIC, 리피터, ARP
- `L7 스위치` : 로드밸런서라고도 하며, 서버의 부하를 분산함.(서버 이중화 및 보안에 강점) IP, PORT뿐 아니라 url,헤더,쿠키 등을 기반으로 트래픽 분산, 헬스 체크를 통해 장애 발생 서버 확인 후 거기에 트래픽 안보냄
- `헬스 체크` : 정상적인 서버 또는 비 정상적 서버 판별함, 반복적으로 서버에 요청을 보내면서 확인(ex: 3웨이 핸드쉨)
- `L4 스위치` : 패킷의 IP주소와 포트 번호를 통해 트래픽 분산
- `L3 스위치` : L2스위치 기능 + 라우팅을 하는 장비
- `L2 스위치` : 장치들의 MAC 주소를 관리하고, 네트워크 계층에서 받은 패킷을 기반으로 이더넷 프레임을 만들어 목적지 MAC주소에 패킷을 보내주는 역할
- `브리지` : 두개의 LAN을 상호 접속할 수 있도록 하는 통신망 연결 장치
- `리피터` : 신호를 증폭하여 전달하는 장치
- `전 이중화 통신` : 두 장치가 동시에 서로에게 데이터를 송수신 할 수 있는 방식
- `반이중화 통신` : 두 장치 간에 한번에 한방향으로만 데이터를 송수신 할 수 있는 방식(워키토키 같음)
- `서버 과부하` : 서버가 리소스를 소진하여 들어오는 요청을 처리하지 못할때 발생(ex: 503), 이유는 보통 자원의 한계점 도달임. 서버의 CPU 사용량이 80~90프로에 도달하거나, 메모리가 부족해서 계속해서 스와핑이 발생하면 과부하 -> 모니터링을 통한 자원의 적절한 할당 필요
- `AWS 오토 스케일링` : 서비스 이용 불가능 상태 이전 cloud watch가 계속해서 모니터링하고, 자원의 용량을 자동으로 조정하는 방법(용량 조정시 시간 오래걸려 로드 밸런서도 둠)
- `서킷 브레이커` : 서비스 장애를 감지하고 연쇄적으로 생기는 에러를 방지하는 기법. 서비스와 서비스사이에 서킷브레이커 계층두고, 미리 설정해둔 timeout 임계값에 도달하면 서킷 브레이커가 그 이후의 추가호출에 무조건 에러를 반환함 -> 연쇄 오류전파를 끝내는 방법
- `대규모 트래픽 서버 부하 해결` : 오토 스케일링이나, 서킷 브레이커 외에 우선 불필요한 컨텐츠 제거하기. 분산된 서버 네트워크(CDN)를 기반으로 컨텐츠를 제공해서 메인 서버 부하를 줄임. 해당 트래픽 자체가 발생안하도록 캐싱을 사용
</details>

## 물어볼것 같은 질문들

<details markdown = "1">
<summary>OSI 7계층</summary>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/d18d26a6-8a28-482e-b37e-5b758251759f">
<br>
OSI 7계층은 네트워킹에서의 통신 프로세스를 이해하기 위한 표준 모델입니다.<br>

- `7계층(application layer, 응용계층)` : 최종 목적지로 응용프로그램과 연관해 서비스를 수행하는 계층입니다. 이메일 , 웹사이트 조회 등 어플리케이션 서비스 제공(HTTP,FTP,DNS 등이 있다)
- `6계층(Presentation layer, 표현 계층)` : 데이터의 암호화, 압축,변환등을 담당하는 계층입니다.(JPEG, MPEG 등)
- `5계층(Session layer, 세션 계층)` : 통신 세션을 구성하고 유지하기 위한 기능을 담당하는 계층입니다.(API, SOCKET)
- `4계층(Transport layer, 전송 계층)` : 종단 간의 사용자들에게 신뢰성 있는 데이터를 전달하기 위한 계층입니다.단위 세그먼트 or 데이터 그램(TCP,UDP)
  - 흐름제어 : 송신측, 수신측 사이의 데이터 처리 속도 차이 제어
  - 혼잡제어 : 네트워크 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도 제어
  - 오류제어 : 오류 검출 및 잘못된 패킷 재전송 등 관리
- `3계층(Network layer, 네트워크 계층)` : IP를 지정하고 라우터로 경로를 선택해 (네트워크를 통해) 패킷을 전송하는 계층(Router), 단위 패킷
- `2계층(Data Link Layer, 데이터 링크 계층)` : 프레임 단위의 데이터 전송과 MAC 주소를 이용한 통신을 처리하는 계층.단위 프레임. 신뢰성 있는 전송 위해 에러 검출 및 흐름제어 담당(이더넷 프로토콜, 스위치)
- `1계층(Physical Layer, 물리 계층)` : 데이터를 전기 신호로 변환 및 제어하는 계층, 단위 비트(리피터 ,허브)

<br>
전송 계층은 전체 통신 경로(최초 송신자와 최종 수신자 간)를 걸쳐 데이터의 안정성 보장, 데이터 링크 계층은 직접 연결된 두 장치간의 데이터 전송 관리<br>
<br>
꼬리질문 1 - 왜 각 계층은 나누어져 있을까요??<br>
통신이 일어나는 과정을 단계별로 잘 확인할 수 있고, 특정 계층에 문제가 말생하면 해당 계층만을 수정하거나 조정함으로서 다른 계층의 장비나 소프트웨어에 영향을 미치지 않고 효율적으로 문제 해결 가능<br>
</details>

<details markdown = "1">
<summary>인캡슐레이션과 디캡슐레이션에 대해 설명해주세요.</summary>
인캡슐레이션은 데이터를 보낼때, 데이터가 각 계층을 지나며 각 계층의 특징이 담긴 헤더들이 붙여지는 과정이고, 디캡슐레이션은 캡슐화된 데이터를 역순으로 제거하면서 응용계층까지 도달하는 과정입니다.
</details>

<details markdown = "1">
<summary>전송계층과 데이터 링크 계층 모두 신뢰성과 관련된 기능을 제공하는데, 어떤 차이가 있는지</summary>
전송계층은 논리적으로 연결된, 종단간의 호스트에 신뢰성 관련 기능(흐름 제어, 혼잡제어, 오류제어)를 제공합니다.<br>
데이터 링크 계층은 물리적으로 연결된 호스트 사이의 전송으로 직접 묶여있는 호스트-노드 혹은 노드-노드 간의 신뢰성 관련 기능(오류제어, 흐름제어, 회선 제어)를 제공합니다.<br>
<br>
한줄 요약 : 전송 계층은 논리적 연결(종단간 호스트) / 데이터링크 계층은 물리적 연결(인접한 노드 or 호스트)
</details>

<details markdown = "1">
<summary>전송 계층이 데이터 분실(패킷 추적)을 확인하는 방법에 대해 설명해주세요.(TCP 에서)</summary>
전송 계층은 세그먼트 마다 고유한 시퀀스 번호를 부여하여 전송합니다.(이후 수신자 측에서 재조립 -> 이를 통해 패킷 분실 여부 확인)<br>
수신측은 정상적으로 데이터를 받으면 해당 패킷의 시퀀스 번호와 함께 확인 응답(ACK)을 송신측에 보냅니다.<br>
송신측은 데이터를 보낸 후 일정 시간 동안(타임 아웃) 확인 응답을 기다리는데, 송신 측이 타임아웃 내에 확인 응답을 받지 못하면 해당 패킷을 분실로 간주하고 다시 전송합니다.<br>
</details>

<details markdown = "1">
<summary>전송계층이 제공하는 신뢰성 관련 기능 중, 흐름제어에 대해 설명해주세요.</summary>
흐름제어는 송신자와 수신자 간의 데이터 처리 속도 차이를 조절하여 통신의 효율성과 안정성을 보장하는 기능입니다.<br>
특히, 수신자의 버퍼가 넘치지 않도록 데이터 전송 속도를 조절하는데 중점을 둡니다.(송신측의 속도가 빠르면 문제가 된다는 것)<br>
이러한 흐름 제어 기법엔 대표적으로 슬라이딩 윈도우가 있습니다.(Stop and Wait도 있음)<br>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/adeae7bf-09df-4e93-b9f9-5be754c8316e">
<br>
슬라이딩 윈도우(Go Back N ARQ)는 특정 크기의 윈도우를 사용해 일정량의 패킷(세그먼트)들을 송신자로부터 수신자에게 보내는 기법입니다.<br>
슬라이딩 윈도우 내의 패킷들 중 ACK를 받지 못한 패킷들이 윈도우에 남게됩니다.<br>
전송된 패킷을 잘 받았다는 ACK 신호가 수신자로부터 송신자로 돌아오면, 해당 패킷의 수만큼 슬라이딩 윈도우는 앞으로 이동합니다.<br>
이러한 로직을 통해 한번에 다량의 패킷을 전송하면서 수신자의 버퍼가 오버플로우 되는 현상을 막을 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>전송계층이 제공하는 신뢰성 관련 기능 중, 오류제어(재전송 프로토콜)에 대해 설명해주세요.</summary>
오류제어는 데이터 통신 과정에서 발생할 수 있는 패킷의 손상이나 손실을 대처하는 방법입니다.<br>
이를 위해 재전송 프로토콜이라는 기법을 사용합니다.<br>
<br>

`Stop and Wait` 방식은 송신자가 데이터를 보내고, 해당 데이터에 대한 응답 (ACK)을 수신자로부터 받기 전까지 다음 데이터를 보내지 않습니다.<br>
이 방식은 간단하지만 네트워크의 전체 사용률을 높이기 어렵습니다.<br>
`Go-Back-N` 방식은 송신자가 여러 데이터를 연속으로 보내지만, 수신자가 오류를 감지하면 해당 오류가 발생한 지점부터 모든 데이터를 재전송합니다.<br>
성공한 데이터를 다시 보낼수도 있기에 약간의 비효율성이 발생할 수 있습니다.<br>
`Selective Repeat (SR)` 오류가 발생한 특정 데이터만 재전송하는 방식입니다.<br>
수신자가 데이터를 순차적으로 수신하지 않기 때문에, 데이터의 재정렬 과정이 필요합니다. 또한, 별도의 버퍼 공간이 요구됩니다<br>
<br>
순차적 수신 예시<br>
예를들어 패킷 1,2,3,4,5 순서대로 송신되었는데 3에서 오류 발생하면 3만 재전송을 요청<br>
이때 수신자 버퍼엔 이미 4,5가 도착했을수 있기에, 재전송된 패킷3이 도착했을때 수신자는 패킷들의 순서를 정렬해야함<br>
</details>

<details markdown = "1">
<summary>전송계층이 제공하는 신뢰성 관련 기능 중, 혼잡제어에 대해 설명해주세요.</summary>
송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달됩니다. 만약 한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 모두 처리할 수 없게 됩니다.<br>
이 경우 호스트들은 또 다시 재전송을 하고 결국 혼잡만 가중시켜 오버플로우나 데이터 손실을 발생시키게 됩니다.<br>
따라서 이러한 네트워크 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송속도를 강제로 줄이게 되는데, 이러한 작업을 혼잡제어라고 합니다.<br>
(흐름 제어가 송신측과 수신측 사이의 전송속도를 다루는데 반해, 혼잡제어는 호스트와 라우터를 포함한 넓은 관점에서 전송 문제를 다룸)<br>
<br>
<br>
-- 답변은 이 형식 ---<br>
네트워크의 혼잡(네트워크 내에 패킷의 수가 과도하게 증가하는 현상)을 피하기 위해 송신측에서 보내는 데이터의 전송속도를 제어하는 것입니다.<br>
이러한 혼잡 현상을 방지하고 제거하기 위한 기능이 혼잡제어로 다양한 방식이 존재합니다.<br>
<br>

`AIMD(Additive Increase/ Multiplicative Decrease)` 방식은 처음에 패킷을 하나씩 보내고 문제가 없다면(ACK를 성공적으로 받으면) Window Size를 1씩 증가시키는 방식입니다.<br>
만약 문제가 발생하면 Window Size를 절반으로 줄입니다.<br>
초기에 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리고 네트워크가 혼잡해지는 상황을 미리 감지하지 못합니다.<br>
<br>

`Slow Start` 방식도 앞선 AIMD와 마찬가지로, 패킷을 하나씩 보내면서 시작하며, ACK마다 윈도우 크기가 2배씩 증가하게 됩니다.<br>
윈도우 크기가 임계값에 도달하거나, 혼잡을 감지하면 윈도우 크기를 절반으로 줄이고 혼잡 회피 단계로 넘어가게 됩니다<br>
타임아웃이 발생하면 윈도우 크기를 1로 초기화하고 다시 Slow Start 단계를 시작합니다.<br>
<br>

`Fast Retransmit(빠른 재전송)`방식은 세개 이상의 중복된 ACK(동일한 ACK 번호)가 도착했을 때, 패킷 손실을 감지하는 메커니즘.<br>
일반적인 타임아웃을 기다리지 않고 즉시 해당 패킷을 재전송하게 됩니다.<br>
<br>
`Fast Recovery(빠른 회복)`방식은 빠른 재전송 후에 혼잡을 감지하면 윈도우 크기를 절반으로 줄입니다. 중복 ACK를 계속 수신하게 되면 윈도우 크기를 선형적으로 증가시킵니다<br>
</details>

<details markdown = "1">
<summary>DNS(Domain Name Server)이 무엇이죠?</summary>
도메인 이름과 IP주소와 도메인 이름 간의 변환을 도와주는 시스템을 의미합니다.<br>
</details>

<details markdown = "1">
<summary>www.google.com  도메인을 브라우저에 입력했을 때 일어나는 일을 순차적으로 설명해주세요.</summary>

1. 사용자가 브라우저의 주소창에 www.google.com을 입력합니다
2. 브라우저는 HSTS 목록을 조회하여 해당 URL이 HTTPS를 지원하는지 확인합니다. 지원한다면 요청은 HTTPS로 변환됩니다.
3. 브라우저는 이후 캐싱된 DNS 기록을 통해 통해 해당 도메인 주소에 대응하는 IP주소를 확인합니다.
4. 만약 요청한 URL에 대한 IP주소가 캐시에 없는 경우, ISP(인터넷 서비스 제공자)의 DNS 서버에 쿼리를 보내 호스팅하고 있는 서버의 IP주소를 찾습니다.
5. 브라우저는 해당 IP주소로 TCP연결을 시도합니다. 이 과정에서 3웨이 핸드쉐이크를 실행하여 서버와 연결을 확립합니다.
6. 연결이 완료되면 브라우저는 웹 서버에게 HTTP 요청 메세지를 생성하고 이를 전송합니다.
7. 서버는 받은 요청을 처리하고 해당 Response를 생성합니다.(HTTP 프로토콜을 활용해 메세지가 만들어짐)
8. 서버는 해당 응답 메세지를 TCP/IP연결을 통해 브라우저에 전송합니다.
9. 브라우저는 받은 응답을 렌더링하여 사용자에게 적잘한 형태로 화면에 출력합니다.
</details>

<details markdown = "1">
<summary>HOL 블로킹이란 무엇이며 HTTP에서는 이를 어떻게 해결하였나요??</summary>
HOL(Head-Of-Line)블로킹은 큐의 맨 앞에 있는 패킷이 처리 지연될 경우 그 뒤에 있는 패킷들도 같이 지연되는 현상을 의미합니다.<br>
HTTP(/2)에서는 이러한 문제를 해결하기 위해 MultiFlexing을 도입하였습니다.<br>
이는 하나의 연결에서 여러 요청과 응답 메세지를 동시에 처리할 수 있도록 하는 기술로, 각 요청과 응답은 별도의 스트림에서 처리되기 때문에, 하나의 스트림에서 지연이 발생하더라도 다른 스트림에는 영향을 미치지 않습니다.<br>
</details>

<details markdown = "1">
<summary>HTTP 통신과 소켓 통신의 차이점을 설명해주세요</summary>
소켓 통신은 서버와 클라이언트가 특정 포트를 통해 연결을 유지하고, 실시간으로 양방향 통신을 하는 방식으로 실시간으로 데이터를 주고 받는 경우에 사용됩니다.<br>
반면 HTTP 통신은 클라이언트가 요청을 보내는 경우에만 서버가 응답하는 단방향 통신입니다. 필요한 경우에만 서버로 접근하는 콘텐츠 위주의 데이터를 사용할때 용이합니다.<br>
</details>


<details markdown = "1">
<summary>TCP Connection시 3-way handshaking을 한다고 했는데, 이에 대해 설명해주세요.</summary>
3-way handshaking은 TCP에서 연결을 초기화하기 위한 과정입니다.<br>
우선 클라이언트가 서버에 연결 요청을 시작하기 위해 SYN 패킷을 보냅니다.(이 패킷에는 임의의 시퀀스 번호를 포함함)<br>
서버는 SYN 패킷을 받았음을 확인하기 위해 ACK를 보내고, 동시에 자신도 데이터를 보내기 위한 준비가 되었음을 알리기 위해 자신의 SYN 패킷을 보냅니다.<br>
클라이언트는 서버가 보낸 ACK와 SYN 패킷을 받고. ACK 패킷을 보내면서 연결 설정을 완료합니다.<br>
이 과정은 클라이언트와 서버 간에 안정적인 연결을 수립하고, 양쪽 모두 데이터 전송을 위한 준비가 되었음을 확인하기 위해 진행됩니다.<br>
<br>
참고 내용<br>
첫번째로 클라이언트는 서버에게 SYN 패킷을 보냅니다. 그리고 자신의 시퀀스 넘버 x를 보냅니다. 서버는 똑같이 SYN과 시퀀스 넘버 y를 보내고 패킷을 잘 받았다는 의미의 ACK=x+1을 보냅니다. 클라이언트는 응답을 받고 마지막으로 ACK=y+1을 보냅니다. 이 과정에서 클라이언트, 서버는 ACK를 받고 센더용 버퍼, 리시버용 버퍼를 생성하게 됩니다.<br>
</details>

<details markdown = "1">
<summary>4-way-handshaking에 대해 설명해주세요.(TCP 연결 해제 과정)</summary>
HTTP 요청과 응답 과정이 끝난 후, 연결 과정을 종료하는 4-way-handshaking이 진행됩니다.<br><br>

1. 클라이언트가 서버로 연결을 종료하겠다는(or 데이터 전송이 완료되었음을 서버에 알리기 위해) FIN 플래그가 설정된 패킷을 전송합니다.
2. 서버는 클라이언트에게 FIN 패킷을 받고,  응답하는 ACK를 보냅니다.(이 시점에서 서버는 클라이언트로부터 데이터 수신을 중단함.)
3. 서버가 보낼 데이터를 모두 전송한 후, 클라이언트에게 자신도 연결을 종료하려고 함을 알리기 위해 FIN 플래그가 설정된 패킷을 보냅니다.
4. 클라이언트는 서버가 보내온 FIN 패킷을 받고, 연결 종료에 대한 마지막 ACK 신호를 보냅니다.(이후 TCP 완전히 종료됨)

<br><br>
꼬리질문 1 - 4way가 한단계 더 많은 이유 or 해제시 사용 이유<br>
클라이언트가 서버에게 모든 데이터 요청을 보냈더라도, 서버 측에서는 클라이언트에게 아직 전송해야 할 데이터가 남아있을 수 있습니다. 따라서 서버는 데이터 전송을 완료한 후에야 FIN 메시지를 전송합니다. 이 과정을 통해 양측 모두가 데이터 전송을 완료하였음을 확인하고 연결을 안전하게 종료할 수 있습니다<br>
TCP는 양방향 통신이기에 송수신에 독립된 회선사용. 따라서 이에 대해 각각의 연결을 종료해야되기 떄문<br>

<br><br>
꼬리질문 2 - 그렇다면, Server가 Client에게 FIN 플래그를 전송하기 전에 전송한 패킷이 지연이나 유실로 인해 재전송이 일어나 FIN 패킷보다 늦게 도착하면 어떻게 처리를 하나요?<br>
이런 일을 방지하기 위해서, Server로부터 Client가 FIN 플래그를 받더라도 바로 세션을 종료시키지 않고 일정시간 잉여 패킷을 기다리는 과정을 거칩니다.<br>

<br><br>
꼬리질문 3 - 초기 Sequence Number인 ISM을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유는???<br>
ISN을 난수로 시작하는 주된 이유는 보안과 관련이 있습니다. ISN이 예측 가능하면, 공격자가 이를 이용해 TCP 세션을 하이재킹하거나 다른 형태의 중간자 공격을 수행할 수 있습니다. 만약 ISN이 항상 0부터 시작한다면, 공격자는 이전 세션의 패킷과 현재 세션의 패킷을 혼란스럽게 만들 수 있어, 패킷 조작이나 재전송 공격이 가능해집니다<br>
<br>
커넥션을 맺을 때 사용하는 포트는 시간이 지남에 따라 재사용된다. 따라서 두 통신이 과거에 사용된 포트 번호 쌍을 사용할 가능성이 생기고 난수가 아닌 순차적 Number가 전송된다면 이전의 커넥션으로부터 오는 패킷으로 인식할 가능성이 생긴다<br>
</details>

<details markdown = "1">
<summary>포트와 소켓이 무엇인지에 대해 설명해주세요.</summary>

`포트`는 호스트 내에서 네트워크 통신을 하는 프로세스나 서비스를 식별하기 위한 고유한 번호입니다(0 ~ 65535, 보통 TCP,UDP에서 사용).<br>
이를 통해 하나의 IP 주소를 가진 컴퓨터에서도 여러 개의 서비스나 프로세스가 동시에 네트워크 통신을 할 수 있습니다.(ex: 웹서비스는 80, SSH는 22)<br>
(포트번호는 IP주소와 결합하여 송신 및 수신측 프로세스간의 통신을 가능하게함)<br>
<br>

`소켓`은 네트워크상에서 동작하는 프로그램 간 통신의 종착점으로, 두 시스템 사이의 네트워크 연결을 나타내는 객체입니다<br>
(IP 주소 + 포트 번호로 나타낼 수 있음, 이를 통해 네트워크 상 특정 컴퓨터의 프로세스나 서비스와 통신가능)<br>
소켓을 열기 위해서는(통신을 위해) IP, 포트 번호, 프로토콜이 필요하고, 송수신자 모두 소켓을 열어야 합니다.<br>
(특정 포트를 사용하여, 하나의 프로세스가 여러 개의 연결을 수립하려면 각 연결에 대해 고유한 소켓이 생성됩니다)<br>
<br><br>
포트는 특정 서비스나 프로세스가 네트워크상에서 통신하기 위한 끝점의 번호를 나타내며, 소켓은 실제 통신을 위한 양쪽 끝점을 의미합니다.<br>
</details>

<details markdown = "1">
<summary>TCP와 UDP가 무엇인지와 차이에 대해 설명해주세요.</summary>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/a8d9b416-bff4-479a-848e-069b786a7214"> <br><br>

`TCP(Transmission Control Protocol)`은 신뢰성 있는 연결형 서비스를 지원하는 전송계층 프로토콜입니다.<br>
TCP는 연결 설정 및 해제를 위해 3 웨이 핸드쉐이크와 4웨이 핸드쉐이크를 사용하고, 순서대로 데이터를 전송하며, 중간에 유실되는 데이터는 재전송됩니다.<br>
흐름 제어, 혼잡 제어, 오류 제어등의 기능을 제공하고, 전이중 통신 방식을 사용하여 양방향으로 동시에 데이터 전송 이 가능합니다.(근데 전이중 통신은 TCP,UDP 둘다 가능함 답변시 빼야할듯)<br>
(점대점 방식으로 연결, 멀티캐스팅이나 브로드 캐스팅 지원 X)<br>
<br>
`UDP(User DataGram Protocol)`은 비연결형 서비스를 지원하는 전송계층 프로토콜 입니다.(최소한의 오류 검출 기능만 제공, 오류 복기 기능 X)<br>
tcp와 다르게 데이터의 전송 순서를 보장하지 않고, 수신 여부도 확인하지 않습니다.<br>
별도의 연결 과정을 진행하지 않고, Header 구성이 간단하여 전송 오버헤드가 적습니다.<br>
tcp보다는 빠른 전송 속도를 지원하므로, 스트리밍 서비스나, DNS 및 SNMP에 이용됩니다.<br>
(멀티 태스킹과 브로드 태스킹 지원)<br>
<br><br>
UDP와 TCP는 각각 독립된 포트 주소 공간을 가지므로, 동일한 포트 번호를 사용해도 충돌하지 않습니다.<br>
Checksum은 데이터와 헤더의 에러를 확인하는 용도로 사용됩니다. UDP의 헤더는 TCP에 비해 간단하므로, 오류 복구 기능이 불필요합니다.<br>
<br><br>
UDP가 TCP에 비해 갖는 장점<br>
- 연결 설정 및 해제 과정이 없어 시간 및 자원 소모 X
- 연결 상태를 저장하지 않기에 더많은 클라이언트 수용 가능(TCP는 연결 유지위해 송수신 버퍼, 각 파라미터 가지고 있어야)
- TCP는 20~60 바이트의 가변 헤더 크기를 가지지만, UDP는 8바이트로 고정<br>
- 패킷순서는 보장안되지만 데이터를 빠르게 전송 가능(흐름 제어를 안해서 빠르게 전송 가능, 재전송 순서보장등의 메커니즘이 없어서)
<br><br>
UDP에 체크섬 존재 이유 -> 오류 복구 기능은 없지만, 최소한의 오류 검출 기능을 제공하여 수신자가 패킷의 손상여부를 판단할 수 있게 하도록<br>
</details>

<details markdown = "1">
<summary>HTTP의 개념과 특징에 대해 설명해주세요.</summary>

`HTTP(HyperTesxt Transfer Protocol)`이란 인터넷에서 데이터를 주고 받는데 사용되는 프로토콜(통신 규약)로, 주로 웹 브라우저와 웹 서버간에 통신을 할때 사용됩니다.<br>
<br>

`비연결 지향(Connectionless)`: 클라이언트가 서버에 요청을 하면 서버는 해당 요청에 응답한 후 연결을 끊습니다. 이렇게 하면 많은 수의 사용자와 통신이 가능하게 됩니다.<br>
`상태 비저장(Stateless)`: 기본적인 HTTP는 서버가 클라이언트의 이전 상태나 정보를 저장하고 있지 않습니다. 즉, 각 요청은 독립적입니다. 이는 서버의 처리를 단순화시키지만, 상태를 유지해야 하는 웹 애플리케이션의 경우 쿠키나 세션 같은 기술을 사용하여 상태를 관리합니다.<br>
<br>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/62139d0e-fda6-4f78-afef-456d48c45742">
<br>
</details>

<details markdown = "1">
<summary>HTTP와 HTTPS의 차이점에 대해 설명해주세요.</summary>
둘다 웹 브라우저와 서버 간의 데이터를 주고 받기 위한 프로토콜이지만, 몇가지 주요한 차이점이 있습니다.<br>
가장 큰 차이점은 보안 부분입니다. HTTP는 평문(plain text)로 자원을 주고 받기에 네트워크를 중간에서 탈취되면 그 내용을 쉽게 확인할 수 있습니다.<br>
반면 HTTPS는 SSL이나 TLS 프로토콜을 이용해  데이터를 암호화(공개키 방식)하여 (전송 계층에 전달)전송합니다.<br>
그리고 기본적으로 HTTP는 80포트를 사용하고, HTTPS는 443포트를 사용합니다.<br>
정리하자면 HTTPS는 HTTP에 비해 데이터 암호화 및 서버 인증 기능을 제공하여 통신의 보안을 강화합니다.<br>
<br>
참고 <br>
HTTPS는 암호화 복호화를 진행하기에, 이 과정에서 서버에 부하가 발생함.<br>
헤더는 그대로 두고, 바디 부분만 암호화함<br>
HTTPS는 대칭키 암호화와 비대칭키 암호화가 혼합되어 사용됨<br>
대칭키가 안전하게 교환된 후에는 대칭키를 사용하여 실제 데이터를 암호화및 복호화 수행<br>
<br>
꼬리질문 1 - HTTPS 통신 흐름에 대해 설명해주세요.<br>

1. 사용자가 브라우저를 통해 HTTPS 웹사이트에 접속하려하면, 우선 브라우저는 해당 서버에 요청을 보냅니다.
2. 서버는 클라이언트에게 자신의 디지털 인증서를 전송합니다. 이 인증서는 일반적으로 CA(Certificate Authority)라고 하는 신뢰할 수 있는 제3자 기관에 의해 발급되며, 서버의 공개키 및 정보, 인증서를 발급한 CA의 서명이 포함되어있습니다.
3. 클라이언트(웹 브라우저)는 서버로 부터 받은 인증서의 유효성과 신뢰도를 확인합니다. 이때 클라이언트는 이미 알고 있는 CA의 공개키를 사용해 인증서의 서명을 검증합니다. 인증서가 유효하다면 서버를 신뢰할 수 있는 것으로 판단합니다.
4. 클라이언트는 데이터 암호화를 위한 일회용의 대칭키(session key)를 생성합니다.
5. 클라이언트는 서버의 인증서에 포함된 공개키로 대칭키를 암호화하여 서버에 전송합니다.
6. 서버는 자신의 개인키를 사용해 암호화된 대칭키를 복호화합니다.
7. 이제 클라이언트 서버 모두 동일한 대칭키를 가지고 있기에, 이 키를 사용하여 암호화 및 복호화를 하면서 데이터를 교환합니다.
8. 통신이 끝나면 대칭키는 폐기되고, 다음 세션을 위해서는 새로운 대칭키가 생성됩니다.

<br>
꼬리질문 2 - HTTPS란 무엇인가요??<br>
HTTPS는 HTTP의 보안 버전입니다.HTTPS는 통신중에 정보가 인터셉트 되거나 조작되는 것을(중간자 공격) 막기 위해 SSL/TLS로 암호화하여 정보를 주고받습니다.<br>
</details>

<details markdown = "1">
<summary>SSL 프로토콜에 대해 설명해주세요.</summary>
SSL(Secure Socket layer)는 웹 상에서 데이터를 암호화하여 전송하는 프로토콜입니다. 이는 사용자와 서버 간의 정보가 중간에서 공격자에 의해 도청되거나 변조되는 것을 방지하기 위해 설계되었습니다.<br>
<br>
참고 : 작동방식<br>
<br>

1. 클라이언트와 서버가 핸드쉐이크 과정을 통해 통신을 시작함.<br>
2. 이 과정에서 양쪽은 암호화에 사용될 키를 교환하며, 이후의 통신은 이 키를 사용해 암호화되어 진행됨.
3. 암호화된 데이터가 목적지에 도착하면, 수신 측에서는 미리 공유된 키를 사용해 데이터를 복호화하여 원래의 내용을 얻습니다.
<br>
후속 버전으로 TLS
</details>

<details markdown = "1">
<summary>HTTP 메서드에 대해 설명해주세요.</summary>
HTTP Method는 HTTP 요청의 종류를 나타내며, 서버가 클라이언트에게 요청을 어떻게 응답해야 할지를 알려줍니다(요청의 목적을 나타냄).<br>
이러한 HTTP Method에는 크게 GET, POST, PUT, PATCH,DELETE 등이 있습니다.<br>
<br>

`GET`은 주로 리소스(서버에 저장된 데이터) 조회에 사용됩니다. 이때 클라이언트가 서버로 데이터를 전달하고자 한다면 URL의 쿼리 파라미터를 통해 전달합니다.<br>
`POST`는 서버에 새로운 데이터를 등록하거나 서버에서의 특정 작업을 수행하기 위해 사용됩니다. POST의 경우 메시지 바디를 통해 데이터를 전송합니다.(민감한 정보 전달이나 복잡한 구조에 적합, 멱등성 보장 안됨)<br>
`PUT`은 리소스의 생성 또는 수정을 위해 사용됩니다. 지정된 URI에 리소스가 존재하면 덮어씌우고, 엎으면 새로 생성합니다.(멱등성 보장)<br>
`PATCH`는 리소스의 부분적인 수정을 위해 사용됩니다. (일반적으로는 멱등성이 보장안됨. 그러나 구체적인 동작은 API 디자인 및 구현에 따라 다름)<br>
`DELETE`는 지정된 URI의 리소스 삭제를 위해 사용됩니다.(멱등성 보장됨)
<br><br>
참고 - HTTP 메세지 내용은 보통 ASCII로 인코딩된 텍스트 정보로 구성되어있음
</details>

<details markdown = "1">
<summary>HTTP 상태 코드들에 대해서 설명해주세요.</summary>
HTTP 상태 코드란 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능을 하는 코드로, 숫자의 첫번째 자리에 따라 5개의 범주로 나눌 수 있습니다.<br>

- 백번 대(1xx : informational)는 요청이 수신되어 처리 중임을 의미합니다.
- 이백번대(2xx : successful)은 요청이 정상 처리되었음을 나타냅니다.
- 삼백번대(3xx : redirection)은 클라이언트에게 다른 위치로의 리다이렉션 또는 추가 동작이 필요함을 의미합니다(Location 헤더 사용).
- 사백번대(4xx : client error)는 클라이언트쪽의 요청에 문제가 있음을 나타냅니다.
- 오백번대(5xx : server error)는 서버 측의 문제로 인해 요청이 완료되지 않았음을 의미합니다.

<br><br>
201 Created -> Post로 뭔가 등록한 경우<br>
202 Accepted -> 요청이 접수되었으나 처리가 완료되지 않음(ex: 1시간 후 배치 동작)<br>
204 No Content는 서버가 요청을 성공적으로 수행했지만, 응답 페이로드에 보낼 데이터가 없는 경우<br>
<br>
301, 308 -> 리소스의 uri가 영구적으로 이동한 경우<br>
304 Not Modified는 클라이언트의 캐시된 버전이 유효한경우 서버가 반환하는 상태코드<br>
<br>
400 -> 잘못된 요청으로 서버 요청 처리 불가<br>
401 Unauthorized -> 클라이언트가 해당 리소스에 대한 인증이 필요할때<br>
403 Forbidden은 주로 인증 자격은 있지만, 접근 권한이 불충분한 경우 발생합니다.<br>
404 Not Found는 서버가 요청한 리소스 찾을수 없을때<br>
<br>

<br>

</details>

<details markdown = "1">
<summary>GET과 POST의 차이점에 대해 설명해주세요</summary>
우선 두 메서드는 사용 목적이 다릅니다.<br>
GET은 주로 서버의 리소스를 조회하는데 사용되는 반면(서버 영향 X), POST는 서버의 자원을 생성하거나 변경하는데 사용됩니다(서버 영향 O).<br>
그리고 GET은 주로 URL의 쿼리스트링에 데이터를 포함하지만, POST의 경우 주로 HTTP 메세지의 바디 부분에 포함시킵니다.<br>
GET은 멱등성을 가지기 떄문에 동일한 요청을 여러번 전송해도 동일한 결과가 반환됩니다. 이러한 특성 덕분에 캐싱에 적합합니다.<br>
반면 POST는 멱등성을 가지지 않습니다. 즉 같은 요청을 여러번 전송하더라도 결과가 달라질수있습니다. 따라서 캐싱에 적합하지 않습니다.<br>
<br>
참고 - GET은 주로 url 길이에 제한된 적은 양의 데이터만 전송됨, POST는 대용량 데이터를 전송하는데 적합(ex: 이미지, 동영상 등등)<br>
캐시를 사용하여 서버 부하 늦출수 있다, 만약 요청이 멱등성을 가지지 않는다면, 동일한 요청에 대해 다른 결과가 반환될 가능성이 있습니다.<br>
</details>

<details markdown = "1">
<summary>POST와 PUT의 차이점에 대해 말씀해주세요</summary>
POST 메서드의 경우 리소스를 생성할때 클라이언트가 그 경로를 직접 지정하지 않습니다. 대신 서버가 생성된 리소스의 URI를 응답 메세지의 Location 헤더를 통해 알려줍니다.<br>
반면 PUT은 리소스를 생성하거나 업데이트할때 그 경로를 직접 지정합니다.PUT은 특정 리소스에 대한 전체 업데이트를 의미하기 떄문입니다.<br>
<br>
POST는 멱등하지 않고 PUT은 멱등함<br>
</details>

<details markdown = "1">
<summary>PUT과 PATCH의 차이점에 대해 말씀해주세요</summary>
PUT과 PATCH는 모두 리소스를 수정하는데 사용되는 HTTP 메서드입니다.<br>
하지만 PUT 메서드는 리소스 전체를 업데이트하기 위해 사용됩니다. 예를들어, 리소스의 모든 필드를 새값으로 대처할때 PUT을 사용하게 됩니다.(만약 일부 필드만 제공되면, 누락된 필드는 null이나 기본값)<br>
반면 PATCH 메서드는 리소스의 일부만을 수정하기 위해 설계되어있습니다.<br>
그리고 보통 PUT은 멱등하게, PATCH는 멱등하지 않게 설계합니다.(절대적 기준은 아니고 설계에 따라 달라짐)<br>
<br>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/b36dd796-e597-4b2d-8408-2fd18e1d0223">
</details>

<details markdown = "1">
<summary>멱등성(idempotent)이 무엇인가요?</summary>
멱등성이란 동일한 요청을 여러 번 보내더라도 서버상의 결과(리스폰스라기 보다는 자원의 상태나 변화를 의미)가 바뀌지 않는 것을 의미합니다.<br>
(ex: 요청에 따라 데이터베이스 내의 특정 데이터가 변경되거나, 파일이 생성/삭제되는 경우 지칭, 동일한 멱등 요청이 여러번 전송될 경우 서버의 자우너 상태는 처음 요청을 처리한 후의 상태와 동일하게 유지됨)<br>
<br>
GET,PUT,DELETE는 멱등성 메소드에 속하고, POST는 멱등성 메소드가 아님<br>
예를들어, 게시글 작성이나 댓글 추가와 같은 연산에서 POST 요청을 여러번 보내면, 중복된 게시글이나 댓글이 생성될 수 있습니다.<br>
GET은 여러 번 수행해도 서버의 상태가 변하지도 않고 같은 결과를 가져온다.<br>
PUT은 여러 번 수행해도 결과적으로 데이터는 요청한 값으로 수정된 항상 같은 상태이다.<br>
DELETE도 여러 번 수행해도 이미 존재하든, 존재하지 않든 그 데이터는 DELETE 요청을 보낸 시점에 사라진다.<br>
PATCH의 멱등성은 구현에 따라 달라질수있음.<br>
<br>
추가 질문1 - safe라는 개념은 무엇인가?<br>
safe는 서버에 있는 자원에 대해 읽기만 수행하고, 그 자원의 상태나 값을 변경하지 않는 다는 것을 의미, 대표적으로 GET 메서드가 있음<br>
</details>

<details markdown = "1">
<summary>HTTP의 Keep-alive 헤더에 대해 설명해주세요.</summary>
HTTP의 Keep-alive 헤더는 지속적인 연결(persistent connection)을 관리하기 위한 헤더입니다.<br>
HTTP/1.0에서는 기본적으로 연결이 비 지속적이였기에, 클라이언트와 서버간의 각 요청 및 응답 이후 연결이 종료되었습니다.이로 인해 매번 새로운 연결을 생성하는 오버헤드가 발생하였습니다.<br>
Keep alive 헤더를 사용하면, 클라이언트와 서버는 현재 연결을 유지하면서 여러번의 요청과 응답을 주고 받을 수 있습니다.<br>
이로 인해 연결 설정 오버헤드를 줄이고, 더 빠른 응답시간을 얻을 수 있는 장점을 제공합니다.<br>
<br>
HTTP/1.1에서는 연결이 기본적으로 지속적입니다. 그러므로 HTTP/1.1에서는 지속적인 연결을 사용하려면 별도의 Keep-Alive 헤더를 지정할 필요가 없습니다. 그러나 연결을 비지속적으로 변경하려면 Connection: close 헤더를 사용해야 합니다.<br>
</details>

<details markdown = "1">
<summary>HTTP 1.0과 1.1 차이에 대해 설명해주세요</summary>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/7643d6ff-f10d-46ad-93e7-b8a5d9c2cc1d">
<br>
HTTP 1.0은 기본적으로 비지속적 연결을 사용합니다.<br>
클라이언트가 서버에 요청을 보낼때마다 새로운 TCP 커넥션을 생성하고, 응답을 받은 후 해당 커넥션을 종료합니다. 이로 인해 각 요청에 대한 연결 설정과 종료의 오버헤드가 발생되어 비효율적입니다.<br>
(Keep-alive 헤더를 사용하여 연결을 지속적으로 유지할순 있지만 표준이 아니였음.)<br>
반면 HTTP 1.1은 지속적 연결이 기본입니다. 따라서 클라이언트와 서버는 현재 연결을 유지하면서 여러번의 요청과 응답을 교환할 수 있게 됩니다.<br>
<br>
그리고 HTTP 1.0은 요청과 응답이 순차적으로 진행됩니다.(즉 첫번째 요청이 응답을 받아야지만 두번쨰 요청을 할 수 있습니다)<br>
하지만 HTTP 1.1은 파이프라이닝 기능을 통해 클라이언트는 여러 요청을 연속적으로 보낼 수 있습니다.<br>
하지만 서버는 여전히 응답을 순차적으로 처리하며, 이로 인해 첫번째 요청에서 발생한 지연이 후속 요청의 처리를 지연시킬 수 있습니다(HOL : Head of Line Blocking 문제)<br>
<br>
참고 - 이거 말고도 호스트 이름을 기반으로 여러 도메인을 하나의 IP 주소에 호스팅할 수 있게 해주는 Host 헤더를 도입하였습니다.<br>
</details>

<details markdown = "1">
<summary>HTTP 2.0의 특징에 대해 설명해주세요</summary>
HTTP 2.0에서는 멀티플렉싱, 헤더 압축, 서버 푸시를 지원하는 프로토콜입니다.<br>
<br>

`멀티플렉싱`은 여러개의 스트림을 사용하여 송수신을 합니다. 이를 통해 특정 스트림의 패킷이 손실되었다 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림에는 영향을 미치지 않습니다.<br>
그리고 병렬로 여러 요청을 받을 수 있고, 응답을 줄수 있습니다.(가장 빨리 처리된 응답부터 클라이언트에게 전달)<br>
<br>
HTTP 1.1에서는 매 요청마다 반복되는 헤더 정보가 포함되어 비효율적이였습니다. 이를 위해 HTTP 2.0에서는 허프만 코딩이라는 특별한 알고리즘을 사용하여 헤더를 압축함으로서 전송 데이터의 크기를 줄입니다.(네트워크 대역폭 절약, 성능 향상)<br>
<br>
또한 서버 푸시를 통해 서버는 클라이언트가 요청하기 전에 필요한 리소스를 미리 푸시할 수 있습니다.<br>
ex) 예를 들어, HTML 문서를 요청했을 때 필요한 CSS나 자바스크립트 파일을 클라이언트가 별도로 요청하지 않아도 미리 전송해줄 수 있습니다<br>
<br>
참고 - 허프만 코딩은 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트수를 사용하여 표현하고, 빈도가 낮은 정보는 비트수를 많이 사용하여 표현해서 전체 데이터의 표현에 필요한 비트양을 줄이는 원리<br>
병렬 -> 여러 작업을 동시에 처리한다는 것<br>
</details>

<details markdown = "1">
<summary>CORS(Cross Origin Resource Sharing)가 무엇인지 설명해주세요.</summary>
CORS는 추가적인 HTTP 헤더를 사용하여, 한 오리진(프로토콜 + 도메인 + 포트번호)에서 실행 중인 웹페이지가 다른 오리진의 (선택한) 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 메커니즘입니다.<br>
<br>
기본적으로 웹 브라우저의 보안 정책으로 인해 한 오리진에서 호스팅되는 웹페이지를 다른 오리진의 리소스에 직접 접근할 수 없습니다. 그러나 웹 애플리케이션에서는 종종 다른 오리진의 리소스에 접근해야할 필요가 있습니다.<br>
<br>
CORS는 서버 측에서 응답에 (Access-control-allow-origin)특별한 헤더를 포함시켜, 특정 출처의 애플리케이션이 자원에 접근할 수 있도록 허용할지를 지정할 수 있게 됩니다.<br>
결과적으로, CORS는 안전하게 다른 오리진의 리소스와 상호작용할 수 있게 하는 보안 표준입니다.<br>
<br>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/f3c7f2ab-694c-42bc-add4-391cbd170cd6">
</details>

<details markdown = "1">
<summary>REST API가 무엇인가요? RESTFUL이 무엇인가요?</summary>
(이걸 통해 백과 프론트 통신함)<br>
<br>
REST API는 REST 원칙에 따라 서비스 API를 구현한 것입니다.<br>
여기서 REST는 자원의 표현, 즉 이름(URI)으로부터 자원의 정보를 주고받는 것을 의미합니다.<br>
따라서 자원을 uri로 표현하고 자원에 대한 행위는 HTTP 메서드로 표현한것이 REST API의 핵심입니다.<br>
<br>
RESTFUL이라는 것은 REST 원칙을 잘 따르는 시스템을 의미합니다.<br>
자원은 uri로 나타내고, 행위에 맞는 적절한 HTTP 메서드를 사용한 것이 RestFul한 API라고 할 수 있습니다.<br>
<br>
RESTFUL 하지 않은 경우를 예로 들자면, CRUD 기능을 모두 POST로만 처리한 것을 RESTFUL 하지 않다고 말할 수 있습니다.(URL에 동사를 사용한 경우 포함)<br>
<br>
참고<br>
URI는 Uniform Resource Identifier의 약자로, 인터넷 상의 자원을 고유하기 식별하거나 이름을 부여하는데 사용된 문자열을 말합니다.<br>
URI는 URL을 포괄하는 더 큰 범주, 모든 URL는 URI<br>
REST는 HTTP 프로토콜을 기반으로 동작하기 때문에, HTTP의 특징들을 그대로 활용할 수 있습니다. 예를 들어, 무상태성을 활용하여 클라이언트와 서버 간의 상호작용이 독립적으로 유지되거나, 캐시 기능을 사용하여 효율적인 데이터 처리가 가능합니다.<br>
</details>

<details markdown = "1">
<summary>쿠키와 세션이 무엇이죠?</summary>
기본적으로 HTTP 프로토콜은 connectionless(비연결형), stateless(무상태)한 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인하는 절차가 필요했습니다.<br>
이러한 단점을 보완하는 것이 쿠키와 세션입니다.<br>
<br>
쿠키는 클라이언트 측에 저장되는 작은 텍스트 파일입니다.<br>
서버에서 HTTP 응답 헤더를 통해 클라이언트에게 쿠키를 전송하고, 클라이언트는 다시 해당 서버에 요청을 보낼 때 HTTP 요청 헤더에 저장된 쿠키를 포함하여 전송합니다.<br>
그리고 이후에 같은 서버로 요청을 보낼때마다, 쿠키를 서버로 함께 전송하게 됩니다.<br>
<br>
세션은 서버 측에서 클라이언트의 상태를 유지하기 위한 기술입니다.<br>
클라이언트가 서버에 요청을 보내면(ex: 로그인 요청), 서버는 클라이언트에게 세션 ID를 부여하고, 해당 세션 ID에 대한 정보를 서버 측에서 유지합니다.<br>
이후 클라이언트가 서버에 요청을 보낼때 마다, 세션 ID를 함께 전송하고, 서버는 이를 통해 클라이언트의 상태를 식별합니다.<br>
<br><br>
참고 - 보통 두개 같이 사용함<br>
키는 만료 시간 부여하고, 세션은 브라우저 종료 시 소멸되는 특성(이거 보다는 보통 일정 시간동안 유지되고, 그 시간동안 사용자가 다시 요청 안보내면 세션을 만료될 수 있음)<br>
세션은 서버의 자원을 사용하기 때문에 사용자가 많을 수록 소모되는 자원이 많기 때문에 상황을 잘 고려해서 사용해야 한다.<br>
쿠키는 클라이언트 측에 저장되므로, 쉽게 접근 가능. 만약 암호화 안하고 중요한 정보가 저장되면 위험함<br>
쿠키는 HTTP 통해 전송되며, HTTPS 사용안하면 중간자 공격(트래픽을 도청하여 쿠키 내용 캡쳐)에 취약<br>
XSS는 악의적인 스크립트를 애플리케이션에 삽입하여 실행되게 하는 공격. 이를 통해 공격자는 사용자 쿠키에 접근 가능<br>
CSRF(크로스 사이트 요청 위조) : 사용자가 자신의 의지와는 무관하게 악의적 요청을 웹에 보내게 만드는 기술.(여기에 종종 사용자 쿠키가 이용됨)<br>
</details>

<details markdown = "1">
<summary>쿠키와 세션을 이용하여 로그인하는 과정을 설명해주세요</summary>

1. 사용자가 로그인 정보를 입력 후 로그인 요청을 합니다.
2. 서버는 입력받은 로그인 정보가 유효하다면, 사용자에 대한 세션을 생성합니다. 이 세션에는 사용자 식별 정보와 다른 필요한 데이터들이 저장됨
3. 서버는 생성한 세션의 ID를 응답 헤더에 포함시켜 사용자의 웹에 전송합니다.
4. 브라우저는 받은 세션ID를 쿠키에 저장합니다(세션 쿠키라고도 함).
5. 이후 사용자가 다른 페이지를 요청할 때마다 브라우저는 세션 ID가 저장된 쿠키를 서버로 함께 전송합니다.
6. 서버는 전송받은 세션 ID를 이용하여 세션 저장소에서 사용자의 세션을 찾아냅니다. 이를 통해 사용자가 로그인 상태임을 확인합니다.(특화된 정보나 서비스 제공)

</details>

<details markdown = "1">
<summary>만약 session의 값을 가져오는 key를 "user"라고 합시다, 사용자 A가 접속해도, B가 접속해도 "user"라는 key를 통해 가져오는데 어떻게 각각 다른 결과 값을 받을 수 있는지 설명해주세요.</summary>
서버는 세션을 생성할때 그에 대응하는 고유한 세션 ID를 만들고 이는 클라이언트의 브라우저에게 전송됩니다.<br>
즉 각 클라이언트마다 고유한 세션 아이디가 있고, 이는 서버상의 각각의 세션 객체와 연결되어있습니다.<br>
이러한 방식으로, 서버는 여러 클라이언트의 상태를 독립적으로 관리하게 됩니다<br>
<br>
유사질문<br>
세션은 서버에 저장되고, 쿠키는 클라이언트에 저장된다고 하셨는데, 그럼 쿠키가 안되는 상황에서도 세션은 사용할 수 있나요?<br>
쿠키를 사용할 수 없을 때는 url 뒤쪽에 파라미터 값으로 전달하는 경우가 있다.<br>
</details>

<details markdown = "1">
<summary>JWT에 대해 설명해주세요.</summary>
JWT(Json Web Token)란 JSON형식의 웹토큰으로 클라이언트와 서버 사이에서 인증 및 권한 부여 작업을 수행할 수 있습니다.<br>
JWT는 Header, Payload, Signature로 구성되어있습니다.<br>

`Header`에는 토큰의 유형(ex: JWT)과 사용된 서명 알고리즘(ex: RSA, SHA256)과 같은 메타데이터 정보를 담고있습니다.<br>
`Payload`에는 토큰에서 사용할 정보의 조각들인 Claim(등록된, 공개, 비공개로 나뉨, 키 : 값 형태)이 담겨있습니다.클레임에는 사용자 식별을 위한 고유 ID와 같은 정보들이 담겨있습니다.<br>
`Signature`은 토큰을 인코딩하거나 유효성 검증을 할때 사용하는 고유한 암호화 코드입니다.<br>
사용자가 로그인 요청을 할 때, 서버는 사용자의 인증을 확인하고 JWT를 생성하여 클라이언트에게 반환합니다. 클라이언트는 이후 요청마다 JWT를 포함하여 서버에 전송하고, 서버는 Signature 부분을 검증하여 토큰의 유효성 및 무결성을 확인합니다.<br>
<br>
단점들<br>
페이로드 자체는 암호화된 것이 아니라 BASE64로 인코딩 된 것이다. 중간에 Payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로 JWE로 암호화하거나 Payload에 중요한 데이터를 넣지 않아야한다.<br>
Stateless : JWT는 상태를 저장하지 않기 때문에 한번 만들어지면 제어가 불가능하다. 즉, 토큰을 임의로 삭제하는 것이 불가능하므로 토큰 만료시간을 꼭 넣어주어야한다.<br>
<br>
주의점<br>
탈취에 의해 악의적으로 사용될 가능성이 있기에 보통 유효시간을 짧게 가져가고 Refresh 토큰을 사용하는 방식으로 구현한다<br>
</details>

<details markdown = "1">
<summary>JWT를 이용하여 로그인 하는 과정을 설명해주세요</summary>

1. 클라이언트가 로그인 페이지에 접속하여 로그인 정보를 입력합니다.
2. 서버는 입력받은 로그인 정보를 인증하고, 로그인에 성공하면 해당 사용자 정보를 기반으로 JWT를 생성합니다.
3. 서버는 생성된 JWT를 클라이언트에게 전송합니다.
4. 클라이언트는 전송받은 JWT를 저장합니다.
5. 이후 클라이언트가 서버에 요청을 보낼때마다, JWT를 HTTP 헤더에 포함하여 전송합니다.
6. 서버는 전송받은 JWT를 이용하여 해당 사용자를 인증하고, 요청을 처리합니다.

</details>

<details markdown = "1">
<summary>JWT 리프레쉬 토큰에 대해 설명해주세요.</summary>
JWT의 refresh token은 클라이언트에게 주어진 긴 유효기간을 가진 토큰입니다.<br>
기본적인 JWT 토큰의 유효기간은 짧게 설정되는 경우가 많아, 유효 기간이 지나면 클라이언트는 이 refresh token을 사용하여 새로운 access token을 서버에 요청할 수 있습니다.<br>
이 방식을 사용하면 사용자가 자주 로그인해야 하는 번거로움을 줄이면서, 짧은 유효기간의 access token을 사용함으로서 보안을 강화할 수 있습니다.<br>
<br>
참고<br>
만약 refresh token이 노출되거나 유출된다면, 이 token으로 새로운 access token을 발급받을 수 있기 때문에 보안 관리가 중요합니다.<br>
</details>

<details markdown = "1">
<summary>URI와 URL의 차이점에 대해 설명해주세요</summary>
URL(Uniform Resource Locator)은 인터넷상의 자원의 위치를 의미합니다.<br>
URI(Identifier)는 인터넷 상의 자원을 식별하기 위한 문자열의 구성으로, URI는 URL과 URN 포함<br> 
</details>

---
## 기타 질문들

<details markdown = "1">
<summary>Blocking/Non-Blocking과 Synchronous/Asynchronous</summary>
Blocking은 호출된 함수가 자신의 작업이 완료될떄까지 제어권을 반환하지 않아서, 호출한 함수가 대기 상태에 있게 되는 방식을 뜻합니다. 즉, 해당 작업이 끝날때까지 다른 작업을 진행할 수 없습니다.<br>
Non Blocking은 호출된 함수가 자신의 작업을 즉시 완료할 수 없더라도, 제어권을 즉시 반환하여 호출한 함수가 다른 작업을 계속 진행할 수 있게 하는 방식을 의미합니다.<br>
<br>
동기는 작업을 수행할때, 해당 작업이 완료될떄까지 다른 작업을 수행하지 않는 방식입니다. 즉, 한 작업이 완료된 후에 다음 작업이 실행됩니다.<br>
비동기는 한 작업을 시작하고 완료를 기다리지 않고 바로 다음 작업을 시작하는 방식입니다. 콜백, 프로미스, 이벤트 리스너등의 메커니즘을 통해 완료시점을 알림<br>
<br>
간단하게 말하면, Blocking/Non-Blocking은 작업이 완료될 때까지 기다리느냐 아니냐에 관한 것이고, Synchronous/Asynchronous는 작업을 수행하는 방식이 순차적으로 진행되느냐 동시에 여러 작업이 진행되느냐에 관한 것입니다.<br>
</details>

<details markdown = "1">
<summary>네트워크의 전체 흐름을 설명해보세요.</summary>

- 응용 계층에서 HTTP 메세지를 보냄
- 전송 계층으로 이 데이터가 전달되고, 여기서 TCP 헤더가 붙어 세그먼트가 됨. TCP 헤더에는 어느 애플리케이션에 데이터를 보내야할지 담겨 있음. 출발지 번호와 목적지 포트 번호가 그역할. 출발지 포트 번호는 잘알려진 포트가 아닌 포트 중에서(1025 이상) 무작위로 선택됨. 목적지 포트는 HTTP라 80선택
- 네트워크 계층으로 세그먼트 데이터가 전달되고, 여기서 IP헤더가 붙음. IP헤더에 출발지 컴퓨터와 목적지 서버의 위치가 각각 출발지 IP주소, 목적지 IP 주소 형태로 추가됨. IP헤더가 붙은 데이터를 IP 패킷이라 함.
- 데이터 링크 계층으로 IP 패킷이 전달됨, 여기서 이더넷 헤더가 붙음. 이더넷 헤더가 붙은 데이터를 이더넷 프레임이라고 부름
- 물리계층으로 이더넷 프레임이 전달되고, 이 데이터가 전기 신호로 변환되어(랜 카드를 통해) 네트워크로 전송됨

</details>

<details markdown = "1">
<summary>대칭키, 비대칭키 암호화 방식에 대해 설명해주세요.</summary>
대칭키 암호화와 복호화에 같은 키를 사용하는 방법입니다.<br>
비대칭키는 암호화와 복호화에 서로 다른 키를 사용하는 방법입니다.<br>
타인에게 노출되어서는 안되는 개인키(private key)와 공개적으로 개방되어있는 공개키가 쌍을 이룬 방식입니다.<br>
<br>
공개키 -> 암호화에 사용, 개인키는 데이터 복호화에 사용됨<br>
</details>

<details markdown = "1">
<summary>공인(public) IP와 사설(private) IP의 차이에 대해 설명해주세요</summary>
공인 IP는 ISP(인터넷 서비스 공급자)가 제공하는 IP 주소이며, 외부에 공개되어 있습니다.<br>
사설 IP는 일반 가정이나 회사 내 등에 할당된 네트워크 IP 주소이며, IPv4의 주소부족으로 인해 서브넷팅된 IP이기 떄문에 라우터(공유기)에 의해 로컬 네트워크상의 PC나 장치에 할당됩니다.<br>
</details>

<details markdown = "1">
<summary>라우터란 무엇이죠?</summary>
라우터는 네트워크에서 데이터 패킷의 전송을 중개하는 장치입니다.<br>
라우터는 네트워크 내에서 패킷을 수신하면 해당 패킷의 목적지 주소를 확인합니다. 이후 포워딩 테이블이라는 내부 정보를 참조하여 패킷을 올바른 목적지로 전송합니다.(포워딩 테이블)<br>
라우팅은 라우터가 네트워크 구조를 이해하고, 최적의 경로를 결정하여 포워딩 테이블을 생성 및 유지하는 과정을 의미합니다. 이를 통해 라우터는 다양한 경로 중 가장 효율적인 경로로 데이터 패킷을 전송합니다.<br>
</details>

<details markdown = "1">
<summary>IP와 IP 주소에 대해 설명해주세요.</summary>
IP는 인터넷 프로토콜의 약자로, 컴퓨터 네트워크에서 데이터를 패킷 형태로(분할하여) 전송하는 규약입니다.<br>
IP주소는 인터넷 상에서 컴퓨터나 네트워크 장비가 유일하게 식별될 수 있도록 부여하는 주소입니다.<br>
가장 널리 사용되는 IPV4는 32비트 주소체제를 사용하고, 8비트씩 끊어서 10진수로 나타냅니다.
IP주소는 크게 네트워크 ID(서브넷 ID)와 호스트 ID로 구분됩니다. 이 둘은 서브넷 마스크를 통해 구분되며, 네트워크의 구조나 규모에 따라 유동적으로 할당 될 수 있습니다.<br>
초기에는 Class A, B, C와 같은 방식으로 IP 주소를 구분하였으나, 최근에는 CIDR(Classless Inter-Domain Routing) 방식을 사용하여 보다 유연하게 주소를 할당하고 관리하게 되었습니다<br>
<br>
`서브넷 마스크` : IP주소의 네트워크 부분과 호스트 부분을 구분하는데 사용<br>
</details>

<details markdown = "1">
<summary>NAT(Network Address Translation)이 무엇이죠?</summary>
개인 네트워크의 IP주소를 인터넷에 연결될 때 공용 IP 주소로 변환하는 기술입니다.<br>
주로 가정이나 기업 내부 네트워크에서 사용하는 사설 IP 주소를 외부 인터넷으로 나갈때 공인 IP주소로 매핑하여 통신이 가능하게 합니다.<br>
이를 통해 IP 주소 부족 문제를 완화하고 보안을 강화할 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>이더넷이 무엇이죠?</summary>
컴퓨터 네트워크 기술의 일종으로 LAN에서 가장 많이 활용되는 네트워크 규칙입니다.<br>
이러한 이더넷에서는 CSMA/CD라는 프로토콜을 사용합니다.<br>
<br>
꼬리질문 1 - CSMA/CD가 뭐죠?<br>
이더넷 네트워크에서 데이터 충돌을 감지하고 관리하기 위한 프로토콜입니다.<br>
만약 두 장치가 동시에 데이터를 전송하게 되면 충돌이 감지되고, 감지된 후에 해당 장치들은 임의의 시간을 기다린 후 다시 전송을 시도합니다.<br>
<br>
꼬리질문 2 - ARP가 무엇이죠?<br>
ARP는 IP주소를 통해 해당하는 MAC 주소를 찾아내는 프로토콜입니다.<br>
</details>

<details markdown = "1">
<summary>MAC(Media Access Control)주소는 무엇이죠?</summary>
MAC주소는 네트워크 하드웨어 장치(이더넷 카드, 와이파이 카드 등)의 고유한 식별자로, 6바이트(48비트)로 구성됩니다.<br>
(일반적으로 16진수 표기법으로 표현됨, ex) 00:1A:2B:3C:4D:5E)<br>
네트워크 환경에서 장치들 간의 통신을 할 때, 각 장치를 구분하기 위한 고유한 식별자가 필요합니다. IP 주소도 이런 식별 역할을 합니다만, IP 주소는 동적으로 변경될 수 있습니다. 반면, MAC 주소는 해당 장치의 하드웨어에 내장되어 있으므로 변경되지 않아, 안정적인 식별이 가능합니다.<br>
</details>

<details markdown = "1">
<summary>스위치는 무슨 기능을 하나요?</summary>
스위치는 LAN 내의 기기들을 연결해주고, 패킷이 서로 충돌없이 원하는 곳에 잘 도착할 수 있도록 도와줍니다.<br>
스위치 안에는 스위치 테이블이 존재하여 연결된 인터페이스들의 맥주소와 연결된 포트 번호를 담고있습니다.<br>
스위치는 데이터 링크 계층에서만 동작하기 떄문에 라우팅 같은 기능은 할 수 없습니다.<br>
</details>

<details markdown = "1">
<summary>방화벽에 대해 설명해주세요.</summary>
방화벽은 수신 및 발신 네트워크 트래픽을 모니터링하고, 정의된 보안 규칙을 기준으로 하여 특정 트래픽의 허용 또는 차단을 결정하는 네트워크 보안 디바이스 입니다.<br>
</details>

<details markdown = "1">
<summary>브루트 포스 공격이란 무엇인지 설명해주세요.</summary>
브루트포스(brute force)라는 의미 그대로 무차별 대입 공격을 말합니다.
브루트포스 공격 대상은 다양하지만 주로 시스템을 이용할 때 필요한 비밀번호나 암호키입니다.
이러한 공격에 대비하기 위해 비밀번호로 설정 가능한 조합의 수를 늘려 풀 수 있는 시간을 늘리는 수 밖에 없습니다.
모든 경우의 수를 대입하기 때문에 이론적으로 풀 수 없는 암호는 존재하지 않기때문입니다.<br>
</details>

<details markdown = "1">
<summary>버퍼 오버플로 공격이란 무엇인지 설명해주세요.</summary>
브루트포스(brute force)라는 의미 그대로 무차별 대입 공격을 말합니다.
브루트포스 공격 대상은 다양하지만 주로 시스템을 이용할 때 필요한 비밀번호나 암호키입니다.
이러한 공격에 대비하기 위해 비밀번호로 설정 가능한 조합의 수를 늘려 풀 수 있는 시간을 늘리는 수 밖에 없습니다.
모든 경우의 수를 대입하기 때문에 이론적으로 풀 수 없는 암호는 존재하지 않기때문입니다.<br>
</details>

<details markdown = "1">
<summary>크로스 사이트 스크립팅(XSS)이 무엇인가요?</summary>
XSS는 웹 애플리케이션의 취약성을 악용한 공격 수법으로, 사용자가 입력한 정보를 출력할 때 부정한 스크립트가 실행되도록 하는 공격기법입니다.<br>
ex) 사용자가 미끼 페이지 접속 -> 악의적 스크립트 있는지 모르고 웹페이지에 데이터 전송 -> 악성 스크립트가 포함된 response 반환 -> 결과적으로 악성 가짜 페이지로부터 공격 받게 됨.<br>
<br>
쿠키에 HTTPOnly 옵션을 활성화 하여 자바스크립트를 통해 쿠키값에 접근 못하게 하거나, 세션에 Sequre 기능활성화를 통해 HTTPS에서만 세션을 주고받게끔 할 수 있음.<br>
</details>

<details markdown = "1">
<summary>크로스 사이트 리퀘스트 포저리(CSRF)가 무엇인가요?</summary>
인터넷 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위 (modify, delete, register 등)를 특정한 웹사이트에 request하도록 만드는 공격을 말한다<br>
<br>
백엔드 단에서 Refferer 검증을 통해 승인된 도메인으로 요청시에만 처리하도록 한다.
Security Token 사용 -> 사용자의 세션에 임의의 난수 값을 저장하고, 사용자의 요청시 해당 값을 포함하여 전송시킨다. 백엔드 단에서는 요청을 받을 때 세션에 저장된 토큰값과 요청 파라미터로 전달받는 토큰 값이 일치하는 지 검증 과정을 거치는 방법<br>
</details>